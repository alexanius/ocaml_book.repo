<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.part{margin:2ex auto;text-align:center}
</style>
<title>Разработка программ с помощью Objective Caml 
Developing Applications with Objective Caml
</title>
</head>
<body >
<!--HEVEA command line is: hevea -o ocaml-book-full/ocaml-book-full.html styles/misc.hva src/main.tex -I . -I styles -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><table class="title"><tr><td><h1 class="titlemain">Разработка программ с помощью Objective Caml<br>
Developing Applications with Objective Caml</h1><h3 class="titlerest">Emmanuel Chailloux<br>
Pascal Manoury<br>
Bruno Pagano</h3></td></tr>
</table><!--TOC chapter id=sec1 Содержание-->
<h1 id="sec1" class="chapter">Содержание</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec2">Глава 1  Как заполучить Objective CAML</a>
</li></ul><ul class="toc"><li class="li-toc">
<a href="#sec3">Часть I  Основы языка</a>
<ul class="toc"><li class="li-toc">
<a href="#sec4">Глава 2  Функциональное программирование</a>
<ul class="toc"><li class="li-toc">
<a href="#sec5">2.1  Введение</a>
</li><li class="li-toc"><a href="#sec6">2.2  План главы</a>
</li><li class="li-toc"><a href="#sec7">2.3  Функциональное ядро Objective CAML</a>
<ul class="toc"><li class="li-toc">
<a href="#sec8">2.3.1  Значения, функции и базовые типы</a>
</li><li class="li-toc"><a href="#sec18">2.3.2  Структуры условного контроля</a>
</li><li class="li-toc"><a href="#sec20">2.3.3  Объявление значений</a>
</li><li class="li-toc"><a href="#sec24">2.3.4  Функциональное выражение, функции</a>
</li><li class="li-toc"><a href="#sec33">2.3.5  Полиморфизм и ограничение типа</a>
</li><li class="li-toc"><a href="#sec36">2.3.6  Примеры</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec39">Глава 3  Императивное программирование</a>
</li><li class="li-toc"><a href="#sec40">Глава 4  Функциональный и императивный стиль</a>
</li><li class="li-toc"><a href="#sec41">Глава 5  Графический интерфейс</a>
</li><li class="li-toc"><a href="#sec42">Глава 6  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec43">Часть II  Средства разработки</a>
<ul class="toc"><li class="li-toc">
<a href="#sec44">Глава 7  Компиляция и переносимость</a>
</li><li class="li-toc"><a href="#sec45">Глава 8  Библиотеки</a>
</li><li class="li-toc"><a href="#sec46">Глава 9  Автоматический сборщик мусора</a>
</li><li class="li-toc"><a href="#sec47">Глава 10  Средства анализа программ</a>
</li><li class="li-toc"><a href="#sec48">Глава 11  Средства лексического и синтаксического анализа</a>
<ul class="toc"><li class="li-toc">
<a href="#sec49">11.1  Введение</a>
</li><li class="li-toc"><a href="#sec50">11.2  План главы</a>
</li><li class="li-toc"><a href="#sec51">11.3  Лексика</a>
<ul class="toc"><li class="li-toc">
<a href="#sec52">11.3.1  Модуль <span style="font-family:monospace">Genlex</span></a>
</li><li class="li-toc"><a href="#sec53">11.3.2  Использование потоков</a>
</li><li class="li-toc"><a href="#sec54">11.3.3  Регулярные выражения</a>
</li><li class="li-toc"><a href="#sec60">11.3.4  Инструмент <span style="font-family:monospace">Ocamllex</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec62">11.4  Синтаксис</a>
<ul class="toc"><li class="li-toc">
<a href="#sec63">11.4.1  Грамматика</a>
</li><li class="li-toc"><a href="#sec64">11.4.2  Порождение и распознавание</a>
</li><li class="li-toc"><a href="#sec65">11.4.3  Нисходящий анализ</a>
</li><li class="li-toc"><a href="#sec68">11.4.4  Восходящий анализ</a>
</li></ul>
</li><li class="li-toc"><a href="#sec71">11.5  Пересмотренный Basic</a>
<ul class="toc"><li class="li-toc">
<a href="#sec72">11.5.1  Файл <span style="font-family:monospace">basic_parser.mly</span></a>
</li><li class="li-toc"><a href="#sec76">11.5.2  Файл <span style="font-family:monospace">basic_lexer.mll</span></a>
</li><li class="li-toc"><a href="#sec77">11.5.3  Компиляция, компоновка</a>
</li></ul>
</li><li class="li-toc"><a href="#sec78">11.6  Exercises</a>
</li><li class="li-toc"><a href="#sec79">11.7  Резюме</a>
</li><li class="li-toc"><a href="#sec80">11.8  To Learn More</a>
</li></ul>
</li><li class="li-toc"><a href="#sec81">Глава 12  Взаимодействие с языком C</a>
</li><li class="li-toc"><a href="#sec82">Глава 13  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec83">Часть III  Устройство программы</a>
<ul class="toc"><li class="li-toc">
<a href="#sec84">Глава 14  Модульное программирование</a>
</li><li class="li-toc"><a href="#sec85">Глава 15  Объектно-ориентированное программирование</a>
</li><li class="li-toc"><a href="#sec86">Глава 16  Сравнение моделей устройств программ</a>
</li><li class="li-toc"><a href="#sec87">Глава 17  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec88">Часть IV  Параллелизм и распределение</a>
<ul class="toc"><li class="li-toc">
<a href="#sec89">Глава 18  Процессы и связь между процессами</a>
</li><li class="li-toc"><a href="#sec90">Глава 19  Параллельное программирование</a>
</li><li class="li-toc"><a href="#sec91">Глава 20  Распределённое программирование</a>
</li><li class="li-toc"><a href="#sec92">Глава 21  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec93">Часть V  Разработка программ с помощью Objective CAML</a>
</li><li class="li-toc"><a href="#sec94">Часть VI  Приложения</a>
</li></ul>
<!--TOC chapter id=sec2 Как заполучить Objective CAML-->
<h1 id="sec2" class="chapter">Глава 1  Как заполучить Objective CAML</h1><!--SEC END -->
<!--TOC part id=sec3 Основы языка-->
<table class="center"><tr><td><h1 id="sec3" class="part">Часть I<br>
Основы языка</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec4 Функциональное программирование-->
<h1 id="sec4" class="chapter">Глава 2  Функциональное программирование</h1><!--SEC END -->
<!--TOC section id=sec5 Введение-->
<h2 id="sec5" class="section">2.1  Введение</h2><!--SEC END --><p>Первый язык функционального программирования LISP появился в конце 1950, в тот
же момент, что и Fortran — один из первых императивных языков. Оба этих языка
существуют и по сей день, хотя они немало изменились. Область их применения:
вычислительные задачи для Фортрана и символьные (symbolic) для Lisp. Интерес к
функциональному программированию состоит в простоте написания программ, где под
программой подразумевается функция, применённая к аргументам. Она вычисляет
результат, который возвращается как вывод программы. Таким образом можно с
лёгкостью комбинировать программы: вывод одной, становится входным аргументом
для другой.</p><p>Функциональное программирование основывается на простой модели вычислений,
состоящей из трёх конструкций: переменные, определение функции и её применение к
какому–либо аргументу. Эта модель, называемая λ–исчисление, была
введена Alonzo Church в 1932, ещё до появления первых компьютеров. В
λ–исчислении любая функция является переменной, так что она может быть
использована как входной параметр другой функции, или возвращена как результат
другой. Теория λ–исчисления утверждает что все то, что вычисляемо может
быть представлено этим формализмом. Однако, синтаксис этой теории слишком
ограничен, чтобы его можно было использовать его как язык программирования. В
связи с этим к λ–исчислению были добавлены базовые типы (например,
целые числа или строки символов), операторы для этих типов, управляющие
структуры и объявление позволяющие именовать переменные или функции, и в
частности рекурсивные функции.</p><p>Существует разные классификации языков функционального программирования. Мы
будем различать их по двум характеристикам, которые нам кажутся наиболее
важными:</p><ul class="itemize"><li class="li-itemize">
	без побочных эффектов (чистые), или с побочным эффектом
(не чистые): чистый язык — это тот, в котором не существует изменения
состояния. Все есть вычисление, и как оно происходит, нас не интересует. Не
чистые языки, такие как Caml или ML, имеют императивные особенности, такие как
изменение состояния. Они позволяют писать программы в стиле близкому к Фортрану,
в котором важен порядок вычисления выражений.<p>	</p></li><li class="li-itemize">язык типизирован динамически или статически: типизация необходима для
проверки соответствия аргумента, переданного функции, типу формального
параметра. Это проверка может быть выполнена во время выполнения программы. В
этом случае типизация называется динамической. В случае ошибки программа будет
остановлена, как это происходит в Lisp. В случае статической типизации проверка
осуществляется во время компиляции, то есть до выполнения программы. Таким
образом она (проверка) не замедлит программу во время выполнения. Эта типизация
используется в ML и в его диалектах, таких как Objective CAML. Только правильно
типизированные программы, то есть успешно прошедшие проверку типов, могут быть
скомпилированы и затем выполнены.
</li></ul>
<!--TOC section id=sec6 План главы-->
<h2 id="sec6" class="section">2.2  План главы</h2><!--SEC END --><p>В этой главе представлены базовые элементы функциональной части языка Objective
CAML, а именно: синтаксис, типы и механизм исключений. После этого вводного
курса мы сможем написать нашу первую программу.</p><p>В первом разделе описаны основы языка, начиная с базовых типов и функций. Затем
мы рассмотрим структурные и функциональные типы. После этого мы рассмотрим
управляющие структуры, а также локальные и глобальные объявления. Во втором
разделе мы обсудим определение типов для создания структур и механизм
сопоставления с образцом, который используется для доступа к этим структурам. В
третьем разделе рассматривается выводимый тип функций и область их применения,
после чего следует описание механизма исключений. Четвёртый раздел объединяет
введённые понятия в простой пример программы–калькулятора.

</p>
<!--TOC section id=sec7 Функциональное ядро Objective CAML-->
<h2 id="sec7" class="section">2.3  Функциональное ядро Objective CAML</h2><!--SEC END --><p>
<a id="sec:caml_kernel"></a></p><p>Как любой другой язык функционального программирования, Objective CAML — это
язык выражений, состоящий в основном из создания функций и их применения.
Результатом вычисления одного из таких выражений является значение данного языка
(value in the language) и выполнение программы заключается в вычислении всех
выражений из которых она состоит.</p>
<!--TOC subsection id=sec8 Значения, функции и базовые типы-->
<h3 id="sec8" class="subsection">2.3.1  Значения, функции и базовые типы</h3><!--SEC END --><p>
<a id="sec:values_funcs_base_types"></a></p><p>В Objective CAML определены следующие типы: целые числа, числа с плавающей
запятой, символьный, строковый и логический.</p>
<!--TOC subsubsection id=sec9 Числа-->
<h4 id="sec9" class="subsubsection">Числа</h4><!--SEC END --><p>Различают целые <span style="font-family:monospace">int</span> и числа с плавающей запятой <span style="font-family:monospace">float</span>.
Objective CAML следует спецификации IEEE 754 для представления чисел с плавающей
запятой двойной точности. Операции с этими числами описаны в таблице
<a href="#tbl%3Aoperations_on_numbers">2.1</a>. Если результат целочисленной операции выходит
за интервал значений типа <span style="font-family:monospace">int</span>, то это не приведёт к ошибке. Результат
будет находиться в интервале целых чисел, то есть все действия над целыми
ограниченны операцией <span style="font-family:monospace">modulo</span> с границами интервала.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.1: Операции над числами</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	целые</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >плавающие </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	+ сложение</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >+. сложение </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	- вычитание и унарный минус</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >-. вычитание и унарный минус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	* умножение</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >*. умножение </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	/ деление</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >/. деление </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">mod</span> остаток целочисленного деления</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >** возведение в степень </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># 1 ;;
- : <span style="color:black">int</span> = 1
# 1 + 2 ;;
- : <span style="color:black">int</span> = 3
# 9 / 2 ;;
- : <span style="color:black">int</span> = 4
# 11 <span style="color:black">mod</span> 3 ;;
- : <span style="color:black">int</span> = 2
<span style="color:black">(* limits of the representation  *)</span>
<span style="color:black">(* of integers                   *)</span>
# 2147483650 ;;
- : <span style="color:black">int</span> = 2</td></tr>
</table></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># 2.0 ;;
- : <span style="color:black">float</span> = 2
# 1.1 +. 2.2 ;;
- : <span style="color:black">float</span> = 3.3
# 9.1 /. 2.2 ;;
- : <span style="color:black">float</span> = 4.13636363636
# 1. /. 0. ;;
- : <span style="color:black">float</span> = <span style="color:black">inf</span>
<span style="color:black">(* limits of the representation  *)</span>
<span style="color:black">(* of floating-point numbers     *)</span>
# 222222222222.11111 ;;
- : <span style="color:black">float</span> = 222222222222</td></tr>
</table>
</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<a id="tbl:operations_on_numbers"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec10 Разница между целыми числами и числами с плавающей запятой.-->
<h4 id="sec10" class="subsubsection">Разница между целыми числами и числами с плавающей запятой.</h4><!--SEC END --><p>Значения разных типов, таких как <span style="font-family:monospace">float</span> и <span style="font-family:monospace">int</span>, не могут
сравниваться между собой напрямую. Для этого существует функции перевода одного
типа в другой (<span style="font-family:monospace">float_of_int</span> и <span style="font-family:monospace">int_of_float</span>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 2 = 2.0;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">float</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# 3.0 = <span style="color:black">float_of_int</span> 3;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span></td></tr>
</table><p>Аналогично, операции над целыми числами и числами с плавающей запятой различны:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 3 + 2;;
- : <span style="color:black">int</span> = 5
# 3.0 +. 2.0;;
- : <span style="color:black">float</span> = 5.
# 3.0 + 2.0;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">float</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# <span style="color:black">sin</span> 3.14159;;
- : <span style="color:black">float</span> = 2.65358979335273<span style="color:black">e</span>-06</td></tr>
</table><p>Неопределенный результат, например получаемый при делении на ноль, приведет к
возникновению исключения (см. <a href="#%3F%3F">??</a>, стр. <a href="#%3F%3F">??</a>), которое остановит
вычисление. Числа с плавающей запятой имеют специальные значения для бесконечных
величин (<span style="font-family:monospace">Inf</span>) и для не определённого результата (<span style="font-family:monospace">NaN</span>
<sup><a id="text1" href="#note1">1</a></sup>). Основные операции над этими числами приведены в
таблице <a href="#tbl%3Afunctions_on_floats">2.2</a></p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.2: Функции над числами с плавающей запятой</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">ceil</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">cos</span> косинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">floor</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">sin</span> синус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">sqrt</span> — квадратный корень</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">tan</span> тангенс </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">exp</span> — экспонента</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">acos</span> арккосинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">log</span> — натуральный логарифм</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">asin</span> арксинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">log10</span> — логарифм по базе 10</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">atan</span> арктангенс </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># <span style="color:black">ceil</span> 3.4 ;;
- : <span style="color:black">float</span> = 4.
# <span style="color:black">floor</span> 3.4 ;;
- : <span style="color:black">float</span> = 3.
# <span style="color:black">ceil</span> (-.3.4) ;;
- : <span style="color:black">float</span> = -3.
# <span style="color:black">floor</span> (-.3.4) ;;
- : <span style="color:black">float</span> = -4.</td></tr>
</table></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># <span style="color:black">sin</span> 1.57078 ;;
- : <span style="color:black">float</span> = 0.999999999866717837
# <span style="color:black">sin</span> (<span style="color:black">asin</span> 0.707) ;;
- : <span style="color:black">float</span> = 0.707
# <span style="color:black">acos</span> 0.0 ;;
- : <span style="color:black">float</span> = 1.57079632679489656
# <span style="color:black">asin</span> 3.14 ;;
- : <span style="color:black">float</span> = <span style="color:black">nan</span></td></tr>
</table>
</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<a id="tbl:functions_on_floats"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec11 Символы и строки-->
<h4 id="sec11" class="subsubsection">Символы и строки</h4><!--SEC END --><p>Символы, тип <span style="font-family:monospace">char</span>, соответствуют целым числам в интервале от 0 до 255,
первые 128 значений соответствуют кодам ASCII. Функция <span style="font-family:monospace">char_of_int</span> и
<span style="font-family:monospace">int_of_char</span> преобразуют один тип в другой. Строки, тип
<span style="font-family:monospace">string</span> — это последовательность символов определенной длинны (не
длиннее 224<sup>24</sup> − 6). Оператором объединения строк (конкатенации) является
шапка ∧. Следующие функции необходимы для перевода типов
<span style="font-family:monospace">int_of_string</span>, <span style="font-family:monospace">string_of_int</span>, <span style="font-family:monospace">string_of_float</span> и
<span style="font-family:monospace">float_of_string</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># '<span style="color:black">B</span>' ;;
- : <span style="color:black">char</span> = '<span style="color:black">B</span>'
# <span style="color:black">int_of_char</span> '<span style="color:black">B</span>' ;;
- : <span style="color:black">int</span> = 66
# <span style="color:black">"est une chaîne"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"est une cha\195\174ne"</span>
# (<span style="color:black">string_of_int</span> 1987) ^ <span style="color:black">" est l'année de la création de CAML"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"1987 est l'ann\195\169e de la cr\195\169ation de CAML"</span></td></tr>
</table><p>Если строка состоит из цифр, то мы не сможем использовать ее в численных
операциях, не выполнив явного преобразования.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">"1999"</span> + 1 ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# (<span style="color:black">int_of_string</span> <span style="color:black">"1999"</span>) + 1 ;;
- : <span style="color:black">int</span> = 2000</td></tr>
</table><p>В модуле <span style="font-family:monospace">String</span> собрано много функций для работы со строками (стр.
<a href="#%3F%3F">??</a>)</p>
<!--TOC subsubsection id=sec12 Булевый тип-->
<h4 id="sec12" class="subsubsection">Булевый тип</h4><!--SEC END --><p>Значение типа <span style="font-family:monospace">boolean</span> принадлежит множеству состоящему из двух
элементов: <span style="font-family:monospace">true</span> и <span style="font-family:monospace">false</span>. Основные операторы описаны в таблице
<a href="#tbl%3Aboolean_operations">2.3.1</a>. По историческим причинам операторы <span style="font-family:monospace">and</span> и
<span style="font-family:monospace">or</span> имеют две формы.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.3: Булевы операторы</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	not — отрицание</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&nbsp;</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	&amp;&amp; логическое и</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&amp; синоним &amp;&amp; </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	|| логическое или</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">or</span> синоним | </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
</div>
	<a id="tbl:boolean_operations"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">true</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">not</span> <span style="color:black">true</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span>
# <span style="color:black">true</span> &amp;&amp; <span style="color:black">false</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span></td></tr>
</table><p>Операторы &amp;&amp; и || или их синонимы, вычисляют аргумент слева и в зависимости от
его значения, вычисляют правый аргумент. Они могут быть переписаны в виде
условной структуры (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.4: Операторы сравнения и равенства</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	= равенство структурное</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&lt; меньше </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	== равенство физическое</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&gt; больше </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	&lt;&gt; отрицание =</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&lt;= меньше или равно </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	!= отрицание ==</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&gt;= больше или равно </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
</div>
	<a id="tbl:comparison_operations"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Операторы сравнения и равенства описаны в таблице
<a href="#tbl%3Acomparison_operations">2.3.1</a>. Это полиморфные операторы, то есть они
применимы как для сравнения двух целых, так и двух строк. Единственное
ограничение это то что операнды должны быть одного типа (см. <a href="#">??</a> стр.
<a href="#">??</a>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 1&lt;=118 &amp;&amp; (1=2 || <span style="color:black">not</span>(1=2)) ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# 1.0 &lt;= 118.0 &amp;&amp; (1.0 = 2.0 || <span style="color:black">not</span> (1.0 = 2.0)) ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">"one"</span> &lt; <span style="color:black">"two"</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# 0 &lt; '0' ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">char</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table><p>Структурное равенство при проверке двух переменных сравнивает значение полей
структуры, тогда как физическое равенство проверяет занимают ли эти переменные
одно и то же место в памяти. Оба оператора возвращают одинаковый результат для
простых типов: <span style="font-family:monospace">boolean</span>, <span style="font-family:monospace">char</span>, <span style="font-family:monospace">int</span> и константные
конструкторы (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p>
<!--TOC subsubsection id=sec13 Осторожно-->
<h4 id="sec13" class="subsubsection">Осторожно</h4><!--SEC END --><p>Числа с плавающей запятой и строки рассматриваются как структурные типы.</p>
<!--TOC subsubsection id=sec14 Объединения-->
<h4 id="sec14" class="subsubsection">Объединения</h4><!--SEC END --><p>Тип <span style="font-family:monospace">unit</span> определяет множество из всего одного элемента, обозначается:
()</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># () ;;
- : <span style="color:black">unit</span> = ()</td></tr>
</table><p>Это значение будет широко использоваться в императивных программах (см. <a href="#">??</a>
стр. <a href="#">??</a>), в функциях с побочным эффектом. Функции, результат которых
равен (), соответствуют понятию процедуры, которое отсутствует в Objective CAML,
так же как и аналог типа <span style="font-family:monospace">void</span> в языке C.</p>
<!--TOC subsubsection id=sec15 Декартово произведение, кортежи-->
<h4 id="sec15" class="subsubsection">Декартово произведение, кортежи</h4><!--SEC END --><p>Значения разных типов могут быть сгруппированы в кортежи. Значения из которых
состоит кортеж разделяются запятой. Для конструкции кортежа, используется символ
<span style="font-family:monospace">*</span>. <span style="font-family:monospace">int*string</span> есть кортеж, в котором первый элемент целое
число и второй строка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">int</span> * <span style="color:black">string</span> = (12, <span style="color:black">"October"</span>)</td></tr>
</table><p>Иногда мы можем использовать более простую форму записи.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 12 , <span style="color:black">"October"</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">string</span> = (12, <span style="color:black">"October"</span>)</td></tr>
</table><p>Функции <span style="font-family:monospace">fst</span> и <span style="font-family:monospace">snd</span> дают доступ первому и второму элементу
соответственно.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">fst</span> ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">int</span> = 12
# <span style="color:black">snd</span> ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">string</span> = <span style="color:black">"October"</span></td></tr>
</table><p>Эти обе функции полиморфные, входной аргумент может быть любого типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">fst</span>;;
- : '<span style="color:black">a</span> * '<span style="color:black">b</span> -&gt; '<span style="color:black">a</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">fst</span> ( <span style="color:black">"October"</span>, 12 ) ;;
- : <span style="color:black">string</span> = <span style="color:black">"October"</span></td></tr>
</table><p>Тип <span style="font-family:monospace">int*char*string</span> — это триплет, в котором первый элемент типа
<span style="font-family:monospace">int</span>, второй <span style="font-family:monospace">char</span>, а третий — <span style="font-family:monospace">string</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># ( 65 , '<span style="color:black">B</span>' , <span style="color:black">"ascii"</span> ) ;;
- : <span style="color:black">int</span> * <span style="color:black">char</span> * <span style="color:black">string</span> = (65, '<span style="color:black">B</span>', <span style="color:black">"ascii"</span>)</td></tr>
</table>
<!--TOC subsubsection id=sec16 Осторожно-->
<h4 id="sec16" class="subsubsection">Осторожно</h4><!--SEC END --><p>Если аргумент функций <span style="font-family:monospace">fst</span> и <span style="font-family:monospace">snd</span> не пара, а другой n–кортеж,
то мы получим ошибку.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">snd</span> ( 65 , '<span style="color:black">B</span>' , <span style="color:black">"ascii"</span> ) ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">int</span> * <span style="color:black">char</span> * <span style="color:black">string</span>
       <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span> '<span style="color:black">a</span> * '<span style="color:black">b</span></td></tr>
</table><p>Существует разница между парой и триплетом: тип <span style="font-family:monospace">int*int*int</span> отличен от
<span style="font-family:monospace">(int*int)*int</span> и <span style="font-family:monospace">int*(int*int)</span>. Методы доступа к элементам
триплета (и других кортежей) не определены в стандартной библиотеке. В случае
необходимости мы используем сопоставление с образцом (см. <a href="#">??</a>).</p>
<!--TOC subsubsection id=sec17 Списки-->
<h4 id="sec17" class="subsubsection">Списки</h4><!--SEC END --><p>Значения одного и того же типа могут быть объединены в списки. Список может быть
либо пустым, либо содержать однотипные элементы.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># [] ;;
- : '<span style="color:black">a</span> <span style="color:black">list</span> = []
# [ 1 ; 2 ; 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]
# [ 1 ; <span style="color:black">"two"</span> ; 3 ] ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table><p>Для того чтобы добавить элемент в начало списка существует следующая функция в
виде инфиксного оператора :: — аналог <span style="font-family:monospace">cons</span> в Caml.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 1 :: 2 :: 3 :: [] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]</td></tr>
</table><p>Для объединения (конкатенации) списков существует инфиксный оператор: @.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># [ 1 ]  <span style="color:black">@</span>  [ 2 ; 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]
# [ 1 ; 2 ]  <span style="color:black">@</span>  [ 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]</td></tr>
</table><p>Остальные функции манипуляции списками определены в библиотеке <span style="font-family:monospace">List</span>.
Функции <span style="font-family:monospace">hd</span> и <span style="font-family:monospace">tl</span> дают доступ к первому и последнему элементу
списка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">List</span>.<span style="color:black">hd</span> [ 1 ; 2 ; 3 ] ;;
- : <span style="color:black">int</span> = 1
# <span style="color:black">List</span>.<span style="color:black">hd</span> [] ;;
<span style="color:black">Exception</span>: <span style="color:black">Failure</span> <span style="color:black">"hd"</span>.</td></tr>
</table><p>В последнем примере получить первый элемент пустого списка действительно
сложно, поэтому возбуждается исключение (см. <a href="#">??</a>).</p>
<!--TOC subsection id=sec18 Структуры условного контроля-->
<h3 id="sec18" class="subsection">2.3.2  Структуры условного контроля</h3><!--SEC END --><p>Одна из структур контроля необходимая в каждом языка программирования —
условный оператор.</p><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">if</span> <span style="color:black">expr1</span> <span style="color:black">then</span> <span style="color:black">expr2</span> <span style="color:black">else</span> <span style="color:black">expr3</span></td></tr>
</table><p>Тип выражения <span style="font-family:monospace">expr1</span> равен <span style="font-family:monospace">bool</span>. Выражения <span style="font-family:monospace">expr2</span> и
<span style="font-family:monospace">expr3</span> должны быть одного и того же типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">if</span> 3=4 <span style="color:black">then</span> 0 <span style="color:black">else</span> 4 ;;
- : <span style="color:black">int</span> = 4
# <span style="color:black">if</span> 3=4 <span style="color:black">then</span> <span style="color:black">"0"</span> <span style="color:black">else</span> <span style="color:black">"4"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"4"</span>
# <span style="color:black">if</span> 3=4 <span style="color:black">then</span> 0 <span style="color:black">else</span>  <span style="color:black">"4"</span>;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table>
<!--TOC subsubsection id=sec19 Замечание-->
<h4 id="sec19" class="subsubsection">Замечание</h4><!--SEC END --><p>
Ветка <span style="font-family:monospace">else</span> может быть опущена, в этом случае будет подставлено значение
по умолчанию равное <span style="font-family:monospace">else ()</span>, в соответствии с этим выражение
<span style="font-family:monospace">expr2</span> должно быть типа <span style="font-family:monospace">unit</span> (см. <a href="#">??</a> стр. <a href="#">??</a>).</p>
<!--TOC subsection id=sec20 Объявление значений-->
<h3 id="sec20" class="subsection">2.3.3  Объявление значений</h3><!--SEC END --><p>Определение связывает имя со значением. Различают глобальные и локальные
определения. В первом случае, объявленные имена видны во всех выражениях,
следуют за ним, во втором — имена доступны только в текущем выражении. Мы
также можем одновременно объявить несколько пар имя-значение.</p>
<!--TOC subsubsection id=sec21 Глобальные объявления-->
<h4 id="sec21" class="subsubsection">Глобальные объявления</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">name</span> = <span style="color:black">expr</span> ;;</td></tr>
</table><p>Глобальное объявление определяет связь имени <span style="font-family:monospace">nom</span> со значением выражения
<span style="font-family:monospace">expr</span>, которое будет доступно всем следующим выражениям.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">yr</span> = <span style="color:black">"1999"</span> ;;
<span style="color:black">val</span> <span style="color:black">yr</span> : <span style="color:black">string</span> = <span style="color:black">"1999"</span>
# <span style="color:black">let</span> <span style="color:black">x</span> = <span style="color:black">int_of_string</span>(<span style="color:black">yr</span>) ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 1999
# <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 1999
# <span style="color:black">x</span> + 1 ;;
- : <span style="color:black">int</span> = 2000
# <span style="color:black">let</span> <span style="color:black">new_yr</span> = <span style="color:black">string_of_int</span> (<span style="color:black">x</span> + 1) ;;
<span style="color:black">val</span> <span style="color:black">new_yr</span> : <span style="color:black">string</span> = <span style="color:black">"2000"</span></td></tr>
</table>
<!--TOC subsubsection id=sec22 Одновременное глобальное объявление-->
<h4 id="sec22" class="subsubsection">Одновременное глобальное объявление</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom1</span> = <span style="color:black">expr1</span>
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">nom2</span> = <span style="color:black">expr2</span>
:
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">nomn</span> = <span style="color:black">exprn</span>;;</td></tr>
</table><p>При одновременном объявлении переменные будут известны только к концу всех
объявлений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 1 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">y</span> = 2 ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 1
<span style="color:black">val</span> <span style="color:black">y</span> : <span style="color:black">int</span> = 2
# <span style="color:black">x</span> + <span style="color:black">y</span> ;;
- : <span style="color:black">int</span> = 3
# <span style="color:black">let</span> <span style="color:black">z</span> = 3 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">t</span> = <span style="color:black">z</span> + 2 ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">z</span></td></tr>
</table><p>Можно сгруппировать несколько глобальных объявлений в одной фразе, вывод типов и
значений произойдёт к концу фразы, отмеченной ;;. В данном случае
объявления будут вычислены по порядку.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 2
  <span style="color:black">let</span> <span style="color:black">y</span> = <span style="color:black">x</span> + 3  ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 2
<span style="color:black">val</span> <span style="color:black">y</span> : <span style="color:black">int</span> = 5</td></tr>
</table><p>Глобальное объявление может быть скрыто локальным с тем же именем (см. <a href="#%3F%3F">??</a>
стр. <a href="#%3F%3F">??</a>).</p>
<!--TOC subsubsection id=sec23 Локальное объявление-->
<h4 id="sec23" class="subsubsection">Локальное объявление</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom</span> = <span style="color:black">expr1</span> <span style="color:black">in</span> <span style="color:black">expr2</span>;;</td></tr>
</table><p>Имя <span style="font-family:monospace">nom</span> связанное с выражением <span style="font-family:monospace">expr1</span> известно только для
вычисления <span style="font-family:monospace">expr2</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">xl</span> = 3 <span style="color:black">in</span> <span style="color:black">xl</span> * <span style="color:black">xl</span> ;;
- : <span style="color:black">int</span> = 9</td></tr>
</table><p>Локальное объявление, которое связывает <span style="font-family:monospace">xl</span> со значением <span style="font-family:monospace">3</span>,
существует только в ходе вычисления <span style="font-family:monospace">xl*xl</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">xl</span> ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">xl</span></td></tr>
</table><p>Локальное объявление скрывает любое глобальные с тем же именем, но как только мы
выходим из блока в котором была оно определено, мы находим старое значение
связанное с этим именем.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 2 ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 2
# <span style="color:black">let</span> <span style="color:black">x</span> = 3 <span style="color:black">in</span> <span style="color:black">x</span> * <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 9
# <span style="color:black">x</span> * <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 4</td></tr>
</table><p>Локальное объявление — это обычное выражение, соответственно оно может быть
использовано для построения других выражений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">let</span> <span style="color:black">x</span> = 3 <span style="color:black">in</span> <span style="color:black">x</span> * <span style="color:black">x</span>) + 1 ;;
- : <span style="color:black">int</span> = 10</td></tr>
</table><p>Локальные объявления так же могут быть одновременными.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span>   <span style="color:black">name1</span> = <span style="color:black">expr1</span>
<span style="color:blue"><span style="font-weight:bold">and</span></span>   <span style="color:black">name2</span> = <span style="color:black">expr2</span>
:
<span style="color:blue"><span style="font-weight:bold">and</span></span>   <span style="color:black">namen</span> = <span style="color:black">exprn</span>
<span style="color:black">in</span>  <span style="color:black">expr</span> ;;</td></tr>
</table><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">a</span> = 3.0 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">b</span> = 4.0 <span style="color:black">in</span> <span style="color:black">sqrt</span> (<span style="color:black">a</span>*.<span style="color:black">a</span> +. <span style="color:black">b</span>*.<span style="color:black">b</span>) ;;
- : <span style="color:black">float</span> = 5.
# <span style="color:black">b</span> ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">b</span></td></tr>
</table>
<!--TOC subsection id=sec24 Функциональное выражение, функции-->
<h3 id="sec24" class="subsection">2.3.4  Функциональное выражение, функции</h3><!--SEC END --><p>Функциональное выражение состоит из параметра и тела. Формальный параметр — это
имя переменной, а тело — это выражение. Обычно говорят что формальный параметр
является абстрактным, по этой причине функциональное выражение тоже называется
абстракцией.</p><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">function</span> <span style="color:black">p</span> -&gt; <span style="color:black">expr</span></td></tr>
</table><p>Таким образом функция возведения в квадрат будет выглядеть так:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span>*<span style="color:black">x</span> ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Objective CAML сам определяет тип. Функциональный тип <span style="font-family:monospace">int-&gt;int</span> это
функция с параметром типа <span style="font-family:monospace">int</span>, возвращающая значение типа <span style="font-family:monospace">int</span>.</p><p>Функция с одним аргументом пишется как функция и аргумент следующий за ней.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span> * <span style="color:black">x</span>) 5 ;;
- : <span style="color:black">int</span> = 25</td></tr>
</table><p>Вычисление функции состоит в вычисление её тела, в данном случае <span style="font-family:monospace">x*x</span>,
где формальный параметр <span style="font-family:monospace">x</span>, заменён значением аргумента (эффективным
параметром), здесь он равен 5.</p><p>При конструкции функционального выражения <span style="font-family:monospace">expr</span> может быть любым
выражением, в частности функциональным.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">function</span> <span style="color:black">x</span> -&gt; (<span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Скобки не обязательны, мы можем писать просто:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span> ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>В простом случае мы скажем, что функция ожидает два аргумента целого типа на
входе и возвращает значение целого типа. Но когда речь идёт о функциональном
языке, таком как Objective CAML, то скорее это соответствует типу функции с
входным аргументом типа <span style="font-family:monospace">int</span> и возвращающая функциональное значение типа
<span style="font-family:monospace">int-&gt;int</span>:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 5 ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Естественно, мы можем применить это функциональное выражение к двум аргументам.
Для этого напишем:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4 5 ;;
- : <span style="color:black">int</span> = 17</td></tr>
</table><p>Когда мы пишем <span style="font-family:monospace">f a b</span>, подразумевается применение <span style="font-family:monospace">(f a) к b</span>.</p><p>Давайте подробно рассмотрим выражение</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">(<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4 5</td></tr>
</table><p>Для того чтобы вычислить это выражение, необходимо сначала вычислить значение</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">(<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4</td></tr>
</table><p>что есть <span style="font-style:italic">функциональное выражение</span> равное</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*4 + <span style="color:black">y</span></td></tr>
</table><p>в котором <span style="font-family:monospace">x</span> заменён на 4 в выражении <span style="font-family:monospace">3 * x + y</span>. Применяя это
значение (являющееся функцией) к 5, мы получаем конечное значение <span style="font-family:monospace">3 * 4
+ 5 = 17</span>:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4 5 ;;
- : <span style="color:black">int</span> = 17</td></tr>
</table>
<!--TOC subsubsection id=sec25 Арность функции-->
<h4 id="sec25" class="subsubsection">Арность функции</h4><!--SEC END --><p>Арностью функции называется число аргументов функции. По правилам,
унаследованным из математики, аргументы функции задаются в скобках после имени
функции. Мы пишем: <span style="font-family:monospace">f(4,5)</span>. Как было указанно ранее, в Objective CAML мы
чаще используем следующий синтаксис: <span style="font-family:monospace">f 4 5</span>. Естественно, можно написать
функциональное выражение применимое к (<span style="font-family:monospace">4,5)</span>:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">function</span> (<span style="color:black">x</span>,<span style="color:black">y</span>) -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Но в данном случае, функция ожидает не два аргумента, а один; тип которого пара
целых. Попытка применить два аргумента к функции ожидающей пару или наоборот,
передать пару функции для двух аргументов приведёт к ошибке:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">function</span> (<span style="color:black">x</span>,<span style="color:black">y</span>) -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4 5 ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">function</span> <span style="color:black">is</span> <span style="color:black">applied</span> <span style="color:black">to</span> <span style="color:black">too</span> <span style="color:black">many</span> <span style="color:black">arguments</span>;
<span style="color:black">maybe</span> <span style="color:black">you</span> <span style="color:black">forgot</span> <span style="color:black">a</span> `;'
#  (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) (4, 5) ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">int</span> * <span style="color:black">int</span>
       <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span> <span style="color:black">int</span></td></tr>
</table>
<!--TOC subsubsection id=sec26 Альтернативный синтаксис-->
<h4 id="sec26" class="subsubsection">Альтернативный синтаксис</h4><!--SEC END --><p>Существует более компактная форма записи функций с несколькими аргументами,
которая дошла к нам из старых версий <span style="font-style:italic">Caml</span>. Выглядит она так:</p><p>Синтаксис </p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">fun</span> <span style="color:black">p1</span> ... <span style="color:black">pn</span> -&gt; <span style="color:black">expr</span></td></tr>
</table><p>Это позволяет не повторять слово <span style="font-family:monospace">function</span> и стрелки. Данная запись
эквивалентна</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">function</span> <span style="color:black">p1</span> -&gt; -&gt; <span style="color:black">function</span> <span style="color:black">pn</span> -&gt; <span style="color:black">expr</span>
# <span style="color:black">fun</span> <span style="color:black">x</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span> ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# (<span style="color:black">fun</span> <span style="color:black">x</span> <span style="color:black">y</span> -&gt; 3*<span style="color:black">x</span> + <span style="color:black">y</span>) 4 5 ;;
- : <span style="color:black">int</span> = 17</td></tr>
</table><p>Эту форму можно часто встретить в библиотеках идущих в поставку с Objective
CAML.</p>
<!--TOC subsubsection id=sec27 Замыкание-->
<h4 id="sec27" class="subsubsection">Замыкание</h4><!--SEC END --><p>Objective CAML рассматривает функциональное выражение также как любое другое.
Значение возвращаемое функциональным выражением называется замыканием. Каждое
выражение Objective CAML вычисляется в окружении состоящем из соответствий
имя–значение, которые были объявлены до вычисляемого выражения. Замыкание может
быть описано как триплет, состоящий из имени формального параметра, тела функции
и окружения выражения. Нам необходимо хранить это окружение, поскольку в теле
функции кроме формальных параметров могут использоваться другие переменные. В
функциональном выражении эти переменные называются свободными, нам понадобится
их значение в момент применения функционального выражения.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">m</span> = 3 ;;
<span style="color:black">val</span> <span style="color:black">m</span> : <span style="color:black">int</span> = 3
# <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span> + <span style="color:black">m</span> ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
#  (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span> + <span style="color:black">m</span>) 5 ;;
- : <span style="color:black">int</span> = 8</td></tr>
</table><p>В случае когда применение замыкания к аргументу возвращает новое замыкание, оно
(новое замыкание) получает в своё окружение все необходимые связи для следующего
применения. Раздел <a href="#%3F%3F">??</a> подробно рассматривает эти понятия. В главе
<a href="#%3F%3F">??</a>, а так же в главе <a href="#%3F%3F">??</a> мы вернёмся к тому как замыкание
представляется в памяти.</p><p>До сих пор рассмотренные функциональные выражения были <span style="font-style:italic">анонимными</span>, однако
мы можем дать им имя.
Объявление функциональных значений</p>
<!--TOC subsubsection id=sec28 Объявление функциональных значений-->
<h4 id="sec28" class="subsubsection">Объявление функциональных значений</h4><!--SEC END --><p>Функциональное значение объявляется так же как и другие, при помощи конструктора
<span style="font-family:monospace">let</span></p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">succ</span> = <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span> + 1 ;;
<span style="color:black">val</span> <span style="color:black">succ</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">succ</span> 420 ;;
- : <span style="color:black">int</span> = 421
# <span style="color:black">let</span> <span style="color:black">g</span> = <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; 2*<span style="color:black">x</span> + 3*<span style="color:black">y</span> ;;
<span style="color:black">val</span> <span style="color:black">g</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">g</span> 1 2;;
- : <span style="color:black">int</span> = 8</td></tr>
</table><p>Для упрощения записи, можно использовать следующий синтаксис:</p><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom</span> <span style="color:black">p1</span>...<span style="color:black">pn</span>=<span style="color:black">expr</span></td></tr>
</table><p>что эквивалентно:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom</span>=<span style="color:black">function</span> <span style="color:black">p1</span>-&gt;-&gt;<span style="color:black">function</span> <span style="color:black">pn</span>-&gt; <span style="color:black">expr</span></td></tr>
</table><p>Следующие объявления <span style="font-family:monospace">succ</span> и g эквивалентны предыдущим:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">succ</span> <span style="color:black">x</span> = <span style="color:black">x</span> + 1 ;;
<span style="color:black">val</span> <span style="color:black">succ</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">g</span> <span style="color:black">x</span> <span style="color:black">y</span> = 2*<span style="color:black">x</span> + 3*<span style="color:black">y</span> ;;
<span style="color:black">val</span> <span style="color:black">g</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>В следующем примере демонстрируется функциональная сторона Objective CAML, где
функция <span style="font-family:monospace">h1</span> получена применением <span style="font-family:monospace">g</span> к аргументу. В данном случае
мы имеем дело с частичным применением.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">h1</span> = <span style="color:black">g</span> 1 ;;
<span style="color:black">val</span> <span style="color:black">h1</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">h1</span> 2 ;;
- : <span style="color:black">int</span> = 8</td></tr>
</table><p>С помощью <span style="font-family:monospace">g</span> мы можем определить другую функцию <span style="font-family:monospace">h2</span> фиксируя
значение второго параметра <span style="font-family:monospace">y</span>:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">h2</span> = <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">g</span> <span style="color:black">x</span> 2 ;;
<span style="color:black">val</span> <span style="color:black">h2</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">h2</span> 1 ;;
- : <span style="color:black">int</span> = 8</td></tr>
</table>
<!--TOC subsubsection id=sec29 Объявление инфиксных функций-->
<h4 id="sec29" class="subsubsection">Объявление инфиксных функций</h4><!--SEC END --><p>Некоторые бинарные функции могут быть использованы в инфиксной форме. Например
при сложении двух целых мы пишем <span style="font-family:monospace">3 + 5</span> для применения <span style="font-family:monospace">+</span> к
<span style="font-family:monospace">3</span> и <span style="font-family:monospace">5</span>. Для того чтобы использовать символ <span style="font-family:monospace">+</span> как
классическое функциональное значение, необходимо указать это, окружая символ
скобками (<span style="font-family:monospace">op</span>).</p><p>В следующем примере определяется функция <span style="font-family:monospace">succ</span> используя <span style="font-family:monospace">(+)</span>:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (+) ;;
- : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">succ</span> = (+) 1 ;;
<span style="color:black">val</span> <span style="color:black">succ</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">succ</span> 3 ;;
- : <span style="color:black">int</span> = 4</td></tr>
</table><p>Таким образом мы можем определить новые операторы, что мы и сделаем определив
<span style="font-family:monospace">++</span> для сложения двух пар целых.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> (++) <span style="color:black">c1</span> <span style="color:black">c2</span> = (<span style="color:black">fst</span> <span style="color:black">c1</span>)+(<span style="color:black">fst</span> <span style="color:black">c2</span>), (<span style="color:black">snd</span> <span style="color:black">c1</span>)+(<span style="color:black">snd</span> <span style="color:black">c2</span>) ;;
<span style="color:black">val</span> ( ++ ) : <span style="color:black">int</span> * <span style="color:black">int</span> -&gt; <span style="color:black">int</span> * <span style="color:black">int</span> -&gt; <span style="color:black">int</span> * <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">c</span> = (2,3) ;;
<span style="color:black">val</span> <span style="color:black">c</span> : <span style="color:black">int</span> * <span style="color:black">int</span> = (2, 3)
# <span style="color:black">c</span> ++ <span style="color:black">c</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">int</span> = (4, 6)</td></tr>
</table><p>Существуют однако ограничения на определение новых операторов, они должны
содержать только <span style="font-style:italic">символы</span> (такие как <span style="font-family:monospace">*,+,$</span>, etc.), исключая буквы
и цифры. Следующие функции являются исключением:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">or</span> <span style="color:black">mod</span> <span style="color:black">land</span> <span style="color:black">lor</span> <span style="color:black">lxor</span> <span style="color:black">lsr</span> <span style="color:black">asr</span></td></tr>
</table>
<!--TOC subsubsection id=sec30 Функции высшего порядка-->
<h4 id="sec30" class="subsubsection">Функции высшего порядка</h4><!--SEC END --><p>Функциональное значение (замыкание) может быть возвращено как результат, а так
же передано как аргумент функции. Такие функции, берущие на входе или
возвращающие функциональные значения, называются функциями высшего порядка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">h</span> = <span style="color:black">function</span> <span style="color:black">f</span> -&gt; <span style="color:black">function</span> <span style="color:black">y</span> -&gt; (<span style="color:black">f</span> <span style="color:black">y</span>) + <span style="color:black">y</span> ;;
<span style="color:black">val</span> <span style="color:black">h</span> : (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p><span style="font-style:italic">Замечание</span>
Выражения группируются справа налево, но функциональные типы объединяются слева
направо. Таким образом тип функции <span style="font-family:monospace">h</span> может быть написан:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">(<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> <span style="color:black">или</span> (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) -&gt; (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>)</td></tr>
</table><p>При помощи функций высшего порядка можно элегантно обрабатывать списки. К
примеру функция <span style="font-family:monospace">List.map</span> применяет какую-нибудь функцию ко всем
элементам списка и возвращает список результатов.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">List</span>.<span style="color:black">map</span> ;;
- : ('<span style="color:black">a</span> -&gt; '<span style="color:black">b</span>) -&gt; '<span style="color:black">a</span> <span style="color:black">list</span> -&gt; '<span style="color:black">b</span> <span style="color:black">list</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">square</span> <span style="color:black">x</span> = <span style="color:black">string_of_int</span> (<span style="color:black">x</span>*<span style="color:black">x</span>) ;;
<span style="color:black">val</span> <span style="color:black">square</span> : <span style="color:black">int</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">List</span>.<span style="color:black">map</span> <span style="color:black">square</span> [1; 2; 3; 4] ;;
- : <span style="color:black">string</span> <span style="color:black">list</span> = [<span style="color:black">"1"</span>; <span style="color:black">"4"</span>; <span style="color:black">"9"</span>; <span style="color:black">"16"</span>]</td></tr>
</table><p>Другой пример — функция <span style="font-family:monospace">List.for_all</span> проверяет соответствуют ли
элементы списка определённому критерию.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">List</span>.<span style="color:black">for_all</span> ;;
- : ('<span style="color:black">a</span> -&gt; <span style="color:black">bool</span>) -&gt; '<span style="color:black">a</span> <span style="color:black">list</span> -&gt; <span style="color:black">bool</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">List</span>.<span style="color:black">for_all</span> (<span style="color:black">function</span> <span style="color:black">n</span> -&gt; <span style="color:black">n</span>&lt;&gt;0) [-3; -2; -1; 1; 2; 3] ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">List</span>.<span style="color:black">for_all</span> (<span style="color:black">function</span> <span style="color:black">n</span> -&gt; <span style="color:black">n</span>&lt;&gt;0) [-3; -2; 0; 1; 2; 3] ;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span></td></tr>
</table>
<!--TOC subsubsection id=sec31 Видимость переменных-->
<h4 id="sec31" class="subsubsection">Видимость переменных</h4><!--SEC END --><p>Для вычисления выражения, необходимо чтобы все используемые им переменные были
определены, как, например, выражение <span style="font-family:monospace">e</span> в определении</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">p</span>=<span style="color:black">e</span></td></tr>
</table><p>Переменная <span style="font-family:monospace">p</span> не известна в этом выражении, она может быть использована
только в случае если <span style="font-family:monospace">p</span> была объявлена ранее.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">p</span> = <span style="color:black">p</span> ^ <span style="color:black">"-suffixe"</span> ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">p</span>
# <span style="color:black">let</span> <span style="color:black">p</span> = <span style="color:black">"préfixe"</span> ;;
<span style="color:black">val</span> <span style="color:black">p</span> : <span style="color:black">string</span> = <span style="color:black">"pr\195\169fixe"</span>
# <span style="color:black">let</span> <span style="color:black">p</span> = <span style="color:black">p</span> ^ <span style="color:black">"-suffixe"</span> ;;
<span style="color:black">val</span> <span style="color:black">p</span> : <span style="color:black">string</span> = <span style="color:black">"pr\195\169fixe-suffixe"</span></td></tr>
</table><p>В Objective CAML переменные связаны статически. При применении замыкания
используется окружение в момент её (замыкания) объявления (статическая
видимость), а не в момент её применения (динамическая видимость)</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">p</span> = 10 ;;
<span style="color:black">val</span> <span style="color:black">p</span> : <span style="color:black">int</span> = 10
# <span style="color:black">let</span> <span style="color:black">k</span> <span style="color:black">x</span> = (<span style="color:black">x</span>, <span style="color:black">p</span>, <span style="color:black">x</span>+<span style="color:black">p</span>) ;;
<span style="color:black">val</span> <span style="color:black">k</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> * <span style="color:black">int</span> * <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">k</span> <span style="color:black">p</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">int</span> * <span style="color:black">int</span> = (10, 10, 20)
# <span style="color:black">let</span> <span style="color:black">p</span> = 1000 ;;
<span style="color:black">val</span> <span style="color:black">p</span> : <span style="color:black">int</span> = 1000
# <span style="color:black">k</span> <span style="color:black">p</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">int</span> * <span style="color:black">int</span> = (1000, 10, 1010)</td></tr>
</table><p>В функции <span style="font-family:monospace">k</span> имеется свободная переменная <span style="font-family:monospace">p</span>, которая была
определена в глобальном окружении, поэтому определение <span style="font-family:monospace">k</span> принято. Связь
между именем <span style="font-family:monospace">p</span> и значением 10 в окружении замыкания <span style="font-family:monospace">k</span>
статическая, то есть не зависит от последнего определения <span style="font-family:monospace">p</span>.</p>
<!--TOC subsubsection id=sec32 Рекурсивное объявление-->
<h4 id="sec32" class="subsubsection">Рекурсивное объявление</h4><!--SEC END --><p>Объявление переменной называется рекурсивным, если оно использует свой
собственный идентификатор в своём определении. Эта возможность часто
используется для определения рекурсивных функций. Как мы видели ранее,
<span style="font-family:monospace">let</span> не позволяет делать это, поэтому необходимо использовать
специальный синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">nom</span> = <span style="color:black">expr</span> ;;</td></tr>
</table><p>Другой способ записи для функции с аргументами:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">nom</span> <span style="color:black">p1</span> ... <span style="color:black">pn</span> = <span style="color:black">expr</span> ;;</td></tr>
</table><p>Определим функцию <span style="font-family:monospace">sigma</span> вычисляющую сумму целых от <span style="font-family:monospace">0</span> до
значения указанного аргументом:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">sigma</span> <span style="color:black">x</span> = <span style="color:black">if</span> <span style="color:black">x</span> = 0 <span style="color:black">then</span> 0 <span style="color:black">else</span> <span style="color:black">x</span> + <span style="color:black">sigma</span> (<span style="color:black">x</span>-1) ;;
<span style="color:black">val</span> <span style="color:black">sigma</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">sigma</span> 10 ;;
- : <span style="color:black">int</span> = 55</td></tr>
</table><p>Как заметил читатель, эта функция рискует не закончится если входной
аргумент меньше 0.</p><p>Обычно, рекурсивное значение — это функция, компилятор не принимает некоторые
рекурсивные объявления, значения которых не функциональные.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">x</span> = <span style="color:black">x</span> + 1 ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">kind</span> <span style="color:black">of</span> <span style="color:black">expression</span> <span style="color:black">is</span> <span style="color:black">not</span> <span style="color:black">allowed</span> <span style="color:black">as</span> <span style="color:black">right</span>-<span style="color:black">hand</span> <span style="color:black">side</span> <span style="color:black">of</span> `<span style="color:black">let</span> <span style="color:black">rec</span>'</td></tr>
</table><p>Как мы увидим позднее, такие определения все таки возможны в некоторых случаях
(см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p><p>Объявление <span style="font-family:monospace">let rec</span> может быть скомбинировано с <span style="font-family:monospace">and</span>. В этом
случае функции определённые на одном и том же уровне, видны всем остальным. Это
может быть полезно при декларации взаимно рекурсивных функций.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">pair</span> <span style="color:black">n</span> = (<span style="color:black">n</span>&lt;&gt;1) &amp;&amp; ((<span style="color:black">n</span>=0) <span style="color:black">or</span> (<span style="color:black">impair</span> (<span style="color:black">n</span>-1))) <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">impair</span> <span style="color:black">n</span> = (<span style="color:black">n</span>&lt;&gt;0) &amp;&amp;
((<span style="color:black">n</span>=1) <span style="color:black">or</span> (<span style="color:black">pair</span> (<span style="color:black">n</span>-1)));;
<span style="color:black">val</span> <span style="color:black">pair</span> : <span style="color:black">int</span> -&gt; <span style="color:black">bool</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">impair</span> : <span style="color:black">int</span> -&gt; <span style="color:black">bool</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">pair</span> 4 ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">impair</span> 5 ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span></td></tr>
</table><p>По тому же принципу, локальные функции могут быть рекурсивными. Новое
определение функции <span style="font-family:monospace">sigma</span> проверяет корректность входного аргумента,
перед тем как посчитать сумму локальной функцией <span style="font-family:monospace">sigma_rec</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">sigma</span> <span style="color:black">x</span> = <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">sigma_rec</span> <span style="color:black">x</span> = <span style="color:black">if</span> <span style="color:black">x</span> = 0 <span style="color:black">then</span> 0 <span style="color:black">else</span> <span style="color:black">x</span> + <span style="color:black">sigma_rec</span> (<span style="color:black">x</span>-1)
<span style="color:black">in</span> <span style="color:black">if</span> (<span style="color:black">x</span>&lt;0) <span style="color:black">then</span> <span style="color:black">"erreur : argument negatif"</span> <span style="color:black">else</span> <span style="color:black">"sigma = "</span> ^ (<span style="color:black">string_of_int</span>
(<span style="color:black">sigma_rec</span> <span style="color:black">x</span>)) ;;
<span style="color:black">val</span> <span style="color:black">sigma</span> : <span style="color:black">int</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p><span style="font-style:italic">Замечание</span></p><p>Мы вынужденны были определить возвращаемый тип как <span style="font-family:monospace">string</span>, поскольку
необходимо чтобы он был один и тот же, независимо от входного аргумента,
отрицательного или положительного. Какое значение должна вернуть <span style="font-family:monospace">sigma</span>
если аргумент больше нуля? Далее, мы увидим правильный способ решения этой
проблемы (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p>
<!--TOC subsection id=sec33 Полиморфизм и ограничение типа-->
<h3 id="sec33" class="subsection">2.3.5  Полиморфизм и ограничение типа</h3><!--SEC END --><p>Некоторые функции выполняют одни и те же инструкции независимо от типа
аргументов. К примеру, для создание пары из двух значений нет смысла определять
функции для каждого известного типа. Другой пример, доступ к первому полю пары
не зависит от того, какого типа это поле.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">make_pair</span> <span style="color:black">a</span> <span style="color:black">b</span> = (<span style="color:black">a</span>,<span style="color:black">b</span>) ;;
<span style="color:black">val</span> <span style="color:black">make_pair</span> : '<span style="color:black">a</span> -&gt; '<span style="color:black">b</span> -&gt; '<span style="color:black">a</span> * '<span style="color:black">b</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">p</span> = <span style="color:black">make_pair</span> <span style="color:black">"papier"</span> 451 ;;
<span style="color:black">val</span> <span style="color:black">p</span> : <span style="color:black">string</span> * <span style="color:black">int</span> = (<span style="color:black">"papier"</span>, 451)
# <span style="color:black">let</span> <span style="color:black">a</span> = <span style="color:black">make_pair</span> '<span style="color:black">B</span>' 65 ;;
<span style="color:black">val</span> <span style="color:black">a</span> : <span style="color:black">char</span> * <span style="color:black">int</span> = ('<span style="color:black">B</span>', 65)
# <span style="color:black">fst</span> <span style="color:black">p</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"papier"</span>
# <span style="color:black">fst</span> <span style="color:black">a</span> ;;
- : <span style="color:black">char</span> = '<span style="color:black">B</span>'</td></tr>
</table><p>Функция, для которой не нужно указывать тип входного аргумента или возвращаемого
значения называется полиморфной. Синтезатор типов, включённый в компилятор
Objective CAML находит наиболее общий тип для каждого выражения. В этом случае
Objective CAML использует переменные, здесь они обозначены как <span style="font-family:monospace">’a</span> и
<span style="font-family:monospace">’b</span>, для указания общих типов. Эти переменные конкретизируются типом
аргумента в момент применения функции.</p><p>При помощи полиморфных функций, мы получаем возможность написания универсального
кода для любого типа переменных, сохраняя при этом надёжность статической
типизации. Действительно, несмотря на то что <span style="font-family:monospace">make_paire</span> полиморфная,
значение созданное (<span style="font-family:monospace">make_paire ’6’ 65</span>) имеет строго определённый тип,
который отличен от (<span style="font-family:monospace">make_paire "paire" 451</span>). Проверка типов
реализуется в момент компиляции, таким образом универсальность кода никак не
сказывается на эффективности программы.</p>
<!--TOC subsubsection id=sec34 Пример функций и полиморфных значений-->
<h4 id="sec34" class="subsubsection">Пример функций и полиморфных значений</h4><!--SEC END --><p>В следующем примере приведена полиморфная функция с входным параметром
функционального типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">app</span> = <span style="color:black">function</span> <span style="color:black">f</span> -&gt; <span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">f</span> <span style="color:black">x</span> ;;
<span style="color:black">val</span> <span style="color:black">app</span> : ('<span style="color:black">a</span> -&gt; '<span style="color:black">b</span>) -&gt; '<span style="color:black">a</span> -&gt; '<span style="color:black">b</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Мы можем применить её к функции <span style="font-family:monospace">impaire</span>, которая была определена ранее.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">app</span> <span style="color:black">impair</span> 2;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span></td></tr>
</table><p>Функция тождества (<span style="font-family:monospace">id</span>) возвращает полученный аргумент.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">id</span> <span style="color:black">x</span> = <span style="color:black">x</span> ;;
<span style="color:black">val</span> <span style="color:black">id</span> : '<span style="color:black">a</span> -&gt; '<span style="color:black">a</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">app</span> <span style="color:black">id</span> 1 ;;
- : <span style="color:black">int</span> = 1</td></tr>
</table><p>Следующая функция, <span style="font-family:monospace">compose</span> принимает на входе две функции и ещё один
аргумент, к которому применяет две первые.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">compose</span> <span style="color:black">f</span> <span style="color:black">g</span> <span style="color:black">x</span> = <span style="color:black">f</span> (<span style="color:black">g</span> <span style="color:black">x</span>) ;;
<span style="color:black">val</span> <span style="color:black">compose</span> : ('<span style="color:black">a</span> -&gt; '<span style="color:black">b</span>) -&gt; ('<span style="color:black">c</span> -&gt; '<span style="color:black">a</span>) -&gt; '<span style="color:black">c</span> -&gt; '<span style="color:black">b</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">add1</span> <span style="color:black">x</span> = <span style="color:black">x</span>+1 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">mul5</span> <span style="color:black">x</span> = <span style="color:black">x</span>*5 <span style="color:black">in</span> <span style="color:black">compose</span> <span style="color:black">mul5</span> <span style="color:black">add1</span> 9 ;;
- : <span style="color:black">int</span> = 50</td></tr>
</table><p>Как мы видим, тип результата возвращаемого <span style="font-family:monospace">g</span> должен быть таким же как и
тип входного аргумента <span style="font-family:monospace">f</span>.</p><p>Не только функциональные значения могут быть полиморфными, проиллюстрируем это
на примере пустого списка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">l</span> = [] ;;
<span style="color:black">val</span> <span style="color:black">l</span> : '<span style="color:black">a</span> <span style="color:black">list</span> = []</td></tr>
</table><p>Следующий пример иллюстрирует тот факт, что создание типов основывается на
разрешении ограничений, накладываемых применением функций, а вовсе не на
значениях, полученных в процессе выполнения.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">q</span> = <span style="color:black">List</span>.<span style="color:black">tl</span> [2] ;;
<span style="color:black">val</span> <span style="color:black">q</span> : <span style="color:black">int</span> <span style="color:black">list</span> = []</td></tr>
</table><p>Здесь тип равен <span style="font-family:monospace">List.tl ’a list-&gt;’a list</span>, то есть эта функция
применяется к списку целых и возвращает список целых. Тот факт что в момент
выполнения возвращён пустой список, не влияет на его тип.</p><p>Objective CAML создаёт параметризованные типы для каждой функции, которые не
зависят от её аргументов. Этот вид полиморфизма называется <span style="font-style:italic">параметрическим
полиморфизмом</span> <sup><a id="text2" href="#note2">2</a></sup>.</p>
<!--TOC subsubsection id=sec35 Ограничение типа-->
<h4 id="sec35" class="subsubsection">Ограничение типа</h4><!--SEC END --><p>Синтезатор типа Objective CAML образует самый общий тип и иногда бывает
необходимо уточнить тип выражения.</p><p>Синтаксис ограничения типа следующий:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">(<span style="color:black">expr</span>:<span style="color:black">t</span>)</td></tr>
</table><p>В этом случае синтезатор типа воспользуется этим ограничением при конструкции
типа выражения. Использование ограничения типа позволяет</p><ul class="itemize"><li class="li-itemize">
	сделать видимым тип параметра функции<p>	</p></li><li class="li-itemize">запретить использование функции вне свой области применения<p>	</p></li><li class="li-itemize">уточнить тип выражения, это окажется необходимым в случае физически
изменяемых значений (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).
</li></ul><p>Рассмотрим использование ограничения типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">add</span> (<span style="color:black">x</span>:<span style="color:black">int</span>) (<span style="color:black">y</span>:<span style="color:black">int</span>) = <span style="color:black">x</span> + <span style="color:black">y</span> ;;
<span style="color:black">val</span> <span style="color:black">add</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">make_pair_int</span> (<span style="color:black">x</span>:<span style="color:black">int</span>) (<span style="color:black">y</span>:<span style="color:black">int</span>) = <span style="color:black">x</span>,<span style="color:black">y</span>;;
<span style="color:black">val</span> <span style="color:black">make_pair_int</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> * <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">compose_fn_int</span> (<span style="color:black">f</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span>) (<span style="color:black">g</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span>) (<span style="color:black">x</span>:<span style="color:black">int</span>) = <span style="color:black">compose</span> <span style="color:black">f</span> <span style="color:black">g</span> <span style="color:black">x</span>;;
<span style="color:black">val</span> <span style="color:black">compose_fn_int</span> : (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) -&gt; (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">nil</span> = ([] : <span style="color:black">string</span> <span style="color:black">list</span>);;
<span style="color:black">val</span> <span style="color:black">nil</span> : <span style="color:black">string</span> <span style="color:black">list</span> = []
# '<span style="color:black">H</span>'::<span style="color:black">nil</span>;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">list</span>
       <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span> <span style="color:black">char</span> <span style="color:black">list</span></td></tr>
</table><p>Это ограничение полиморфизма позволяет лучше контролировать тип выражений, тем
самым ограничивая тип определённый системой. В таких выражениях можно
использовать любой определённый тип.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">llnil</span> = ([] : '<span style="color:black">a</span> <span style="color:black">list</span> <span style="color:black">list</span>) ;;
<span style="color:black">val</span> <span style="color:black">llnil</span> : '<span style="color:black">a</span> <span style="color:black">list</span> <span style="color:black">list</span> = []
# [1;2;3]:: <span style="color:black">llnil</span> ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> <span style="color:black">list</span> = [[1; 2; 3]]</td></tr>
</table><p><span style="font-family:monospace">llint</span> является списком списков любого типа.</p><p>В данном случае подразумевается ограничение типа, а не явная типизация
заменяющая тип, который определил Objective CAML. В частности, мы не можем
обобщить тип, более чем это позволяет вывод типов Objective CAML.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">add_general</span> (<span style="color:black">x</span>:'<span style="color:black">a</span>) (<span style="color:black">y</span>:'<span style="color:black">b</span>) = <span style="color:black">add</span> <span style="color:black">x</span> <span style="color:black">y</span> ;;
<span style="color:black">val</span> <span style="color:black">add_general</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Ограничения типа будут использованы в интерфейсах модулей <a href="#%3F%3F">??</a>, а так же в
декларации классов <a href="#%3F%3F">??</a></p>
<!--TOC subsection id=sec36 Примеры-->
<h3 id="sec36" class="subsection">2.3.6  Примеры</h3><!--SEC END --><p>В этом параграфе мы приведём несколько примеров функций. Большинство из них уже
определены в Objective CAML, мы делаем это только в педагогических целях.</p><p>Тест остановки рекурсивных функций реализован при помощи проверки, имеющей стиль
более близкий к <span style="font-family:monospace">Lisp</span>. Мы увидим как это сделать в стиле ML (см.
<a href="#%3F%3F">??</a>).</p>
<!--TOC subsubsection id=sec37 Размер списка-->
<h4 id="sec37" class="subsubsection">Размер списка</h4><!--SEC END --><p>Начнём с функции проверяющей пустой список или нет.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">null</span> <span style="color:black">l</span> = (<span style="color:black">l</span>=[]);;
<span style="color:black">val</span> <span style="color:black">null</span> : '<span style="color:black">a</span> <span style="color:black">list</span> -&gt; <span style="color:black">bool</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Определим функцию <span style="font-family:monospace">size</span> вычисления размера списка (т.е. число
элементов).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">size</span> <span style="color:black">l</span> = <span style="color:black">if</span> <span style="color:black">null</span> <span style="color:black">l</span> <span style="color:black">then</span> 0 <span style="color:black">else</span> 1+(<span style="color:black">size</span>(<span style="color:black">List</span>.<span style="color:black">tl</span> <span style="color:black">l</span>));;
<span style="color:black">val</span> <span style="color:black">size</span> : '<span style="color:black">a</span> <span style="color:black">list</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">size</span> [] ;;
- : <span style="color:black">int</span> = 0
# <span style="color:black">size</span> [1;2;18;22] ;;
- : <span style="color:black">int</span> = 4</td></tr>
</table><p>Функция <span style="font-family:monospace">size</span> проверяет список: если он пуст возвращает 0, иначе
прибавляет 1 к длине остатка списка.</p>
<!--TOC subsubsection id=sec38 Итерация композиций (Iteration of composition)-->
<h4 id="sec38" class="subsubsection">Итерация композиций (Iteration of composition)</h4><!--SEC END --><p>Выражение <span style="font-family:monospace">iterate n f</span> вычисляет <span style="font-style:italic">f</span><sup><span style="font-style:italic">n</span></sup>, соответствующее применение
функции <span style="font-family:monospace">f n</span> раз.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">iterate</span> <span style="color:black">n</span> <span style="color:black">f</span> =
   <span style="color:black">if</span> <span style="color:black">n</span> = 0 <span style="color:black">then</span> (<span style="color:black">function</span> <span style="color:black">x</span> -&gt; <span style="color:black">x</span>)
   <span style="color:black">else</span> <span style="color:black">compose</span> <span style="color:black">f</span> (<span style="color:black">iterate</span> (<span style="color:black">n</span>-1) <span style="color:black">f</span>) ;;
<span style="color:black">val</span> <span style="color:black">iterate</span> : <span style="color:black">int</span> -&gt; ('<span style="color:black">a</span> -&gt; '<span style="color:black">a</span>) -&gt; '<span style="color:black">a</span> -&gt; '<span style="color:black">a</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Функция <span style="font-family:monospace">iterate</span> проверяет аргумент n на равенство нулю, если аргумент
равен, то возвращаем функцию идентичности, иначе возвращаем композицию
<span style="font-family:monospace">f</span> с итерацией <span style="font-family:monospace">f n-1</span> раз.</p><p>Используя <span style="font-family:monospace">iterate</span> можно определить операцию возведения в степень, как
итерацию умножения.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">power</span> <span style="color:black">i</span> <span style="color:black">n</span> =
  <span style="color:black">let</span> <span style="color:black">i_times</span> = ( * ) <span style="color:black">i</span> <span style="color:black">in</span>
   <span style="color:black">iterate</span> <span style="color:black">n</span> <span style="color:black">i_times</span> 1 ;;
<span style="color:black">val</span> <span style="color:black">power</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">power</span> 2 8 ;;
- : <span style="color:black">int</span> = 256</td></tr>
</table><p>Функция <span style="font-family:monospace">power</span> повторяет n раз функциональное выражение
<span style="font-family:monospace">i_times</span>, затем применяет этот результат к 1, таким образом мы получаем
n-ю степень целого числа.</p>
<!--TOC subsubsection id=sec39 Таблица умножения-->
<h4 id="sec39" class="subsubsection">Таблица умножения</h4><!--SEC END --><p>Напишем функцию <span style="font-family:monospace">multab</span>, которая вычисляет ряд таблицы умножения
соответствующую целому числу переданному в аргументе.</p><p>Для начала определим функцию <span style="font-family:monospace">apply_fun_list</span>. Пусть <span style="font-family:monospace">f_list</span>
список функций, тогда вызов <span style="font-family:monospace">apply_fun_list x f_list</span> возвращает
список результатов применения каждого элемента списка <span style="font-family:monospace">f_list</span> к
<span style="font-family:monospace">x</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">apply_fun_list</span> <span style="color:black">x</span> <span style="color:black">f_list</span> =
  <span style="color:black">if</span> <span style="color:black">null</span> <span style="color:black">f_list</span> <span style="color:black">then</span> []
  <span style="color:black">else</span> ((<span style="color:black">List</span>.<span style="color:black">hd</span> <span style="color:black">f_list</span>) <span style="color:black">x</span>)::(<span style="color:black">apply_fun_list</span> <span style="color:black">x</span> (<span style="color:black">List</span>.<span style="color:black">tl</span> <span style="color:black">f_list</span>)) ;;
<span style="color:black">val</span> <span style="color:black">apply_fun_list</span> : '<span style="color:black">a</span> -&gt; ('<span style="color:black">a</span> -&gt; '<span style="color:black">b</span>) <span style="color:black">list</span> -&gt; '<span style="color:black">b</span> <span style="color:black">list</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">apply_fun_list</span> 1 [(+) 1;(+) 2;(+) 3] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [2; 3; 4]</td></tr>
</table><p>Функция <span style="font-family:monospace">mk_mult_fun_list</span> возвращает список функций умножающих их
аргумент на i, <span style="font-family:monospace">0&lt;=i&lt;=n</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">mk_mult_fun_list</span> <span style="color:black">n</span> =
    <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">mmfl_aux</span> <span style="color:black">p</span> =
      <span style="color:black">if</span> <span style="color:black">p</span> = <span style="color:black">n</span> <span style="color:black">then</span> [ ( * ) <span style="color:black">n</span> ]
      <span style="color:black">else</span> (( * ) <span style="color:black">p</span>) :: (<span style="color:black">mmfl_aux</span> (<span style="color:black">p</span>+1))
    <span style="color:black">in</span>  (<span style="color:black">mmfl_aux</span> 1) ;;
<span style="color:black">val</span> <span style="color:black">mk_mult_fun_list</span> : <span style="color:black">int</span> -&gt; (<span style="color:black">int</span> -&gt; <span style="color:black">int</span>) <span style="color:black">list</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Подсчитаем ряд для 7</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">multab</span> <span style="color:black">n</span> = <span style="color:black">apply_fun_list</span> <span style="color:black">n</span> (<span style="color:black">mk_mult_fun_list</span> 10) ;;
<span style="color:black">val</span> <span style="color:black">multab</span> : <span style="color:black">int</span> -&gt; <span style="color:black">int</span> <span style="color:black">list</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">multab</span> 7 ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [7; 14; 21; 28; 35; 42; 49; 56; 63; 70]</td></tr>
</table>
<!--TOC subsubsection id=sec40 Итерация в списке-->
<h4 id="sec40" class="subsubsection">Итерация в списке</h4><!--SEC END --><p>Вызов функции <span style="font-family:monospace">fold_left f a [e1; e2; </span>…<span style="font-family:monospace">; en]</span> возвращает
<span style="font-family:monospace">f</span>…<span style="font-family:monospace">(f (f a e1) e2) </span>…<span style="font-family:monospace"> en</span>, значит получаем n применений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">fold_left</span> <span style="color:black">f</span> <span style="color:black">a</span> <span style="color:black">l</span> =
   <span style="color:black">if</span> <span style="color:black">null</span> <span style="color:black">l</span> <span style="color:black">then</span> <span style="color:black">a</span>
   <span style="color:black">else</span> <span style="color:black">fold_left</span> <span style="color:black">f</span> ( <span style="color:black">f</span> <span style="color:black">a</span> (<span style="color:black">List</span>.<span style="color:black">hd</span> <span style="color:black">l</span>)) (<span style="color:black">List</span>.<span style="color:black">tl</span> <span style="color:black">l</span>) ;;
<span style="color:black">val</span> <span style="color:black">fold_left</span> : ('<span style="color:black">a</span> -&gt; '<span style="color:black">b</span> -&gt; '<span style="color:black">a</span>) -&gt; '<span style="color:black">a</span> -&gt; '<span style="color:black">b</span> <span style="color:black">list</span> -&gt; '<span style="color:black">a</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>С помощью функции <span style="font-family:monospace">fold_left</span> можно компактно определить функцию
вычисления суммы элементов списка целых чисел.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">sum_list</span> = <span style="color:black">fold_left</span> (+) 0 ;;
<span style="color:black">val</span> <span style="color:black">sum_list</span> : <span style="color:black">int</span> <span style="color:black">list</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">sum_list</span> [2;4;7] ;;
- : <span style="color:black">int</span> = 13</td></tr>
</table><p>Или, например, конкатенация элементов списка строк.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">sum_list</span> = <span style="color:black">fold_left</span> (+) 0 ;;
<span style="color:black">val</span> <span style="color:black">sum_list</span> : <span style="color:black">int</span> <span style="color:black">list</span> -&gt; <span style="color:black">int</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">sum_list</span> [2;4;7] ;;
- : <span style="color:black">int</span> = 13</td></tr>
</table>
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Not a Number</div>
</dd><dt class="dt-thefootnotes"><a id="note2" href="#text2">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Некоторые встроенные функции не подчиняются этому
правилу, особенно функция структурного равенства (<span style="font-family:monospace">=</span>), которая является
полиморфной (её тип <span style="font-family:monospace">’a -&gt; ’a -&gt; bool</span>), но она исследует структуру своих
аргументов для проверки равенства.</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec41 Императивное программирование-->
<h1 id="sec41" class="chapter">Глава 3  Императивное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec42 Функциональный и императивный стиль-->
<h1 id="sec42" class="chapter">Глава 4  Функциональный и императивный стиль</h1><!--SEC END -->
<!--TOC chapter id=sec43 Графический интерфейс-->
<h1 id="sec43" class="chapter">Глава 5  Графический интерфейс</h1><!--SEC END -->
<!--TOC chapter id=sec44 Приложения-->
<h1 id="sec44" class="chapter">Глава 6  Приложения</h1><!--SEC END -->
<!--TOC part id=sec45 Средства разработки-->
<table class="center"><tr><td><h1 id="sec45" class="part">Часть II<br>
Средства разработки</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec46 Компиляция и переносимость-->
<h1 id="sec46" class="chapter">Глава 7  Компиляция и переносимость</h1><!--SEC END -->
<!--TOC chapter id=sec47 Библиотеки-->
<h1 id="sec47" class="chapter">Глава 8  Библиотеки</h1><!--SEC END -->
<!--TOC chapter id=sec48 Автоматический сборщик мусора-->
<h1 id="sec48" class="chapter">Глава 9  Автоматический сборщик мусора</h1><!--SEC END -->
<!--TOC chapter id=sec49 Средства анализа программ-->
<h1 id="sec49" class="chapter">Глава 10  Средства анализа программ</h1><!--SEC END -->
<!--TOC chapter id=sec50 Средства лексического и синтаксического анализа-->
<h1 id="sec50" class="chapter">Глава 11  Средства лексического и синтаксического анализа</h1><!--SEC END -->
<!--TOC section id=sec51 Введение-->
<h2 id="sec51" class="section">11.1  Введение</h2><!--SEC END --><p>Определение и реализация средств лексического и синтаксического анализа являлись
важным доменом исследования в информатике. Эта работа привела к созданию
генераторов лексического и синтаксического анализа <span style="font-family:monospace">lex</span> и
<span style="font-family:monospace">yacc</span>. Команды <span style="font-family:monospace">camllex camlyacc</span>, которые мы представим в этой
главе, являются их достойными наследниками. Два указанных инструмента стали
de–facto стандартными, однако существуют другие средства, как например потоки
или регулярные выражения из библиотеки <span style="font-family:monospace">Str</span>, которые могут быть
достаточны для простых случаев, там где не нужен мощный анализ.</p><p>Необходимость подобных инструментов особенно чувствовалась в таких доменах как
компиляция языков программирования. Однако и другие программы могут с успехом
использовать данные средства: базы данных, позволяющие определять запросы или
электронная таблица, где содержимое ячейки можно определить как результат
какой–нибудь формулы. Проще говоря, любая программа, в которой взаимодействие с
пользователем осуществляется при помощи языка, использует лексический и
синтаксический анализ.</p><p>Возьмём простой случай. Текстовый формат часто используется для хранения данных,
будь то конфигурационный системный файл или данные табличного файла. Здесь, для
использования данных, необходим лексический и синтаксический анализ.</p><p>Обобщая, скажем что лексический и синтаксический анализ преобразует линейный
поток символов в данные с более богатой структурой: последовательность слов,
структура записи, абстрактное синтаксическое дерево программы и т.д.</p><p>У каждого языка есть словарный состав (лексика) и грамматика, которая описывает
каким образом эти составные объединяются (синтаксис). Для того, чтобы машина или
программа могли корректно обрабатывать язык, этот язык должен иметь точные
лексические и синтаксические правила. У машины нет тонкого чувства для
того чтобы правильно оценить двусмысленность натуральных языков. По этой
причине к машине необходимо обращаться в соответствии с чёткими правилами, в
которых нет исключений. В соответствии с этим, понятия лексики и семантики
получили формальные определения, которые будут кратко представлены в данной
главе.
</p>
<!--TOC section id=sec52 План главы-->
<h2 id="sec52" class="section">11.2  План главы</h2><!--SEC END --><p>Данная глава знакомит нас со средствами лексического и синтаксического анализа,
которые входят в дистрибутив Objective CAML. Обычно синтаксический анализ
следует за лексическим. В первой части мы узнаем о простом инструменте
лексического анализа из модуля <span style="font-family:monospace">Genlex</span>. После этого ознакомимся с
формализмом рациональных выражений и тем самым рассмотрим более детально
определение множества лексических единиц. А так же проиллюстрируем их реализацию
в модуле <span style="font-family:monospace">Str</span> и инструменте <span style="font-family:monospace">ocamllex</span>. Во второй части мы
определим грамматику и рассмотрим правила создания фраз языка. После этого
рассмотрим два анализа фраз: восходящий и нисходящий. Они будут
проиллюстрированы использованием <span style="font-family:monospace">Stream</span> и <span style="font-family:monospace">ocamlyacc</span>. В
приведённых примерах используется контекстно–независимая грамматика. Здесь мы
узнаем как реализовать контекстный анализ при помощи Stream. В третьей части мы
вернёмся к интерпретатору BASIC (см. стр <a href="#%3F%3F">??</a>) и при помощи
<span style="font-family:monospace">ocamllex</span> и <span style="font-family:monospace">ocamlyacc</span> добавим лексические и синтаксические
функции анализа языка.

</p>
<!--TOC section id=sec53 Лексика-->
<h2 id="sec53" class="section">11.3  Лексика</h2><!--SEC END --><p>Синтаксический анализ это предварительный и необходимый этап обработки
последовательностей символов: он разделяет этот поток в последовательность слов,
так называемых лексические единицы или лексемы.</p>
<!--TOC subsection id=sec54 Модуль <span style="font-family:monospace">Genlex</span>-->
<h3 id="sec54" class="subsection">11.3.1  Модуль <span style="font-family:monospace">Genlex</span></h3><!--SEC END --><p>В данном модуле имеется элементарное средство для анализа символьного потока.
Для этого используются несколько категорий предопределённых лексических единиц.
Эти категории различаются по типу:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">type</span> <span style="color:black">token</span> = <span style="color:black">Kwd</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Ident</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Int</span> <span style="color:black">of</span> <span style="color:black">int</span>
    | <span style="color:black">Float</span> <span style="color:black">of</span> <span style="color:black">float</span>
    | <span style="color:black">String</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Char</span> <span style="color:black">of</span> <span style="color:black">char</span> ;;</td></tr>
</table><p>Таким образом мы можем распознать в потоке символов целое число (конструктор
<span style="font-family:monospace">Int</span>) и получить его значение (аргумент конструктора <span style="font-family:monospace">int</span>).
Распознаваемые символы и строки подчиняются следующим общепринятым соглашением:
строка окружена символами ("), а символ окружён (’). Десятичное число
представлено либо используя запись с точкой (например 0.01), либо с мантиссой и
экспонентой (на пример 1E-2). Кроме этого остались конструкторы <span style="font-family:monospace">Kwd</span> и
<span style="font-family:monospace">Ident</span>.</p><p>Конструктор <span style="font-family:monospace">Ident</span> предназначен для определения идентификаторов.
Идентификатором может быть имя переменной или функции языка программирования.
Они состоят из любой последовательности букв и цифр, могут включать
символ подчёркивания (_) или апостроф (’). Данная последовательность не должна
начинаться с цифры. Любая последовательность следующих операндов тоже будет
считаться идентификатором: +,*,&gt; или -. И наконец, конструктор <span style="font-family:monospace">Kwd</span>
определяет
категорию специальных идентификаторов или символов.</p><p>Категория ключевых слова — единственная из этого множества, которую можно
сконфигурировать. Для того, чтобы создать лексический анализатор, воспользуемся
следующей конструкцией, которой необходимо передать список ключевых слов на
место первого аргумента.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> ;;
- : <span style="color:black">string</span> <span style="color:black">list</span> -&gt; <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Тем самым получаем функцию, которая принимает на вход поток символов и
возвращает поток лексических единиц (с типом <span style="font-family:monospace">token</span>).</p><p>Таким образом, мы без труда реализуем лексический анализатор для интерпретатора
BASIC. Объявим множество ключевых слов:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">keywords</span> =
    [ <span style="color:black">"REM"</span>; <span style="color:black">"GOTO"</span>; <span style="color:black">"LET"</span>; <span style="color:black">"PRINT"</span>; <span style="color:black">"INPUT"</span>; <span style="color:black">"IF"</span>; <span style="color:black">"THEN"</span>; <span style="color:black">"-"</span>;
    <span style="color:black">"!"</span>; <span style="color:black">"+"</span>; <span style="color:black">"-"</span>; <span style="color:black">"*"</span>; <span style="color:black">"/"</span>; <span style="color:black">"%"</span>;
    <span style="color:black">"="</span>; <span style="color:black">"&lt;"</span>; <span style="color:black">"&gt;"</span>; <span style="color:black">"&lt;="</span>; <span style="color:black">"&gt;="</span>; <span style="color:black">"&lt;&gt;"</span>;
    <span style="color:black">"&amp;"</span>; <span style="color:black">"|"</span> ] ;;</td></tr>
</table><p>При помощи данного множества, определим функцию лексического анализа:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">line_lexer</span> <span style="color:black">l</span> = <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> <span style="color:black">keywords</span> (<span style="color:black">Stream</span>.<span style="color:black">of_string</span> <span style="color:black">l</span>) ;;
<span style="color:black">val</span> <span style="color:black">line_lexer</span> : <span style="color:black">string</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">line_lexer</span> <span style="color:black">"LET x = x + y * 3"</span> ;;
- : <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">abstr</span>&gt;</td></tr>
</table><p>Приведённая функция <span style="font-family:monospace">line_lexer</span>, из входящего потока символов создаёт
поток соответствующих лексем.</p>
<!--TOC subsection id=sec55 Использование потоков-->
<h3 id="sec55" class="subsection">11.3.2  Использование потоков</h3><!--SEC END --><p>Мы также можем реализовать лексический анализ в ручную используя потоки.</p><p>В следующем примере определён лексический анализатор арифметических выражений.
Функции lexer передаётся поток символов из которого она создаёт поток
лексических единиц с типом <span style="font-family:monospace">lexeme Stream.t</span> <sup><a id="text3" href="#note3">1</a></sup>. Символы пробел, табуляция и
переход на новую строку удаляются. Для упрощения, мы не будем обрабатывать
переменные и отрицательны целые числа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">spaces</span> <span style="color:black">s</span> =
    <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
      [&lt;'' ' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;''\<span style="color:black">t</span>' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;''\<span style="color:black">n</span>' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;&gt;] -&gt; ();;
<span style="color:black">val</span> <span style="color:black">spaces</span> : <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">unit</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">lexer</span> <span style="color:black">s</span> =
   <span style="color:black">spaces</span> <span style="color:black">s</span>;
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt; ''(' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"("</span>; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; '')' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">")"</span>; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''+' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"+"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''-' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"-"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''*' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"*"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''/' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"/"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''0'..'9' <span style="color:black">as</span> <span style="color:black">c</span>;
       <span style="color:black">i</span>,<span style="color:black">v</span> = <span style="color:black">lexint</span> (<span style="color:black">Char</span>.<span style="color:black">code</span> <span style="color:black">c</span> - <span style="color:black">Char</span>.<span style="color:black">code</span>('0')) &gt;]
       -&gt;[&lt;'<span style="color:black">Lint</span> <span style="color:black">i</span> ; <span style="color:black">lexer</span> <span style="color:black">v</span>&gt;]
   <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">lexint</span> <span style="color:black">r</span> <span style="color:black">s</span> =
     <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
       [&lt; ''0'..'9' <span style="color:black">as</span> <span style="color:black">c</span> &gt;]
       -&gt; <span style="color:black">let</span> <span style="color:black">u</span> = (<span style="color:black">Char</span>.<span style="color:black">code</span> <span style="color:black">c</span>) - (<span style="color:black">Char</span>.<span style="color:black">code</span> '0') <span style="color:black">in</span> <span style="color:black">lexint</span> (10*<span style="color:black">r</span> + <span style="color:black">u</span>) <span style="color:black">s</span>
       | [&lt;&gt;] -&gt; <span style="color:black">r</span>,<span style="color:black">s</span> ;;
<span style="color:black">val</span> <span style="color:black">lexer</span> : <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">lexint</span> : <span style="color:black">int</span> -&gt; <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">int</span> * <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Функция <span style="font-family:monospace">lexint</span> предназначена для анализа той части потока символов,
которая соответствует числовой постоянной. Она вызывается, когда функция
<span style="font-family:monospace">lexer</span> встречает цифры. В этом случае функция <span style="font-family:monospace">lexint</span> поглощает
все последовательные цифры и выдаёт соответствующее значение полученного числа.</p>
<!--TOC subsection id=sec56 Регулярные выражения-->
<h3 id="sec56" class="subsection">11.3.3  Регулярные выражения</h3><!--SEC END --><p>Оставим ненадолго практику и рассмотрим проблему лексических единиц с
теоретической точки зрения.</p><p>Лексическая единица является словом. Слово образуется при конкатенации элементов
алфавита. В нашем случае алфавитом является множество символов ASCII.</p><p>Теоретически, слово может вообще не содержать символов (пустое слово
<sup><a id="text4" href="#note4">2</a></sup>) или состоять из одного символа.</p><p>Теоретические исследования конкатенации элементов алфавита для образования
лексических элементов (лексем) привели к созданию простого формализма,
известного как регулярные выражения.</p>
<!--TOC subsubsection id=sec57 Определение-->
<h4 id="sec57" class="subsubsection">Определение</h4><!--SEC END --><p>Регулярные выражения позволяют определить множества слов. Пример такого
множества: идентификаторы. Принцип определения основан на некоторых
теоретико–множественный операциях. Пусть <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span> — два множества слов, тогда
мы можем определить:</p><ul class="itemize"><li class="li-itemize">
	объединение <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span>, записываемое <span style="font-style:italic">M</span> | <span style="font-style:italic">N</span>.<p>	</p></li><li class="li-itemize">дополнение <span style="font-style:italic">M</span>, записываемое ∧ <span style="font-style:italic">M</span>: множество всех слов, кроме
тех, которые входят в <span style="font-style:italic">M</span>.<p>	</p></li><li class="li-itemize">конкатенация <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span>: множество всех слов созданных конкатенацией
слова из <span style="font-style:italic">M</span> и слова из <span style="font-style:italic">N</span>. Записывается просто <span style="font-style:italic">MN</span>.<p>	</p></li><li class="li-itemize">мы можем повторить операцию конкатенации слов множества <span style="font-style:italic">M</span> и тем
самым получить множество слов образованных из конечной последовательности слов
множеств <span style="font-style:italic">M</span>. Такое множество записывается <span style="font-style:italic">M</span>+. Он содержит все слова множества
<span style="font-style:italic">M</span>, все слова полученные конкатенацией двух слов множества <span style="font-style:italic">M</span>, трёх слов, и
т.д. Если мы желаем чтобы данное множество содержало пустое слово, необходимо
писать <span style="font-style:italic">M</span>*.<p>	</p></li><li class="li-itemize">для удобства, существует дополнительная конструкция <span style="font-style:italic">M</span>?, которая
включает все слова множества <span style="font-style:italic">M</span>, а так же пустое слово.
</li></ul><p>Один единственный символ ассоциируется с одно элементным множеством. В таком
случае выражение <span style="font-style:italic">a| b| c</span> описывает множество состоящее из трёх слов
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> и <span style="font-style:italic">c</span>. Существует более компактная запись: <span style="font-style:italic">[abc]</span>.
Так как наш алфавит является упорядоченным (по порядку кодов ASCII), можно
определить интервал. Например, множество цифр запишется как [0−9]. Для
группировки выражений можно использовать скобки.</p><p>Для того, чтобы использовать в записи сами символы–операторы, как обычные
символы, необходимо ставить перед ними обратную косую черту: \.
Например множество (\ *)* обозначает множество последовательностей
звёздочек.</p>
<!--TOC subsubsection id=sec58 Пример-->
<h4 id="sec58" class="subsubsection">Пример</h4><!--SEC END --><p>Пусть существует множество из цифр (0,1,2,3,4,5,6,7,8,9), символы плюс (+) и
минус (−), точки (.) и буквы <span style="font-style:italic">E</span>. Теперь мы можем определить множество чисел
<span style="font-style:italic">num</span>. Назовем <span style="font-style:italic">integers</span> множество определённое выражением [0−9]+.
Множество неотрицательных чисел <span style="font-style:italic">unum</span> определяется так:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">	<span style="font-style:italic">integers</span> ? (.<span style="font-style:italic">integers</span>) ? (<span style="font-style:italic">E</span>(\+|−) ? <span style="font-style:italic">integers</span>)?
</td></tr>
</table><p>Множество отрицательных и положительных чисел записывается:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">unum</span> | −<span style="font-style:italic">unum</span>    или    −?<span style="font-style:italic">unum</span>
</td></tr>
</table>
<!--TOC subsubsection id=sec59 Распознавание-->
<h4 id="sec59" class="subsubsection">Распознавание</h4><!--SEC END --><p>Теперь, после того как множество выражений определено, остаётся проблема
распознавания принадлежности строки символов или одной из её подстрок этому
множеству. Для решения данной задачи необходимо реализовать программу обработки
выражений, которая соответствует формальным определениям множества. Для
регулярных выражений такая обработка может быть автоматизирована. Подобная
автоматизация реализована в модуле <span style="font-family:monospace">Genlex</span> из библиотеки <span style="font-family:monospace">Str</span> и
инструментом <span style="font-family:monospace">ocamllex</span>, которые будут представлены в следующих двух
параграфах.</p>
<!--TOC subsubsection id=sec60 Библиотека <span style="font-family:monospace">Str</span>-->
<h4 id="sec60" class="subsubsection">Библиотека <span style="font-family:monospace">Str</span></h4><!--SEC END --><p>В данном модуле имеется абстрактный тип <span style="font-family:monospace">regexp</span> и функция
<span style="font-family:monospace">regexp</span>. Указанный тип представляет регулярные выражения, а функция
трансформирует регулярное выражение, представленное в виде строки символов, в
абстрактное представление.</p><p>Модуль <span style="font-family:monospace">Str</span> содержит несколько функций, которые используют регулярные
выражения и манипулируют символьными строками. Синтаксис регулярных выражений
библиотеки <span style="font-family:monospace">Str</span> приведён в таблице <a href="#tbl%3Areg_exps">11.1</a>.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 11.1: Регулярные выражения</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	.</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >любой символ, кроме \ </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	*</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >ноль или несколько экземпляров предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	+</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >хотя бы один экземпляр предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	?</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >ноль или один экземпляр предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	[..]</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >множество символов </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	.</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >любой символ, кроме \ </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >интервал записывается при помощи - (пример [0−9]) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >дополнение записывается при помощи ∧ (пример [∧ <span style="font-style:italic">A</span>−<span style="font-style:italic">Z</span>]) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	∧</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >начало строки (не путать с дополнением ∧) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	$</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >конец строки </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	|</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >вариант </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	(..)</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >группировка в одно выражение (можно ссылаться на это выражение) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	<span style="font-style:italic">i</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >числовая константа <span style="font-style:italic">i</span> ссылается на <span style="font-style:italic">i</span>–ый элемент группированного
выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	\</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >забой, используется для сопоставления зарезервированных
символов в регулярных выражениях </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	<a id="tbl:reg_exps"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec61 Пример-->
<h4 id="sec61" class="subsubsection">Пример</h4><!--SEC END --><p>В следующем примере напишем функцию, которая переводит дату из английского
формата во французский. Предполагается, что входной файл состоит из строк,
разбитых на поля данных и элементы даты разделяются точкой. Определим функцию,
которая из полученной строки (строка файла), выделяет дату, разбивает её на
части, переводит во французских формат и тем самым заменяет старую дату на
новую.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">french_date_of</span> <span style="color:black">d</span> =
  <span style="color:black">match</span> <span style="color:black">d</span> <span style="color:black">with</span>
   [<span style="color:black">mm</span>; <span style="color:black">dd</span>; <span style="color:black">yy</span>] -&gt; <span style="color:black">dd</span>^<span style="color:black">"/"</span>^<span style="color:black">mm</span>^<span style="color:black">"/"</span>^<span style="color:black">yy</span>
   | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"Bad date format"</span> ;;
<span style="color:black">val</span> <span style="color:black">french_date_of</span> : <span style="color:black">string</span> <span style="color:black">list</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">english_date_format</span> = <span style="color:black">Str</span>.<span style="color:black">regexp</span> <span style="color:black">"[0-9]+\.[0-9]+\.[0-9]+"</span> ;;
<span style="color:black">val</span> <span style="color:black">english_date_format</span> : <span style="color:black">Str</span>.<span style="color:black">regexp</span> = &lt;<span style="color:black">abstr</span>&gt;

# <span style="color:black">let</span> <span style="color:black">trans_date</span> <span style="color:black">l</span> =
  <span style="color:black">try</span>
  <span style="color:black">let</span> <span style="color:black">i</span>=<span style="color:black">Str</span>.<span style="color:black">search_forward</span> <span style="color:black">english_date_format</span> <span style="color:black">l</span> 0 <span style="color:black">in</span>
  <span style="color:black">let</span> <span style="color:black">d1</span> = <span style="color:black">Str</span>.<span style="color:black">matched_string</span> <span style="color:black">l</span> <span style="color:black">in</span>
  <span style="color:black">let</span> <span style="color:black">d2</span> = <span style="color:black">french_date_of</span> (<span style="color:black">Str</span>.<span style="color:black">split</span> (<span style="color:black">Str</span>.<span style="color:black">regexp</span> <span style="color:black">"\."</span>) <span style="color:black">d1</span>) <span style="color:black">in</span>
    <span style="color:black">Str</span>.<span style="color:black">global_replace</span> <span style="color:black">english_date_format</span> <span style="color:black">d2</span> <span style="color:black">l</span>
  <span style="color:black">with</span> <span style="color:black">Not_found</span> -&gt; <span style="color:black">l</span> ;;
  <span style="color:black">val</span> <span style="color:black">trans_date</span> : <span style="color:black">string</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">trans_date</span>
<span style="color:black">"..............06.13.99............"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"..............13/06/99............"</span></td></tr>
</table>
<!--TOC subsection id=sec62 Инструмент <span style="font-family:monospace">Ocamllex</span>-->
<h3 id="sec62" class="subsection">11.3.4  Инструмент <span style="font-family:monospace">Ocamllex</span></h3><!--SEC END --><p><span style="font-family:monospace">ocamllex</span> — это лексический генератор созданный для Objective CAML по
модели <span style="font-family:monospace">lex</span>, написанном на языке C. При помощи файла, описывающего
элементы лексики в виде множества регулярных выражений, которые необходимо
распознать, он создаёт файл–исходник на Objective CAML. К описанию каждого
лексического элемента можно привязать какое–нибудь действие, называемое
семантическое действие. В полученном коде используется абстрактный тип
<span style="font-family:monospace">lexbuf</span> из модуля <span style="font-family:monospace">Lexing</span>. В данном модуле также имеется
несколько функций управления лексическими буферами, которые могут быть
использованы программистом для того чтобы определить необходимые действия.</p><p>Обычно, файлы, описывающие лексику, имеют расширение <span style="font-family:monospace">.mll</span>. Для того,
чтобы из файла <span style="font-family:monospace">lex_file.mll</span> получить файл на Objective CAML,
необходимо выполнить следующую команду:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">ocamllex</span> <span style="color:black">lex_file</span>.<span style="color:black">mll</span></td></tr>
</table><p>После этого, мы получим файл <span style="font-family:monospace">lex_file.ml</span>, содержащий код лексического
анализатора. Теперь, данный файл можно использовать в программе на Objective
CAML. Каждому множеству правил анализа соответствует функция, которая принимает
лексический буфер (типа <span style="font-family:monospace">Lexing.lexbuf</span>) и затем возвращает значение,
определённое семантическим действием. Значит, все действия для определённого
правила должны создавать значение одного и того же типа.</p><p>Формат у файла для <span style="font-family:monospace">ocamllex</span> следующий:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">{
  <span style="color:black">header</span>
}
<span style="color:black">let</span> <span style="color:black">ident</span> = <span style="color:black">regexp</span>
        ...
<span style="color:black">rule</span> <span style="color:black">ruleset1</span> = <span style="color:black">parse</span>
                <span style="color:black">regexp</span> { <span style="color:black">action</span> }
                | ...
                | <span style="color:black">regexp</span> { <span style="color:black">action</span> }
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">ruleset2</span> = <span style="color:black">parse</span>
        ...
<span style="color:blue"><span style="font-weight:bold">and</span></span> ...
{
  <span style="color:black">trailer</span>-<span style="color:blue"><span style="font-weight:bold">and</span></span>-<span style="color:black">end</span>
}</td></tr>
</table><p>Части заголовок и продолжение-и-конец не являются обязательными.
Здесь вставляется код Objective CAML, определяющий типы данных, функции и т.д.
необходимые для обработки данных. В последней части используются функции,
которые используют правила анализа множества лексических данных из средней
части. Серия объявлений, которая предшествует определению правил, позволяет дать
имя некоторым регулярным выражениям. Эти имена будут использоваться в
определении правил.</p>
<!--TOC subsubsection id=sec63 Пример-->
<h4 id="sec63" class="subsubsection">Пример</h4><!--SEC END --><p>Вернёмся к нашему интерпретатору BASIC и усовершенствуем тип возвращаемых
лексических единиц. Таким образом, мы можем воспользоваться функцией
<span style="font-family:monospace">lexer</span>, (см. стр. <a href="#%3F%3F">??</a>) которая возвращает такой же тип результата
(<span style="font-family:monospace">lexeme</span>), но на входе она получает буфер типа <span style="font-family:monospace">Lexing.lexbuf</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">  {
    <span style="color:black">let</span> <span style="color:black">string_chars</span> <span style="color:black">s</span> =
    <span style="color:black">String</span>.<span style="color:black">sub</span> <span style="color:black">s</span> 1 ((<span style="color:black">String</span>.<span style="color:black">length</span> <span style="color:black">s</span>)-2) ;;
  }

<span style="color:black">let</span> <span style="color:black">op_ar</span> = ['-' '+' '*' '\%' '/']
<span style="color:black">let</span> <span style="color:black">op_bool</span> = ['!' '\&amp;' '|']
<span style="color:black">let</span> <span style="color:black">rel</span> = ['=' '&lt;' '&gt;']

<span style="color:black">rule</span> <span style="color:black">lexer</span> = <span style="color:black">parse</span>
    [' ']   { <span style="color:black">lexer</span> <span style="color:black">lexbuf</span> }
  | <span style="color:black">op_ar</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">op_bool</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&lt;="</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&gt;="</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&lt;&gt;"</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">rel</span>     { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"REM"</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"LET"</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"PRINT"</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"INPUT"</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"IF"</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"THEN"</span>  { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | '-'? ['0'-'9']+   { <span style="color:black">Lint</span> (<span style="color:black">int_of_string</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>)) }
  | ['<span style="color:black">A</span>'-'<span style="color:black">z</span>']+        { <span style="color:black">Lident</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | '<span style="color:black">"' [^ '"</span>']* '<span style="color:black">"'  { Lstring (string_chars (Lexing.lexeme lexbuf)) }</span></td></tr>
</table><p>После обработки данного файла командой <span style="font-family:monospace">ocamllex</span> получим функцию
<span style="font-family:monospace">lexer</span> типа <span style="font-family:monospace">Lexing.lexbuf -&gt; lexeme</span>. Далее, мы рассмотрим каким
образом подобные функции используются в синтаксическом анализе (см. стр.
<a href="#%3F%3F">??</a>).

</p>
<!--TOC section id=sec64 Синтаксис-->
<h2 id="sec64" class="section">11.4  Синтаксис</h2><!--SEC END --><p>Благодаря лексическому анализу, мы в состоянии разбить поток символов на более
структурированные элементы: лексические элементы. Теперь необходимо знать как
правильно объединять эти элементы в синтаксически корректные фразы какого-нибудь
языка. Правила синтаксической группировки определены посредством грамматических
правил. Формализм, произошедший из лингвистики, был с успехом перенят
математиками, занимающимися теориями языков, и специалистами по информатике. На
странице <a href="#%3F%3F">??</a> мы уже видели пример грамматики для языка BASIC. Здесь мы
снова вернёмся к этому примеру, чтобы более углублённо ознакомится с базовыми
концепциями грамматики.</p>
<!--TOC subsection id=sec65 Грамматика-->
<h3 id="sec65" class="subsection">11.4.1  Грамматика</h3><!--SEC END --><p>Говоря формальным языком, грамматика основывается на четырёх элементах:</p><ol class="enumerate" type=1><li class="li-enumerate">
	Множество символов, называемых терминалами. Эти символы являются
лексическими элементами языка. В Бэйсике к ним относятся символы операторов,
арифметических отношений и логические (+, &amp;, &lt;, ≤, ⋯), ключевые
слова языка <span style="font-weight:bold">(GOTO, PRINT, IF, THEN, </span>⋯<span style="font-weight:bold">)</span>, целые числа (элемент
<span style="font-family:monospace">integer</span>) и переменные (элемент <span style="font-family:monospace">variable</span>).<p>	</p></li><li class="li-enumerate">Множество нетерминальных символов, которые представляют
синтаксические компоненты языка. Например, программа на языке Бэйсик состоит из
строк. Таким образом мы имеем компоненту Line, которая в свою очередь
состоит из выражений (Expression), и т.д.<p>	</p></li><li class="li-enumerate">Множество так называемых порождающих правил. Они описывают каким
образом комбинируются терминальные и нетерминальные символы, чтобы создать
синтаксическую компоненту. Строка в Бэйсике начинается с номера, за которой
следует инструкция. Смысл правила следующий:<div class="center">
	Line ::= <span style="font-style:italic">integer</span> Instruction
</div><p>Одна и та же компонента может быть порождена несколькими способами. В этом
случае варианты разделяются символом | как в:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Instruction</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >LET variable = Instruction </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >GOTO integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >PRINT Expression </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		etc</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >	</td></tr>
</table>
</div></li></ol><p>Среди всех нетерминальных символов различают один, называемый начальным.
Правило, которое порождает эту аксиому является порождающим правилом всего
языка.</p>
<!--TOC subsection id=sec66 Порождение и распознавание-->
<h3 id="sec66" class="subsection">11.4.2  Порождение и распознавание</h3><!--SEC END --><p>
<a id="page_ref:Production_and_Recognition"></a></p><p>С помощью порождающих правил можно определить принадлежит ли последовательность
лексем языку.</p><p>Рассмотрим простой язык, описывающий арифметические выражения:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp + Exp</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp * Exp</td><td style="text-align:center;white-space:nowrap" >(R3) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >( Exp )</td><td style="text-align:center;white-space:nowrap" >(R4)
	</td></tr>
</table>
</div><p>здесь <span style="font-style:italic">(R1) (R2) (R3) (R4)</span> — имена правил. По окончании лексического
анализа выражение 1*(2+3) становится последовательностью следующих лексем:</p><div class="center">
<span style="font-style:italic">integer * (integer + integer)</span>
</div><p>Для того, чтобы проанализировать эту фразу и убедиться в том что она принадлежит
языку арифметических выражений, воспользуемся правилами справа налево: если
часть выражения соответствует правому члену какого-нибудь правила, мы заменяем
это выражение соответствующим левым членом. Этот процесс продолжается до тех
пор, пока выражение не будет редуцировано до аксиомы. Ниже представлен результат
такого анализа <sup><a id="text5" href="#note5">3</a></sup>:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		integer * (integer + integer)</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (integer + integer) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp + integer) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp + Exp) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R2)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R4)</td><td style="text-align:left;white-space:nowrap" >Exp * Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R3)</td><td style="text-align:left;white-space:nowrap" >Exp
	</td></tr>
</table>
</div><p>Начиная с последней линии, которая содержит лишь Exp и следуя стрелкам, можно
определить каким образом было полученное выражение исходя из аксиомы Exp.
Соответственно данная фраза является правильно сформированной фразой языка
арифметических выражений, определённого грамматикой.</p><p>Преобразование грамматики в программу, способную распознать принадлежность
последовательности лексем языку, который определён грамматикой, является более
сложной проблемой, чем проблема использования регулярных выражений.
Действительно, в соответствии с математическим результатом любое множество
(слов), определённое формализмом регулярных выражений, может быть определено
другим формализмом: детерминированные конечные автоматы. Такие автоматы легко
реализуются программами, принимающими поток символов. Подобный результат для
грамматик в общем не существует. Однако, имеются менее строгие (?) (weaker)
результаты устанавливающие эквивалентность между определёнными классами
грамматик и более богатыми автоматами: автомат со стеком. Здесь мы не станем
вдаваться ни в детали этих результатов, ни в точное определение таких автоматов.
Однако, мы можем определить какие классы грамматики могут использоваться в
средствах генерации синтаксических анализаторов или для реализации напрямую
анализатора.</p>
<!--TOC subsection id=sec67 Нисходящий анализ-->
<h3 id="sec67" class="subsection">11.4.3  Нисходящий анализ</h3><!--SEC END --><p>Разбор выражения 1 * (2 + 3) в предыдущем параграфе не является единственным:
мы с таким же успехом могли бы начать редуцирование <span style="font-style:italic">integer</span>, то есть
воспользоваться правилом <span style="font-style:italic">(R2)</span> редуцирования 2 + 3. Эти два способа
распознавания являются двумя типами анализа: восходящий анализ (справа налево) и
нисходящий слева направо. Последний анализ легко реализуется при помощи потоков
лексем модуля <span style="font-family:monospace">Stream</span>. Средство <span style="font-family:monospace">ocamlyacc</span> использует восходящий
анализ, при котором применяется стек, как это уже было проиллюстрировано
синтаксическим анализатором программ на Бэйсике. Выбор анализа не просто дело
вкуса, в зависимости от используемой для спецификации языка формы грамматики,
можно или нет применять нисходящий анализ.</p>
<!--TOC subsubsection id=sec68 Простой случай-->
<h4 id="sec68" class="subsubsection">Простой случай</h4><!--SEC END --><p>Каноническим примером нисходящего анализа является префиксная запись
арифметических выражений, определяемая как:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >+ Exp Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >* Exp Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>В данном случае достаточно знать первую лексему, для того чтобы определить какое
правило может быть использовано. При помощи подобной предсказуемости нет
необходимости явно управлять стеком, достаточно положиться на рекурсивный вызов
анализатора. И тогда при помощи <span style="font-family:monospace">Genlex</span> и <span style="font-family:monospace">Stream</span> очень просто
написать программу реализующую нисходящий анализ. Функция <span style="font-family:monospace">infix_of</span> из
полученного префиксного выражения возвращает его инфиксный эквивалент:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">lexer</span> <span style="color:black">s</span> =
   <span style="color:black">let</span> <span style="color:black">ll</span> = <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> [<span style="color:black">"+"</span>;<span style="color:black">"*"</span>]
   <span style="color:black">in</span> <span style="color:black">ll</span> (<span style="color:black">Stream</span>.<span style="color:black">of_string</span> <span style="color:black">s</span>);;
<span style="color:black">val</span> <span style="color:black">lexer</span> : <span style="color:black">string</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">stream_parse</span> <span style="color:black">s</span> =
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Ident</span> <span style="color:black">x</span>&gt;] -&gt; <span style="color:black">x</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Int</span> <span style="color:black">n</span>&gt;] -&gt; <span style="color:black">string_of_int</span> <span style="color:black">n</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Kwd</span> <span style="color:black">"+"</span>; <span style="color:black">e1</span>=<span style="color:black">stream_parse</span>; <span style="color:black">e2</span>=<span style="color:black">stream_parse</span>&gt;] -&gt; <span style="color:black">"("</span>^<span style="color:black">e1</span>^<span style="color:black">"+"</span>^<span style="color:black">e2</span>^<span style="color:black">")"</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Kwd</span> <span style="color:black">"*"</span>; <span style="color:black">e1</span>=<span style="color:black">stream_parse</span>; <span style="color:black">e2</span>=<span style="color:black">stream_parse</span>&gt;] -&gt; <span style="color:black">"("</span>^<span style="color:black">e1</span>^<span style="color:black">"*"</span>^<span style="color:black">e2</span>^<span style="color:black">")"</span>
   | [&lt;&gt;] -&gt; <span style="color:black">failwith</span> <span style="color:black">"Parse error"</span> ;;
<span style="color:black">val</span> <span style="color:black">stream_parse</span> : <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">infix_of</span> <span style="color:black">s</span> = <span style="color:black">stream_parse</span> (<span style="color:black">lexer</span> <span style="color:black">s</span>) ;;
<span style="color:black">val</span> <span style="color:black">infix_of</span> : <span style="color:black">string</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">infix_of</span> <span style="color:black">"* +3 11 22"</span>;;
- : <span style="color:black">string</span> = <span style="color:black">"((3+11)*22)"</span></td></tr>
</table><p>Однако не стоит забывать о некоторой примитивности лексического анализа.
Советуем периодически добавлять пробелы между различными лексическими
элементами.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">infix_of</span> <span style="color:black">"*+3 11 22"</span>;;
- : <span style="color:black">string</span> = <span style="color:black">"*+"</span></td></tr>
</table>
<!--TOC subsubsection id=sec69 Случай посложней-->
<h4 id="sec69" class="subsubsection">Случай посложней</h4><!--SEC END --><p>Синтаксический анализ при помощи потоков предсказуем, он облагает грамматику
двумя условиями:</p><ul class="itemize"><li class="li-itemize">
	В правилах грамматики не должно быть левой рекурсии. Правило
называется рекурсивным слева, если его правый член начинается с нетерминального
символа, который является левой частью правила. Например: <span style="font-family:monospace">Exp ::= Exp +
Exp</span><p>	</p></li><li class="li-itemize">Не должно существовать правил начинающихся одним и тем же выражением.
</li></ul><p>Грамматика арифметических выражений, приведённая на стр.
<a href="#page_ref%3AProduction_and_Recognition">??</a>, не подходит для нисходящего
анализа: они не удовлетворяют ни одному из условий. Для того, чтобы применить
нисходящий анализ необходимо переформулировать грамматику таким образом, чтобы
удалить левую рекурсию и неопределённость правил. Вот полученный результат:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >Atom NextExpr </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		NextExpr</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >+ Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >- Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >* Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >/ Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" > 		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >ε </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		 Atom</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >( Expr )
	</td></tr>
</table>
</div><p>Заметьте использование пустого слова ε в определении
<span style="font-family:monospace">NextExpr</span>. Оно необходимо, если мы хотим чтобы просто целое число
являлось выражением.</p><p>Следующий анализатор есть просто перевод вышеуказанной грамматики в код. Он
реализует абстрактное синтаксическое дерево арифметических выражений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">rest</span> = <span style="color:black">parser</span>
    [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"+"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">PLUS</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"-"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">MINUS</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"*"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">MULT</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"/"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">DIV</span>,<span style="color:black">e2</span>)
  | [&lt; &gt;] -&gt; <span style="color:black">None</span>
 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">atom</span> = <span style="color:black">parser</span>
     [&lt; '<span style="color:black">Lint</span> <span style="color:black">i</span> &gt;] -&gt; <span style="color:black">ExpInt</span> <span style="color:black">i</span>
   | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"("</span>; <span style="color:black">e</span> = <span style="color:black">expr</span> ; '<span style="color:black">Lsymbol</span> <span style="color:black">")"</span> &gt;] -&gt; <span style="color:black">e</span>
 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">expr</span> <span style="color:black">s</span> =
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt; <span style="color:black">e1</span> = <span style="color:black">atom</span> &gt;] -&gt;
       <span style="color:black">match</span> <span style="color:black">rest</span> <span style="color:black">s</span> <span style="color:black">with</span>
          <span style="color:black">None</span> -&gt; <span style="color:black">e1</span>
        | <span style="color:black">Some</span> (<span style="color:black">op</span>,<span style="color:black">e2</span>) -&gt; <span style="color:black">ExpBin</span>(<span style="color:black">e1</span>,<span style="color:black">op</span>,<span style="color:black">e2</span>) ;;
<span style="color:black">val</span> <span style="color:black">rest</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; (<span style="color:black">bin_op</span> * <span style="color:black">expression</span>) <span style="color:black">option</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">atom</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">expression</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">expr</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">expression</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Сложность использования нисходящего анализа заключается в том, что грамматика
должна быть очень ограниченной формы. Если язык выражен естественно с
использованием левой рекурсии (как в инфиксных выражениях), то не всегда легко
определить эквивалентную грамматику, то есть определяющую такой же язык, которая
бы удовлетворяла требованиям нисходящего анализа. По этой причине, средства
<span style="font-family:monospace">yacc</span> и <span style="font-family:monospace">ocamlyacc</span> реализуют восходящий анализ, который
разрешает определение более естественных грамматик. Однако, мы увидим, что даже
в этом случае существуют ограничения.</p>
<!--TOC subsection id=sec70 Восходящий анализ-->
<h3 id="sec70" class="subsection">11.4.4  Восходящий анализ</h3><!--SEC END --><p>Мы уже вкратце представили на странице <a href="#%3F%3F">??</a> принципы восходящего
анализа: сдвиг и вывод <sup><a id="text6" href="#note6">4</a></sup>.
После каждого подобного действия, состояние стека изменяется. Из этой
последовательности можно вывести правила грамматики, в случае если грамматика
это позволяет, как в примере с нисходящим анализом. Опять же, сложности
возникают из-за неопределённости правил, когда невозможно выбрать между
продвинутся или сократить. Проиллюстрируем действие восходящего анализа и его
недостатки на все тех же арифметических выражениях в постфиксном и инфиксном
написании.</p>
<!--TOC subsubsection id=sec71 Положительная сторона-->
<h4 id="sec71" class="subsubsection">Положительная сторона</h4><!--SEC END --><p>Упрощённая постфиксная грамматика арифметических выражений выглядит так:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp Exp +</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp Exp -</td><td style="text-align:center;white-space:nowrap" >(R3) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Данная грамматика является двойственной по отношению к префиксной: для того
чтобы точно знать какое правило следует применить, необходимо дождаться
окончания анализа. В действительности анализ подобных выражений схож с
вычислением при помощи стека. Только вместо проталкивания результата вычисления,
проталкиваются грамматические символы. Если в начале стек пустой, то после того
как ввод закончен, необходимо получить стек содержащий лишь нетерминальную
аксиому. Приведём изменение стека: если мы продвигаемся, то проталкивается
текущий нетерминальный символ; если сокращаем, то первые символы стека
соответствуют правому члену (в обратном порядке) правила и тогда мы заменяем эти
элементы соответствующими нетерминальными элементами.</p><p>В таблице <a href="#tbl%3Abottom-up_parsing">11.2</a> приведён восходящий анализ выражения 1 2
+ 3 * 4 +. Считываемая лексическая единица подчёркивается для более удобного
чтения. Конец потока помечается символом $.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 11.2: Восходящий анализ</td></tr>
</table></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>1</U> 2 + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>2</U> + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[1] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>2</U> + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[2 Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R2)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>3</U> * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>*</U> 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R3)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>4</U> + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R2)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>$</U></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
	<a id="tbl:bottom-up_parsing"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec72 Отрицательная сторона-->
<h4 id="sec72" class="subsubsection">Отрицательная сторона</h4><!--SEC END --><p>Вся трудность перехода от грамматики к программе распознающей язык заключается в
определении действия, которое необходимо применить. Проиллюстрируем эту проблему
на трёх примерах, приводящих к трём неопределённостям.</p><p>Первый пример есть грамматика выражений использующих операцию сложения:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E0 + E0</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Неопределённость данной грамматики проявляется при использовании правила <span style="font-style:italic">R2</span>. Предположим следующую ситуацию:</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >E0 + E0 … </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>В подобном случае невозможно определить необходимо сдвинуть и протолкнуть в стек
+ или сократить в соответствии с правилом <span style="font-style:italic">(R2)</span> оба E0 и присутствующий в
стеке +. Подобная ситуация называется конфликтом сдвиг-вывод (shift/reduce). Она
является следствием того, что выражение <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> может быть выведено справа двумя способами.</p><p>Первый вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Второй вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) E0 + E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Выражения, полученные двумя выводами, могут показаться одинаковыми с точки
зрения вычисления выражения,</p><p>(<span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span>) + <span style="font-style:italic">integer</span> и <span style="font-style:italic">integer</span> + (<span style="font-style:italic">integer</span>
+ <span style="font-style:italic">integer</span>)</p><p>но разными для конструкции синтаксического дерева (см. рис. <a href="#%3F%3F">??</a> на стр.
<a href="#%3F%3F">??</a>)</p><p>Второй пример грамматики, порождающей конфликт между сдвиг-вывод, содержит
такую же неопределённость: явное заключение в скобки. Но в отличии от
предыдущего случая, выбор сдвиг-вывод изменяет смысл выражения. Пусть есть
грамматика:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span> (<span style="font-style:italic">R1</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E1 + E1 (<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E1 * E1 (<span style="font-style:italic">R3</span>)
	</td></tr>
</table>
</div><p>Здесь мы снова получаем предыдущий конфликт как в случае с + так и для *, но к
этому добавляется другой, между + и *. Опять же, одно и то же выражение может
быть получено двумя способами, так как у него существует два вывода справа:</p><p><span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> * <span style="font-style:italic">integer</span></p><p>Первый вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R3</span>) E0 * <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) <U>E1</U> * <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + <U>E1</U> * <span style="font-style:italic">integer</span>
	</td></tr>
</table>
</div><p>Второй вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + E1 * <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) E1 + <U>E1</U> * <span style="font-style:italic">integer</span>
	</td></tr>
</table>
</div><p>В данном выражении обе пары скобок имеют разный смысл:</p><p>(<span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span>) * <span style="font-style:italic">integer</span> ≠ <span style="font-style:italic">integer</span> + (<span style="font-style:italic">integer</span> * <span style="font-style:italic">integer</span>)</p><p>Подобную проблему, мы уже встречали в выражениях Basic (см. стр. <a href="#%3F%3F">??</a>).
Она была разрешена при помощи приоритетов, которые присваиваются операторам:
сначала редуцируется правило (R3), затем (R2), что соответствует заключению в
скобки произведения.</p><p>Данную проблему выбора между + и * можно решить изменив грамматику. Для того,
введём два новых терминальных символа: член T (<span style="font-style:italic">term</span>) и множитель F
(<span style="font-style:italic">factor</span>). Отсюда получаем:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >E + T</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R1</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >T</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		T</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >T + F</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R3</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >F</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R4</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		F</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >T + <span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R5</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>После этого, единственный способ получить <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> *
<span style="font-style:italic">integer</span>: посредством правила (<span style="font-style:italic">R1</span>).</p><p>Третий и последний случай касается условных конструкций языка программирования.
На пример в Pascal существует две конструкции: <span style="font-family:monospace">if .. then</span> и <span style="font-family:monospace">if
.. then .. else</span>. Пусть существует следующая грамматика:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Instr</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> EXP <span style="font-style:italic">then</span> Instr</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R1</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >-</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> EXP <span style="font-style:italic">then</span> Instr <span style="font-style:italic">else</span> Instr</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >-</td><td style="text-align:left;white-space:nowrap" >etc …</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>И в следующей ситуации:</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">else</span></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Instr <span style="font-style:italic">then</span> Epx <span style="font-style:italic">if</span> …] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Невозможно определить соответствуют ли элементы стека правила (<span style="font-style:italic">R1</span>) и в
этом случае необходимо сократить или соответствуют первому <span style="font-family:monospace">Instr</span>
правила (<span style="font-style:italic">R2</span>) и тогда необходимо сдвинуть.</p><p>Кроме конфликтов сдвиг-вывод, восходящий анализ вызывает конфликт вывод-вывод.</p><p>Мы представим здесь инструмент <span style="font-family:monospace">ocamlyacc</span>, который использует подобную
технику может встретить указанные конфликты.
</p>
<!--TOC section id=sec73 Пересмотренный Basic-->
<h2 id="sec73" class="section">11.5  Пересмотренный Basic</h2><!--SEC END --><p>Теперь, используя совместно <span style="font-family:monospace">ocamllex</span> и <span style="font-family:monospace">ocamlyacc</span>, заменим
функцию <span style="font-family:monospace">parse</span> для Бэйсика, приведённую на странице <a href="#%3F%3F">??</a>, на
функции полученные при помощи файлов спецификации лексики и синтаксиса языка.</p><p>Для этого, мы не сможем воспользоваться типами лексических единиц, в таком виде
как они были определены. Необходимо определить более точные типы, чтобы
различать операторы, команды и ключевые слова.</p><p>Так же, нам понадобится изолировать в отдельном файле <span style="font-family:monospace">basic_types.mli</span>
декларации типов, относящиеся к абстрактному синтаксису. В нем будут содержатся
декларации типа <span style="font-family:monospace">sentences</span>, а так же других типы необходимые этому.</p>
<!--TOC subsection id=sec74 Файл <span style="font-family:monospace">basic_parser.mly</span>-->
<h3 id="sec74" class="subsection">11.5.1  Файл <span style="font-family:monospace">basic_parser.mly</span></h3><!--SEC END -->
<!--TOC subsubsection id=sec75 Заголовок-->
<h4 id="sec75" class="subsubsection">Заголовок</h4><!--SEC END --><p>Данный файл содержит вызовы деклараций типов абстрактного синтаксиса и две
функции перевода строк символов в их эквивалент абстрактного синтаксиса.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%{
<span style="color:black">open</span> <span style="color:black">Basic_types</span> ;;

<span style="color:black">let</span> <span style="color:black">phrase_of_cmd</span> <span style="color:black">c</span> =
 <span style="color:black">match</span> <span style="color:black">c</span> <span style="color:black">with</span>
   <span style="color:black">"RUN"</span> -&gt; <span style="color:black">Run</span>
 | <span style="color:black">"LIST"</span> -&gt; <span style="color:black">List</span>
 | <span style="color:black">"END"</span> -&gt; <span style="color:black">End</span>
 | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"line : unexpected command"</span>
;;

<span style="color:black">let</span> <span style="color:black">bin_op_of_rel</span> <span style="color:black">r</span> =
 <span style="color:black">match</span> <span style="color:black">r</span> <span style="color:black">with</span>
   <span style="color:black">"="</span> -&gt; <span style="color:black">EQUAL</span>
 | <span style="color:black">"&lt;"</span> -&gt; <span style="color:black">INF</span>
 | <span style="color:black">"&lt;="</span> -&gt; <span style="color:black">INFEQ</span>
 | <span style="color:black">"&gt;"</span> -&gt; <span style="color:black">SUP</span>
 | <span style="color:black">"&gt;="</span> -&gt; <span style="color:black">SUPEQ</span>
 | <span style="color:black">"&lt;&gt;"</span> -&gt; <span style="color:black">DIFF</span>
 | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"line : unexpected relation symbol"</span>
;;

%}</td></tr>
</table>
<!--TOC subsubsection id=sec76 Декларации-->
<h4 id="sec76" class="subsubsection">Декларации</h4><!--SEC END --><p>Здесь содержится три части: декларация лексем, декларация правил ассоциативности
и приоритетов, декларация стартового символа <span style="font-family:monospace">line</span>, которая
соответствует анализу линии программы или команды.</p><p>Ниже представлены лексические единицы:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">token</span> &lt;<span style="color:black">int</span>&gt; <span style="color:black">Lint</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lident</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lstring</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lcmd</span>
%<span style="color:black">token</span> <span style="color:black">Lplus</span> <span style="color:black">Lminus</span> <span style="color:black">Lmult</span> <span style="color:black">Ldiv</span> <span style="color:black">Lmod</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lrel</span>
%<span style="color:black">token</span> <span style="color:black">Land</span> <span style="color:black">Lor</span> <span style="color:black">Lneg</span>
%<span style="color:black">token</span> <span style="color:black">Lpar</span> <span style="color:black">Rpar</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lrem</span>
%<span style="color:black">token</span> <span style="color:black">Lrem</span> <span style="color:black">Llet</span> <span style="color:black">Lprint</span> <span style="color:black">Linput</span> <span style="color:black">Lif</span> <span style="color:black">Lthen</span> <span style="color:black">Lgoto</span>
%<span style="color:black">token</span> <span style="color:black">Lequal</span>
%<span style="color:black">token</span> <span style="color:black">Leol</span></td></tr>
</table><p>Имена деклараций говорят сами за себя и они описаны в файле
<span style="font-family:monospace">basic_lexer.mll</span> (см. стр. <a href="#%3F%3F">??</a>).</p><p>Правила приоритета операторов схожи со значениями, которые определяются
функциями <span style="font-family:monospace">priority_uop</span> и <span style="font-family:monospace">priority_binop</span>, которые были
определены грамматикой Бейсика (см. стр. <a href="#%3F%3F">??</a>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">right</span> <span style="color:black">Lneg</span>
%<span style="color:black">left</span> <span style="color:black">Land</span> <span style="color:black">Lor</span>
%<span style="color:black">left</span> <span style="color:black">Lequal</span> <span style="color:black">Lrel</span>
%<span style="color:black">left</span> <span style="color:black">Lmod</span>
%<span style="color:black">left</span> <span style="color:black">Lplus</span> <span style="color:black">Lminus</span>
%<span style="color:black">left</span> <span style="color:black">Lmult</span> <span style="color:black">Ldiv</span>
%<span style="color:black">nonassoc</span> <span style="color:black">Lop</span></td></tr>
</table><p>Символ <span style="font-family:monospace">Lop</span> необходим для обработки унарных минусов. Он не является
терминальным символом, а псевдо–терминальным. Благодаря этому, получаем
перегрузку операторов, когда в двух случаях использования одного и того же
оператора, приоритет меняется в зависимости от контекста. Мы вернёмся к этому
случаю, когда будем рассматривать правила грамматики.</p><p>Здесь нетерминалом является <span style="font-family:monospace">line</span>. Полученная функция возвращает дерево
абстрактного синтаксиса, которое соответствует проанализированной линии.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">start</span> <span style="color:black">line</span>
%<span style="color:black">type</span> &lt;<span style="color:black">Basic_types</span>.<span style="color:black">phrase</span>&gt; <span style="color:black">line</span></td></tr>
</table>
<!--TOC subsubsection id=sec77 Правила грамматики-->
<h4 id="sec77" class="subsubsection">Правила грамматики</h4><!--SEC END --><p>Грамматика делится на 3 нетерминальных элемента: <span style="font-family:monospace">line</span> для линии,
<span style="font-family:monospace">inst</span> для инструкции и <span style="font-family:monospace">exp</span> для выражений. Действия, которые
привязаны к каждому правилу лишь создают соответствующую часть абстрактного
синтаксиса.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"> %%
<span style="color:black">line</span> :
   <span style="color:black">Lint</span> <span style="color:black">inst</span> <span style="color:black">Leol</span>               { <span style="color:black">Line</span> {<span style="color:black">num</span>=<span style="color:black">$1</span>; <span style="color:black">inst</span>=<span style="color:black">$2</span>} }
 | <span style="color:black">Lcmd</span> <span style="color:black">Leol</span>                    { <span style="color:black">phrase_of_cmd</span> <span style="color:black">$1</span> }
 ;

<span style="color:black">inst</span> :
   <span style="color:black">Lrem</span>                         { <span style="color:black">Rem</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lgoto</span> <span style="color:black">Lint</span>                   { <span style="color:black">Goto</span> <span style="color:black">$2</span> }
 | <span style="color:black">Lprint</span> <span style="color:black">exp</span>                   { <span style="color:black">Print</span> <span style="color:black">$2</span> }
 | <span style="color:black">Linput</span> <span style="color:black">Lident</span>                { <span style="color:black">Input</span> <span style="color:black">$2</span> }
 | <span style="color:black">Lif</span> <span style="color:black">exp</span> <span style="color:black">Lthen</span> <span style="color:black">Lint</span>           { <span style="color:black">If</span> (<span style="color:black">$2</span>, <span style="color:black">$4</span>) }
 | <span style="color:black">Llet</span> <span style="color:black">Lident</span> <span style="color:black">Lequal</span> <span style="color:black">exp</span>        { <span style="color:black">Let</span> (<span style="color:black">$2</span>, <span style="color:black">$4</span>) }
 ;

<span style="color:black">exp</span> :
   <span style="color:black">Lint</span>                         { <span style="color:black">ExpInt</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lident</span>                       { <span style="color:black">ExpVar</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lstring</span>                      { <span style="color:black">ExpStr</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lneg</span> <span style="color:black">exp</span>                     { <span style="color:black">ExpUnr</span> (<span style="color:black">NOT</span>, <span style="color:black">$2</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lplus</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">PLUS</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lminus</span> <span style="color:black">exp</span>               { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MINUS</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lmult</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MULT</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Ldiv</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">DIV</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lmod</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MOD</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lequal</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">EQUAL</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lrel</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, (<span style="color:black">bin_op_of_rel</span> <span style="color:black">$2</span>), <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Land</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:blue"><span style="font-weight:bold">AND</span></span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lor</span> <span style="color:black">exp</span>                  { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">OR</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">Lminus</span> <span style="color:black">exp</span> %<span style="color:black">prec</span> <span style="color:black">Lop</span>        { <span style="color:black">ExpUnr</span>(<span style="color:black">OPPOSITE</span>, <span style="color:black">$2</span>) }
 | <span style="color:black">Lpar</span> <span style="color:black">exp</span> <span style="color:black">Rpar</span>                { <span style="color:black">$2</span> }
 ;
 %%</td></tr>
</table><p>Данные правила не нуждаются в особых комментариях, кроме следующего:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">exp</span> :
 ...
 | <span style="color:black">Lminus</span> <span style="color:black">exp</span> %<span style="color:black">prec</span> <span style="color:black">Lop</span> { <span style="color:black">ExpUnr</span>(<span style="color:black">OPPOSITE</span>, <span style="color:black">$2</span>) }</td></tr>
</table><p>Это правило касается использования унарного минуса -. Ключевое слово
<span style="font-family:monospace">%prec</span> означает, что указанная конструкция получает приоритет от
<span style="font-family:monospace">Lop</span> (в данном случае наивысший).</p>
<!--TOC subsection id=sec78 Файл <span style="font-family:monospace">basic_lexer.mll</span>-->
<h3 id="sec78" class="subsection">11.5.2  Файл <span style="font-family:monospace">basic_lexer.mll</span></h3><!--SEC END --><p>Лексический анализ содержит лишь одно множество: <span style="font-family:monospace">lexer</span>, которое точно
соответствует старой функции <span style="font-family:monospace">lexer</span> (см. стр. <a href="#%3F%3F">??</a>).</p><p>Семантическое действие, которое связано с распознаванием лексических единиц,
возвращает результат соответствующего конструктора. Необходимо загрузить файл
синтаксических правил, так как в нем декларируется тип лексических единиц.
Добавим так же функцию, которая удаляет кавычки вокруг строк.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">{
 <span style="color:black">open</span> <span style="color:black">Basic_parser</span> ;;

 <span style="color:black">let</span> <span style="color:black">string_chars</span> <span style="color:black">s</span> = <span style="color:black">String</span>.<span style="color:black">sub</span> <span style="color:black">s</span> 1 ((<span style="color:black">String</span>.<span style="color:black">length</span> <span style="color:black">s</span>)-2) ;;
}

<span style="color:black">rule</span> <span style="color:black">lexer</span> = <span style="color:black">parse</span>
   [' ' '\<span style="color:black">t</span>']            { <span style="color:black">lexer</span> <span style="color:black">lexbuf</span> }

 | '\<span style="color:black">n</span>'                  { <span style="color:black">Leol</span> }

 | '!'                   { <span style="color:black">Lneg</span> }
 | '&amp;'                   { <span style="color:black">Land</span> }
 | '|'                   { <span style="color:black">Lor</span> }
 | '='                   { <span style="color:black">Lequal</span> }
 | '%'                   { <span style="color:black">Lmod</span> }
 | '+'                   { <span style="color:black">Lplus</span> }
 | '-'                   { <span style="color:black">Lminus</span> }
 | '*'                   { <span style="color:black">Lmult</span> }
 | '/'                   { <span style="color:black">Ldiv</span> }

 | ['&lt;' '&gt;']             { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"&lt;="</span>                  { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"&gt;="</span>                  { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }

 | <span style="color:black">"REM"</span> [^ '\<span style="color:black">n</span>']*       { <span style="color:black">Lrem</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"LET"</span>                 { <span style="color:black">Llet</span> }
 | <span style="color:black">"PRINT"</span>               { <span style="color:black">Lprint</span> }
 | <span style="color:black">"INPUT"</span>               { <span style="color:black">Linput</span> }
 | <span style="color:black">"IF"</span>                  { <span style="color:black">Lif</span> }
 | <span style="color:black">"THEN"</span>                { <span style="color:black">Lthen</span> }
 | <span style="color:black">"GOTO"</span>                { <span style="color:black">Lgoto</span> }

 | <span style="color:black">"RUN"</span>                { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"LIST"</span>               { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"END"</span>                { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }

 | ['0'-'9']+           { <span style="color:black">Lint</span> (<span style="color:black">int_of_string</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>)) }
 | ['<span style="color:black">A</span>'-'<span style="color:black">z</span>']+           { <span style="color:black">Lident</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | '<span style="color:black">"' [^ '"</span>']* '<span style="color:black">"'     { Lstring (string_chars (Lexing.lexeme lexbuf)) }</span></td></tr>
</table><p>Заметьте, что нам пришлось изолировать символ =, который используется
одновременно в выражениях и приравниваниях.</p><p>Для двух рациональных выражений необходимо привести определённые объяснения.
Линия комментариев соответствует выражению <span style="font-family:monospace">("REM"
[</span>∧<span style="font-family:monospace">’</span>\<span style="font-family:monospace">n’]*)</span>, где за ключевым словом <span style="font-family:monospace">REM</span> следует какое
угодно количество символов и затем перевод строки. Правило, которое
соответствует символьным строкам, <span style="font-family:monospace">(’"’ [</span>∧<span style="font-family:monospace"> ’"’]* ’"’)</span>,
подразумевает последовательность символов, отличных от " и заключённых в
кавычки ".</p>
<!--TOC subsection id=sec79 Компиляция, компоновка-->
<h3 id="sec79" class="subsection">11.5.3  Компиляция, компоновка</h3><!--SEC END --><p>Компиляция должна быть реализована в определённом порядке. Это связано с
взаимозависимостью деклараций лексем. Поэтому в нашем случае, необходимо
выполнить команды в следующем порядке:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_types</span>.<span style="color:black">mli</span>
<span style="color:black">ocamlyacc</span> <span style="color:black">basic_parser</span>.<span style="color:black">mly</span>
<span style="color:black">ocamllex</span> <span style="color:black">basic_lexer</span>.<span style="color:black">mll</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_parser</span>.<span style="color:black">mli</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_lexer</span>.<span style="color:black">ml</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_parser</span>.<span style="color:black">ml</span></td></tr>
</table><p>После чего получим файлы <span style="font-family:monospace">basic_lexer.cmo</span> и <span style="font-family:monospace">basic_parser.cmo</span>,
которые можно использовать в нашей программе.</p><p>Теперь, у нас есть весь необходимый арсенал, для того чтобы переделать
программу.</p><p>Удалим все типы и функции параграфов лексический анализ (стр.
<a href="#%3F%3F">??</a>) и синтаксический анализ (стр. <a href="#%3F%3F">??</a>) для программы
Бэйсик. Также в функции <span style="font-family:monospace">one_command</span> (стр. <a href="#%3F%3F">??</a>) заменим
выражение:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">match</span> <span style="color:black">parse</span> (<span style="color:black">input_line</span> <span style="color:black">stdin</span>) <span style="color:black">with</span></td></tr>
</table><p>на</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">match</span> <span style="color:black">line</span> <span style="color:black">lexer</span> (<span style="color:black">Lexing</span>.<span style="color:black">from_string</span> ((<span style="color:black">input_line</span> <span style="color:black">stdin</span>)^<span style="color:black">"\n"</span>)) <span style="color:black">with</span></td></tr>
</table><p>Заметьте, что необходимо поместить в конце линии символ конца ’\n’,
который был удалён функцией <span style="font-family:monospace">input_line</span>. Это необходимо, потому что
данный символ используется для указания конца командной линии (<span style="font-family:monospace">Leol</span>).
</p>
<!--TOC section id=sec80 Exercises-->
<h2 id="sec80" class="section">11.6  Exercises</h2><!--SEC END -->
<!--TOC section id=sec81 Резюме-->
<h2 id="sec81" class="section">11.7  Резюме</h2><!--SEC END --><p>В данной главе были описаны различные средства лексического и синтаксического
анализа Objective CAML. По порядку описания:</p><ul class="itemize"><li class="li-itemize">
	модуль <span style="font-family:monospace">Str</span> для фильтрования рациональных выражений<p>	</p></li><li class="li-itemize">модуль <span style="font-family:monospace">Genlex</span> для быстрого создания простых лексических
анализаторов<p>	</p></li><li class="li-itemize"><span style="font-family:monospace">ocamllex</span> представитель семейства <span style="font-family:monospace">lex</span><p>	</p></li><li class="li-itemize"><span style="font-family:monospace">ocamlyacc</span> представитель семейства <span style="font-family:monospace">yacc</span><p>	</p></li><li class="li-itemize">потоки, для построения нисходящих анализаторов, в том числе и
контекстных
</li></ul><p>При помощи инструментов o<span style="font-family:monospace">camllex</span> и <span style="font-family:monospace">ocamlyacc</span> мы переделали
синтаксический анализ Бэйсика, который проще поддерживать, чем анализатор
представленный на стр. <a href="#%3F%3F">??</a>.
</p>
<!--TOC section id=sec82 To Learn More-->
<h2 id="sec82" class="section">11.8  To Learn More</h2><!--SEC END -->
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note3" href="#text3">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">тип
<span style="font-family:monospace">lexeme</span> определён на стр. <a href="#%3F%3F">??</a></div>
</dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">традиционно, такое слово обозначается греческой буквой эпсилон:
ε</div>
</dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">анализируемая часть выражения подчёркнута, а так же
указано используемое правило </div>
</dd><dt class="dt-thefootnotes"><a id="note6" href="#text6">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Обычно на русский язык термины <span style="font-weight:bold">shift</span> и
<span style="font-weight:bold">reduce</span> переводят как сдвиг и вывод, но в данной книге для термина <span style="font-weight:bold">reduce</span> будет также использоваться перевод сокращение — прим. пер. </div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec83 Взаимодействие с языком C-->
<h1 id="sec83" class="chapter">Глава 12  Взаимодействие с языком C</h1><!--SEC END -->
<!--TOC chapter id=sec84 Приложения-->
<h1 id="sec84" class="chapter">Глава 13  Приложения</h1><!--SEC END -->
<!--TOC part id=sec85 Устройство программы-->
<table class="center"><tr><td><h1 id="sec85" class="part">Часть III<br>
Устройство программы</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec86 Модульное программирование-->
<h1 id="sec86" class="chapter">Глава 14  Модульное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec87 Объектно-ориентированное программирование-->
<h1 id="sec87" class="chapter">Глава 15  Объектно-ориентированное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec88 Сравнение моделей устройств программ-->
<h1 id="sec88" class="chapter">Глава 16  Сравнение моделей устройств программ</h1><!--SEC END -->
<!--TOC chapter id=sec89 Приложения-->
<h1 id="sec89" class="chapter">Глава 17  Приложения</h1><!--SEC END -->
<!--TOC part id=sec90 Параллелизм и распределение-->
<table class="center"><tr><td><h1 id="sec90" class="part">Часть IV<br>
Параллелизм и распределение</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec91 Процессы и связь между процессами-->
<h1 id="sec91" class="chapter">Глава 18  Процессы и связь между процессами</h1><!--SEC END -->
<!--TOC chapter id=sec92 Параллельное программирование-->
<h1 id="sec92" class="chapter">Глава 19  Параллельное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec93 Распределённое программирование-->
<h1 id="sec93" class="chapter">Глава 20  Распределённое программирование</h1><!--SEC END -->
<!--TOC chapter id=sec94 Приложения-->
<h1 id="sec94" class="chapter">Глава 21  Приложения</h1><!--SEC END -->
<!--TOC part id=sec95 Разработка программ с помощью Objective CAML-->
<table class="center"><tr><td><h1 id="sec95" class="part">Часть V<br>
Разработка программ с помощью Objective CAML</h1></td></tr>
</table><!--SEC END -->
<!--TOC part id=sec96 Приложения-->
<table class="center"><tr><td><h1 id="sec96" class="part">Часть VI<br>
Приложения</h1></td></tr>
</table><!--SEC END --><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Этот документ был преобразован из L<sup>A</sup>T<sub>E</sub>X
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
