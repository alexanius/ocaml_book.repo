<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.00">
<style type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.footnotetext{margin:0ex; padding 0ex;}
div.footnotetext P{margin:0px; text-indent:1em;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
div table{margin-left:inherit;margin-right:inherit;margin-bottom:2px;margin-top:2px}
td table{margin:auto;}
table{border-collapse:collapse;}
td{padding:0;}
.cellpadding0 tr td{padding:0;}
.cellpadding1 tr td{padding:1px;}
pre{text-align:left;margin-left:0ex;margin-right:auto;}
blockquote{margin-left:4ex;margin-right:4ex;text-align:left;}
td p{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.part{margin:2ex auto;text-align:center}
</style>
<title>Разработка программ с помощью Objective Caml 
Developing Applications with Objective Caml
</title>
</head>
<body >
<!--HEVEA command line is: hevea -o ocaml-book-full/ocaml-book-full.html styles/misc.hva src/main.tex -I . -I styles -->
<!--CUT STYLE book--><!--CUT DEF chapter 1 --><table class="title"><tr><td><h1 class="titlemain">Разработка программ с помощью Objective Caml<br>
Developing Applications with Objective Caml</h1><h3 class="titlerest">Emmanuel Chailloux<br>
Pascal Manoury<br>
Bruno Pagano</h3></td></tr>
</table><!--TOC chapter id=sec1 Содержание-->
<h1 id="sec1" class="chapter">Содержание</h1><!--SEC END --><ul class="toc"><li class="li-toc">
<a href="#sec2">Глава 1  Как заполучить Objective CAML</a>
</li></ul><ul class="toc"><li class="li-toc">
<a href="#sec3">Часть I  Основы языка</a>
<ul class="toc"><li class="li-toc">
<a href="#sec4">Глава 2  Функциональное программирование</a>
<ul class="toc"><li class="li-toc">
<a href="#sec5">2.1  Введение</a>
</li><li class="li-toc"><a href="#sec6">2.2  План главы</a>
</li><li class="li-toc"><a href="#sec7">2.3  Функциональное ядро Objective CAML</a>
<ul class="toc"><li class="li-toc">
<a href="#sec8">2.3.1  Значения, функции и базовые типы</a>
</li><li class="li-toc"><a href="#sec18">2.3.2  Структуры условного контроля</a>
</li></ul>
</li></ul>
</li><li class="li-toc"><a href="#sec20">Глава 3  Императивное программирование</a>
</li><li class="li-toc"><a href="#sec21">Глава 4  Функциональный и императивный стиль</a>
</li><li class="li-toc"><a href="#sec22">Глава 5  Графический интерфейс</a>
</li><li class="li-toc"><a href="#sec23">Глава 6  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec24">Часть II  Средства разработки</a>
<ul class="toc"><li class="li-toc">
<a href="#sec25">Глава 7  Компиляция и переносимость</a>
</li><li class="li-toc"><a href="#sec26">Глава 8  Библиотеки</a>
</li><li class="li-toc"><a href="#sec27">Глава 9  Автоматический сборщик мусора</a>
</li><li class="li-toc"><a href="#sec28">Глава 10  Средства анализа программ</a>
</li><li class="li-toc"><a href="#sec29">Глава 11  Средства лексического и синтаксического анализа</a>
<ul class="toc"><li class="li-toc">
<a href="#sec30">11.1  Введение</a>
</li><li class="li-toc"><a href="#sec31">11.2  План главы</a>
</li><li class="li-toc"><a href="#sec32">11.3  Лексика</a>
<ul class="toc"><li class="li-toc">
<a href="#sec33">11.3.1  Модуль <span style="font-family:monospace">Genlex</span></a>
</li><li class="li-toc"><a href="#sec34">11.3.2  Использование потоков</a>
</li><li class="li-toc"><a href="#sec35">11.3.3  Регулярные выражения</a>
</li><li class="li-toc"><a href="#sec41">11.3.4  Инструмент <span style="font-family:monospace">Ocamllex</span></a>
</li></ul>
</li><li class="li-toc"><a href="#sec43">11.4  Синтаксис</a>
<ul class="toc"><li class="li-toc">
<a href="#sec44">11.4.1  Грамматика</a>
</li><li class="li-toc"><a href="#sec45">11.4.2  Порождение и распознавание</a>
</li><li class="li-toc"><a href="#sec46">11.4.3  Нисходящий анализ</a>
</li><li class="li-toc"><a href="#sec49">11.4.4  Восходящий анализ</a>
</li></ul>
</li><li class="li-toc"><a href="#sec52">11.5  Пересмотренный Basic</a>
<ul class="toc"><li class="li-toc">
<a href="#sec53">11.5.1  Файл <span style="font-family:monospace">basic_parser.mly</span></a>
</li><li class="li-toc"><a href="#sec57">11.5.2  Файл <span style="font-family:monospace">basic_lexer.mll</span></a>
</li><li class="li-toc"><a href="#sec58">11.5.3  Компиляция, компоновка</a>
</li></ul>
</li><li class="li-toc"><a href="#sec59">11.6  Exercises</a>
</li><li class="li-toc"><a href="#sec60">11.7  Резюме</a>
</li><li class="li-toc"><a href="#sec61">11.8  To Learn More</a>
</li></ul>
</li><li class="li-toc"><a href="#sec62">Глава 12  Взаимодействие с языком C</a>
</li><li class="li-toc"><a href="#sec63">Глава 13  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec64">Часть III  Устройство программы</a>
<ul class="toc"><li class="li-toc">
<a href="#sec65">Глава 14  Модульное программирование</a>
</li><li class="li-toc"><a href="#sec66">Глава 15  Объектно-ориентированное программирование</a>
</li><li class="li-toc"><a href="#sec67">Глава 16  Сравнение моделей устройств программ</a>
</li><li class="li-toc"><a href="#sec68">Глава 17  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec69">Часть IV  Параллелизм и распределение</a>
<ul class="toc"><li class="li-toc">
<a href="#sec70">Глава 18  Процессы и связь между процессами</a>
</li><li class="li-toc"><a href="#sec71">Глава 19  Параллельное программирование</a>
</li><li class="li-toc"><a href="#sec72">Глава 20  Распределённое программирование</a>
</li><li class="li-toc"><a href="#sec73">Глава 21  Приложения</a>
</li></ul>
</li><li class="li-toc"><a href="#sec74">Часть V  Разработка программ с помощью Objective CAML</a>
</li><li class="li-toc"><a href="#sec75">Часть VI  Приложения</a>
</li></ul>
<!--TOC chapter id=sec2 Как заполучить Objective CAML-->
<h1 id="sec2" class="chapter">Глава 1  Как заполучить Objective CAML</h1><!--SEC END -->
<!--TOC part id=sec3 Основы языка-->
<table class="center"><tr><td><h1 id="sec3" class="part">Часть I<br>
Основы языка</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec4 Функциональное программирование-->
<h1 id="sec4" class="chapter">Глава 2  Функциональное программирование</h1><!--SEC END -->
<!--TOC section id=sec5 Введение-->
<h2 id="sec5" class="section">2.1  Введение</h2><!--SEC END --><p>Первый язык функционального программирования LISP появился в конце 1950, в тот
же момент, что и Fortran — один из первых императивных языков. Оба этих языка
существуют и по сей день, хотя они немало изменились. Область их применения:
вычислительные задачи для Фортрана и символьные (symbolic) для Lisp. Интерес к
функциональному программированию состоит в простоте написания программ, где под
программой подразумевается функция, применённая к аргументам. Она вычисляет
результат, который возвращается как вывод программы. Таким образом можно с
лёгкостью комбинировать программы: вывод одной, становится входным аргументом
для другой.</p><p>Функциональное программирование основывается на простой модели вычислений,
состоящей из трёх конструкций: переменные, определение функции и её применение к
какому–либо аргументу. Эта модель, называемая λ–исчисление, была
введена Alonzo Church в 1932, ещё до появления первых компьютеров. В
λ–исчислении любая функция является переменной, так что она может быть
использована как входной параметр другой функции, или возвращена как результат
другой. Теория λ–исчисления утверждает что все то, что вычисляемо может
быть представлено этим формализмом. Однако, синтаксис этой теории слишком
ограничен, чтобы его можно было использовать его как язык программирования. В
связи с этим к λ–исчислению были добавлены базовые типы (например,
целые числа или строки символов), операторы для этих типов, управляющие
структуры и объявление позволяющие именовать переменные или функции, и в
частности рекурсивные функции.</p><p>Существует разные классификации языков функционального программирования. Мы
будем различать их по двум характеристикам, которые нам кажутся наиболее
важными:</p><ul class="itemize"><li class="li-itemize">
	без побочных эффектов (чистые), или с побочным эффектом
(не чистые): чистый язык — это тот, в котором не существует изменения
состояния. Все есть вычисление, и как оно происходит, нас не интересует. Не
чистые языки, такие как Caml или ML, имеют императивные особенности, такие как
изменение состояния. Они позволяют писать программы в стиле близкому к Фортрану,
в котором важен порядок вычисления выражений.<p>	</p></li><li class="li-itemize">язык типизирован динамически или статически: типизация необходима для
проверки соответствия аргумента, переданного функции, типу формального
параметра. Это проверка может быть выполнена во время выполнения программы. В
этом случае типизация называется динамической. В случае ошибки программа будет
остановлена, как это происходит в Lisp. В случае статической типизации проверка
осуществляется во время компиляции, то есть до выполнения программы. Таким
образом она (проверка) не замедлит программу во время выполнения. Эта типизация
используется в ML и в его диалектах, таких как Objective CAML. Только правильно
типизированные программы, то есть успешно прошедшие проверку типов, могут быть
скомпилированы и затем выполнены.
</li></ul>
<!--TOC section id=sec6 План главы-->
<h2 id="sec6" class="section">2.2  План главы</h2><!--SEC END --><p>В этой главе представлены базовые элементы функциональной части языка Objective
CAML, а именно: синтаксис, типы и механизм исключений. После этого вводного
курса мы сможем написать нашу первую программу.</p><p>В первом разделе описаны основы языка, начиная с базовых типов и функций. Затем
мы рассмотрим структурные и функциональные типы. После этого мы рассмотрим
управляющие структуры, а также локальные и глобальные объявления. Во втором
разделе мы обсудим определение типов для создания структур и механизм
сопоставления с образцом, который используется для доступа к этим структурам. В
третьем разделе рассматривается выводимый тип функций и область их применения,
после чего следует описание механизма исключений. Четвёртый раздел объединяет
введённые понятия в простой пример программы–калькулятора.

</p>
<!--TOC section id=sec7 Функциональное ядро Objective CAML-->
<h2 id="sec7" class="section">2.3  Функциональное ядро Objective CAML</h2><!--SEC END --><p>
<a id="sec:caml_kernel"></a></p><p>Как любой другой язык функционального программирования, Objective CAML — это
язык выражений, состоящий в основном из создания функций и их применения.
Результатом вычисления одного из таких выражений является значение данного языка
(value in the language) и выполнение программы заключается в вычислении всех
выражений из которых она состоит.</p>
<!--TOC subsection id=sec8 Значения, функции и базовые типы-->
<h3 id="sec8" class="subsection">2.3.1  Значения, функции и базовые типы</h3><!--SEC END --><p>
<a id="sec:values_funcs_base_types"></a></p><p>В Objective CAML определены следующие типы: целые числа, числа с плавающей
запятой, символьный, строковый и логический.</p>
<!--TOC subsubsection id=sec9 Числа-->
<h4 id="sec9" class="subsubsection">Числа</h4><!--SEC END --><p>Различают целые <span style="font-family:monospace">int</span> и числа с плавающей запятой <span style="font-family:monospace">float</span>.
Objective CAML следует спецификации IEEE 754 для представления чисел с плавающей
запятой двойной точности. Операции с этими числами описаны в таблице
<a href="#tbl%3Aoperations_on_numbers">2.1</a>. Если результат целочисленной операции выходит
за интервал значений типа <span style="font-family:monospace">int</span>, то это не приведёт к ошибке. Результат
будет находиться в интервале целых чисел, то есть все действия над целыми
ограниченны операцией <span style="font-family:monospace">modulo</span> с границами интервала.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.1: Операции над числами</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	целые</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >плавающие </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	+ сложение</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >+. сложение </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	- вычитание и унарный минус</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >-. вычитание и унарный минус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	* умножение</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >*. умножение </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	/ деление</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >/. деление </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">mod</span> остаток целочисленного деления</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >** возведение в степень </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># 1 ;;
- : <span style="color:black">int</span> = 1
# 1 + 2 ;;
- : <span style="color:black">int</span> = 3
# 9 / 2 ;;
- : <span style="color:black">int</span> = 4
# 11 <span style="color:black">mod</span> 3 ;;
- : <span style="color:black">int</span> = 2
<span style="color:black">(* limits of the representation  *)</span>
<span style="color:black">(* of integers                   *)</span>
# 2147483650 ;;
- : <span style="color:black">int</span> = 2</td></tr>
</table></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># 2.0 ;;
- : <span style="color:black">float</span> = 2
# 1.1 +. 2.2 ;;
- : <span style="color:black">float</span> = 3.3
# 9.1 /. 2.2 ;;
- : <span style="color:black">float</span> = 4.13636363636
# 1. /. 0. ;;
- : <span style="color:black">float</span> = <span style="color:black">inf</span>
<span style="color:black">(* limits of the representation  *)</span>
<span style="color:black">(* of floating-point numbers     *)</span>
# 222222222222.11111 ;;
- : <span style="color:black">float</span> = 222222222222</td></tr>
</table>
</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<a id="tbl:operations_on_numbers"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec10 Разница между целыми числами и числами с плавающей запятой.-->
<h4 id="sec10" class="subsubsection">Разница между целыми числами и числами с плавающей запятой.</h4><!--SEC END --><p>Значения разных типов, таких как <span style="font-family:monospace">float</span> и <span style="font-family:monospace">int</span>, не могут
сравниваться между собой напрямую. Для этого существует функции перевода одного
типа в другой (<span style="font-family:monospace">float_of_int</span> и <span style="font-family:monospace">int_of_float</span>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 2 = 2.0;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">float</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# 3.0 = <span style="color:black">float_of_int</span> 3;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span></td></tr>
</table><p>Аналогично, операции над целыми числами и числами с плавающей запятой различны:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 3 + 2;;
- : <span style="color:black">int</span> = 5
# 3.0 +. 2.0;;
- : <span style="color:black">float</span> = 5.
# 3.0 + 2.0;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">float</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# <span style="color:black">sin</span> 3.14159;;
- : <span style="color:black">float</span> = 2.65358979335273<span style="color:black">e</span>-06</td></tr>
</table><p>Неопределенный результат, например получаемый при делении на ноль, приведет к
возникновению исключения (см. <a href="#%3F%3F">??</a>, стр. <a href="#%3F%3F">??</a>), которое остановит
вычисление. Числа с плавающей запятой имеют специальные значения для бесконечных
величин (<span style="font-family:monospace">Inf</span>) и для не определённого результата (<span style="font-family:monospace">NaN</span>
<sup><a id="text1" href="#note1">1</a></sup>). Основные операции над этими числами приведены в
таблице <a href="#tbl%3Afunctions_on_floats">2.2</a></p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.2: Функции над числами с плавающей запятой</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">ceil</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">cos</span> косинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">floor</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">sin</span> синус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">sqrt</span> — квадратный корень</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">tan</span> тангенс </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">exp</span> — экспонента</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">acos</span> арккосинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">log</span> — натуральный логарифм</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">asin</span> арксинус </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	<span style="font-family:monospace">log10</span> — логарифм по базе 10</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">atan</span> арктангенс </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># <span style="color:black">ceil</span> 3.4 ;;
- : <span style="color:black">float</span> = 4.
# <span style="color:black">floor</span> 3.4 ;;
- : <span style="color:black">float</span> = 3.
# <span style="color:black">ceil</span> (-.3.4) ;;
- : <span style="color:black">float</span> = -3.
# <span style="color:black">floor</span> (-.3.4) ;;
- : <span style="color:black">float</span> = -4.</td></tr>
</table></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >
<table class="lstframe" style="padding:1ex;border-style:none;"><tr><td class="lstlisting"># <span style="color:black">sin</span> 1.57078 ;;
- : <span style="color:black">float</span> = 0.999999999866717837
# <span style="color:black">sin</span> (<span style="color:black">asin</span> 0.707) ;;
- : <span style="color:black">float</span> = 0.707
# <span style="color:black">acos</span> 0.0 ;;
- : <span style="color:black">float</span> = 1.57079632679489656
# <span style="color:black">asin</span> 3.14 ;;
- : <span style="color:black">float</span> = <span style="color:black">nan</span></td></tr>
</table>
</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
	<a id="tbl:functions_on_floats"></a>
</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec11 Символы и строки-->
<h4 id="sec11" class="subsubsection">Символы и строки</h4><!--SEC END --><p>Символы, тип <span style="font-family:monospace">char</span>, соответствуют целым числам в интервале от 0 до 255,
первые 128 значений соответствуют кодам ASCII. Функция <span style="font-family:monospace">char_of_int</span> и
<span style="font-family:monospace">int_of_char</span> преобразуют один тип в другой. Строки, тип
<span style="font-family:monospace">string</span> — это последовательность символов определенной длинны (не
длиннее 224<sup>24</sup> − 6). Оператором объединения строк (конкатенации) является
шапка ∧. Следующие функции необходимы для перевода типов
<span style="font-family:monospace">int_of_string</span>, <span style="font-family:monospace">string_of_int</span>, <span style="font-family:monospace">string_of_float</span> и
<span style="font-family:monospace">float_of_string</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># '<span style="color:black">B</span>' ;;
- : <span style="color:black">char</span> = '<span style="color:black">B</span>'
# <span style="color:black">int_of_char</span> '<span style="color:black">B</span>' ;;
- : <span style="color:black">int</span> = 66
# <span style="color:black">"est une chaîne"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"est une cha\195\174ne"</span>
# (<span style="color:black">string_of_int</span> 1987) ^ <span style="color:black">" est l'année de la création de CAML"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"1987 est l'ann\195\169e de la cr\195\169ation de CAML"</span></td></tr>
</table><p>Если строка состоит из цифр, то мы не сможем использовать ее в численных
операциях, не выполнив явного преобразования.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">"1999"</span> + 1 ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span>
# (<span style="color:black">int_of_string</span> <span style="color:black">"1999"</span>) + 1 ;;
- : <span style="color:black">int</span> = 2000</td></tr>
</table><p>В модуле <span style="font-family:monospace">String</span> собрано много функций для работы со строками (стр.
<a href="#%3F%3F">??</a>)</p>
<!--TOC subsubsection id=sec12 Булевый тип-->
<h4 id="sec12" class="subsubsection">Булевый тип</h4><!--SEC END --><p>Значение типа <span style="font-family:monospace">boolean</span> принадлежит множеству состоящему из двух
элементов: <span style="font-family:monospace">true</span> и <span style="font-family:monospace">false</span>. Основные операторы описаны в таблице
<a href="#tbl%3Aboolean_operations">2.3.1</a>. По историческим причинам операторы <span style="font-family:monospace">and</span> и
<span style="font-family:monospace">or</span> имеют две формы.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.3: Булевы операторы</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	not — отрицание</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&nbsp;</td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	&amp;&amp; логическое и</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&amp; синоним &amp;&amp; </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	|| логическое или</td><td style="vertical-align:top;text-align:left;border:solid 1px;" ><span style="font-family:monospace">or</span> синоним | </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
</div>
	<a id="tbl:boolean_operations"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">true</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">not</span> <span style="color:black">true</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span>
# <span style="color:black">true</span> &amp;&amp; <span style="color:black">false</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">false</span></td></tr>
</table><p>Операторы &amp;&amp; и || или их синонимы, вычисляют аргумент слева и в зависимости от
его значения, вычисляют правый аргумент. Они могут быть переписаны в виде
условной структуры (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
<div class="center">
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 2.4: Операторы сравнения и равенства</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	= равенство структурное</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&lt; меньше </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	== равенство физическое</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&gt; больше </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	&lt;&gt; отрицание =</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&lt;= меньше или равно </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	!= отрицание ==</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >&gt;= больше или равно </td></tr>
<tr><td style="vertical-align:top;text-align:left;border:solid 1px;" >	</td></tr>
</table>
</div>
	<a id="tbl:comparison_operations"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Операторы сравнения и равенства описаны в таблице
<a href="#tbl%3Acomparison_operations">2.3.1</a>. Это полиморфные операторы, то есть они
применимы как для сравнения двух целых, так и двух строк. Единственное
ограничение это то что операнды должны быть одного типа (см. <a href="#">??</a> стр.
<a href="#">??</a>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 1&lt;=118 &amp;&amp; (1=2 || <span style="color:black">not</span>(1=2)) ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# 1.0 &lt;= 118.0 &amp;&amp; (1.0 = 2.0 || <span style="color:black">not</span> (1.0 = 2.0)) ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# <span style="color:black">"one"</span> &lt; <span style="color:black">"two"</span> ;;
- : <span style="color:black">bool</span> = <span style="color:black">true</span>
# 0 &lt; '0' ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">char</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table><p>Структурное равенство при проверке двух переменных сравнивает значение полей
структуры, тогда как физическое равенство проверяет занимают ли эти переменные
одно и то же место в памяти. Оба оператора возвращают одинаковый результат для
простых типов: <span style="font-family:monospace">boolean</span>, <span style="font-family:monospace">char</span>, <span style="font-family:monospace">int</span> и константные
конструкторы (см. <a href="#%3F%3F">??</a> стр. <a href="#%3F%3F">??</a>).</p>
<!--TOC subsubsection id=sec13 Осторожно-->
<h4 id="sec13" class="subsubsection">Осторожно</h4><!--SEC END --><p>Числа с плавающей запятой и строки рассматриваются как структурные типы.</p>
<!--TOC subsubsection id=sec14 Объединения-->
<h4 id="sec14" class="subsubsection">Объединения</h4><!--SEC END --><p>Тип <span style="font-family:monospace">unit</span> определяет множество из всего одного элемента, обозначается:
()</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># () ;;
- : <span style="color:black">unit</span> = ()</td></tr>
</table><p>Это значение будет широко использоваться в императивных программах (см. <a href="#">??</a>
стр. <a href="#">??</a>), в функциях с побочным эффектом. Функции, результат которых
равен (), соответствуют понятию процедуры, которое отсутствует в Objective CAML,
так же как и аналог типа <span style="font-family:monospace">void</span> в языке C.</p>
<!--TOC subsubsection id=sec15 Декартово произведение, кортежи-->
<h4 id="sec15" class="subsubsection">Декартово произведение, кортежи</h4><!--SEC END --><p>Значения разных типов могут быть сгруппированы в кортежи. Значения из которых
состоит кортеж разделяются запятой. Для конструкции кортежа, используется символ
<span style="font-family:monospace">*</span>. <span style="font-family:monospace">int*string</span> есть кортеж, в котором первый элемент целое
число и второй строка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">int</span> * <span style="color:black">string</span> = (12, <span style="color:black">"October"</span>)</td></tr>
</table><p>Иногда мы можем использовать более простую форму записи.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 12 , <span style="color:black">"October"</span> ;;
- : <span style="color:black">int</span> * <span style="color:black">string</span> = (12, <span style="color:black">"October"</span>)</td></tr>
</table><p>Функции <span style="font-family:monospace">fst</span> и <span style="font-family:monospace">snd</span> дают доступ первому и второму элементу
соответственно.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">fst</span> ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">int</span> = 12
# <span style="color:black">snd</span> ( 12 , <span style="color:black">"October"</span> ) ;;
- : <span style="color:black">string</span> = <span style="color:black">"October"</span></td></tr>
</table><p>Эти обе функции полиморфные, входной аргумент может быть любого типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">fst</span>;;
- : '<span style="color:black">a</span> * '<span style="color:black">b</span> -&gt; '<span style="color:black">a</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">fst</span> ( <span style="color:black">"October"</span>, 12 ) ;;
- : <span style="color:black">string</span> = <span style="color:black">"October"</span></td></tr>
</table><p>Тип <span style="font-family:monospace">int*char*string</span> — это триплет, в котором первый элемент типа
<span style="font-family:monospace">int</span>, второй <span style="font-family:monospace">char</span>, а третий — <span style="font-family:monospace">string</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># ( 65 , '<span style="color:black">B</span>' , <span style="color:black">"ascii"</span> ) ;;
- : <span style="color:black">int</span> * <span style="color:black">char</span> * <span style="color:black">string</span> = (65, '<span style="color:black">B</span>', <span style="color:black">"ascii"</span>)</td></tr>
</table>
<!--TOC subsubsection id=sec16 Осторожно-->
<h4 id="sec16" class="subsubsection">Осторожно</h4><!--SEC END --><p>Если аргумент функций <span style="font-family:monospace">fst</span> и <span style="font-family:monospace">snd</span> не пара, а другой n–кортеж,
то мы получим ошибку.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">snd</span> ( 65 , '<span style="color:black">B</span>' , <span style="color:black">"ascii"</span> ) ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">int</span> * <span style="color:black">char</span> * <span style="color:black">string</span>
       <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span> '<span style="color:black">a</span> * '<span style="color:black">b</span></td></tr>
</table><p>Существует разница между парой и триплетом: тип <span style="font-family:monospace">int*int*int</span> отличен от
<span style="font-family:monospace">(int*int)*int</span> и <span style="font-family:monospace">int*(int*int)</span>. Методы доступа к элементам
триплета (и других кортежей) не определены в стандартной библиотеке. В случае
необходимости мы используем сопоставление с образцом (см. <a href="#">??</a>).</p>
<!--TOC subsubsection id=sec17 Списки-->
<h4 id="sec17" class="subsubsection">Списки</h4><!--SEC END --><p>Значения одного и того же типа могут быть объединены в списки. Список может быть
либо пустым, либо содержать однотипные элементы.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># [] ;;
- : '<span style="color:black">a</span> <span style="color:black">list</span> = []
# [ 1 ; 2 ; 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]
# [ 1 ; <span style="color:black">"two"</span> ; 3 ] ;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table><p>Для того чтобы добавить элемент в начало списка существует следующая функция в
виде инфиксного оператора :: — аналог <span style="font-family:monospace">cons</span> в Caml.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># 1 :: 2 :: 3 :: [] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]</td></tr>
</table><p>Для объединения (конкатенации) списков существует инфиксный оператор: @.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># [ 1 ]  <span style="color:black">@</span>  [ 2 ; 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]
# [ 1 ; 2 ]  <span style="color:black">@</span>  [ 3 ] ;;
- : <span style="color:black">int</span> <span style="color:black">list</span> = [1; 2; 3]</td></tr>
</table><p>Остальные функции манипуляции списками определены в библиотеке <span style="font-family:monospace">List</span>.
Функции <span style="font-family:monospace">hd</span> и <span style="font-family:monospace">tl</span> дают доступ к первому и последнему элементу
списка.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">List</span>.<span style="color:black">hd</span> [ 1 ; 2 ; 3 ] ;;
- : <span style="color:black">int</span> = 1
# <span style="color:black">List</span>.<span style="color:black">hd</span> [] ;;
<span style="color:black">Exception</span>: <span style="color:black">Failure</span> <span style="color:black">"hd"</span>.</td></tr>
</table><p>В последнем примере получить первый элемент пустого списка действительно
сложно, поэтому возбуждается исключение (см. <a href="#">??</a>).</p>
<!--TOC subsection id=sec18 Структуры условного контроля-->
<h3 id="sec18" class="subsection">2.3.2  Структуры условного контроля</h3><!--SEC END --><p>Одна из структур контроля необходимая в каждом языка программирования —
условный оператор.</p><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">if</span> <span style="color:black">expr1</span> <span style="color:black">then</span> <span style="color:black">expr2</span> <span style="color:black">else</span> <span style="color:black">expr3</span></td></tr>
</table><p>Тип выражения <span style="font-family:monospace">expr1</span> равен <span style="font-family:monospace">bool</span>. Выражения <span style="font-family:monospace">expr2</span> и
<span style="font-family:monospace">expr3</span> должны быть одного и того же типа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">if</span> 3=4 <span style="color:black">then</span> 0 <span style="color:black">else</span> 4 ;;
- : <span style="color:black">int</span> = 4
# <span style="color:black">if</span> 3=4 <span style="color:black">then</span> <span style="color:black">"0"</span> <span style="color:black">else</span> <span style="color:black">"4"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"4"</span>
# <span style="color:black">if</span> 3=4 <span style="color:black">then</span> 0 <span style="color:black">else</span>  <span style="color:black">"4"</span>;;
<span style="color:black">Error</span>: <span style="color:black">This</span> <span style="color:black">expression</span> <span style="color:black">has</span> <span style="color:black">type</span> <span style="color:black">string</span> <span style="color:black">but</span> <span style="color:black">an</span> <span style="color:black">expression</span> <span style="color:black">was</span> <span style="color:black">expected</span> <span style="color:black">of</span> <span style="color:black">type</span>
         <span style="color:black">int</span></td></tr>
</table>
<!--TOC subsubsection id=sec19 Замечание-->
<h4 id="sec19" class="subsubsection">Замечание</h4><!--SEC END --><p>
Ветка <span style="font-family:monospace">else</span> может быть опущена, в этом случае будет подставлено значение
по умолчанию равное <span style="font-family:monospace">else ()</span>, в соответствии с этим выражение
<span style="font-family:monospace">expr2</span> должно быть типа <span style="font-family:monospace">unit</span> (см. <a href="#">??</a> стр. <a href="#">??</a>).</p>
<!--TOC subsection id=sec20 Объявление значений-->
<h3 id="sec20" class="subsection">2.3.3  Объявление значений</h3><!--SEC END --><p>Определение связывает имя со значением. Различают глобальные и локальные
определения. В первом случае, объявленные имена видны во всех выражениях,
следуют за ним, во втором — имена доступны только в текущем выражении. Мы
также можем одновременно объявить несколько пар имя-значение.</p>
<!--TOC subsubsection id=sec21 Глобальные объявления-->
<h4 id="sec21" class="subsubsection">Глобальные объявления</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">name</span> = <span style="color:black">expr</span> ;;</td></tr>
</table><p>Глобальное объявление определяет связь имени <span style="font-family:monospace">nom</span> со значением выражения
<span style="font-family:monospace">expr</span>, которое будет доступно всем следующим выражениям.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">yr</span> = <span style="color:black">"1999"</span> ;;
<span style="color:black">val</span> <span style="color:black">yr</span> : <span style="color:black">string</span> = <span style="color:black">"1999"</span>
# <span style="color:black">let</span> <span style="color:black">x</span> = <span style="color:black">int_of_string</span>(<span style="color:black">yr</span>) ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 1999
# <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 1999
# <span style="color:black">x</span> + 1 ;;
- : <span style="color:black">int</span> = 2000
# <span style="color:black">let</span> <span style="color:black">new_yr</span> = <span style="color:black">string_of_int</span> (<span style="color:black">x</span> + 1) ;;
<span style="color:black">val</span> <span style="color:black">new_yr</span> : <span style="color:black">string</span> = <span style="color:black">"2000"</span></td></tr>
</table>
<!--TOC subsubsection id=sec22 Одновременное глобальное объявление-->
<h4 id="sec22" class="subsubsection">Одновременное глобальное объявление</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom1</span> = <span style="color:black">expr1</span>
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">nom2</span> = <span style="color:black">expr2</span>
:
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">nomn</span> = <span style="color:black">exprn</span>;;</td></tr>
</table><p>При одновременном объявлении переменные будут известны только к концу всех
объявлений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 1 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">y</span> = 2 ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 1
<span style="color:black">val</span> <span style="color:black">y</span> : <span style="color:black">int</span> = 2
# <span style="color:black">x</span> + <span style="color:black">y</span> ;;
- : <span style="color:black">int</span> = 3
# <span style="color:black">let</span> <span style="color:black">z</span> = 3 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">t</span> = <span style="color:black">z</span> + 2 ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">z</span></td></tr>
</table><p>Можно сгруппировать несколько глобальных объявлений в одной фразе, вывод типов и
значений произойдёт к концу фразы, отмеченной ;;. В данном случае
объявления будут вычислены по порядку.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 2
  <span style="color:black">let</span> <span style="color:black">y</span> = <span style="color:black">x</span> + 3  ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 2
<span style="color:black">val</span> <span style="color:black">y</span> : <span style="color:black">int</span> = 5</td></tr>
</table><p>Глобальное объявление может быть скрыто локальным с тем же именем (см. <a href="#%3F%3F">??</a>
стр. <a href="#%3F%3F">??</a>).</p>
<!--TOC subsubsection id=sec23 Локальное объявление-->
<h4 id="sec23" class="subsubsection">Локальное объявление</h4><!--SEC END --><p>Синтаксис:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span> <span style="color:black">nom</span> = <span style="color:black">expr1</span> <span style="color:black">in</span> <span style="color:black">expr2</span>;;</td></tr>
</table><p>Имя <span style="font-family:monospace">nom</span> связанное с выражением <span style="font-family:monospace">expr1</span> известно только для
вычисления <span style="font-family:monospace">expr2</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">xl</span> = 3 <span style="color:black">in</span> <span style="color:black">xl</span> * <span style="color:black">xl</span> ;;
- : <span style="color:black">int</span> = 9</td></tr>
</table><p>Локальное объявление, которое связывает <span style="font-family:monospace">xl</span> со значением <span style="font-family:monospace">3</span>,
существует только в ходе вычисления <span style="font-family:monospace">xl*xl</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">xl</span> ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">xl</span></td></tr>
</table><p>Локальное объявление скрывает любое глобальные с тем же именем, но как только мы
выходим из блока в котором была оно определено, мы находим старое значение
связанное с этим именем.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">x</span> = 2 ;;
<span style="color:black">val</span> <span style="color:black">x</span> : <span style="color:black">int</span> = 2
# <span style="color:black">let</span> <span style="color:black">x</span> = 3 <span style="color:black">in</span> <span style="color:black">x</span> * <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 9
# <span style="color:black">x</span> * <span style="color:black">x</span> ;;
- : <span style="color:black">int</span> = 4</td></tr>
</table><p>Локальное объявление — это обычное выражение, соответственно оно может быть
использовано для построения других выражений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># (<span style="color:black">let</span> <span style="color:black">x</span> = 3 <span style="color:black">in</span> <span style="color:black">x</span> * <span style="color:black">x</span>) + 1 ;;
- : <span style="color:black">int</span> = 10</td></tr>
</table><p>Локальные объявления так же могут быть одновременными.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">let</span>   <span style="color:black">name1</span> = <span style="color:black">expr1</span>
<span style="color:blue"><span style="font-weight:bold">and</span></span>   <span style="color:black">name2</span> = <span style="color:black">expr2</span>
:
<span style="color:blue"><span style="font-weight:bold">and</span></span>   <span style="color:black">namen</span> = <span style="color:black">exprn</span>
<span style="color:black">in</span>  <span style="color:black">expr</span> ;;</td></tr>
</table><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">a</span> = 3.0 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">b</span> = 4.0 <span style="color:black">in</span> <span style="color:black">sqrt</span> (<span style="color:black">a</span>*.<span style="color:black">a</span> +. <span style="color:black">b</span>*.<span style="color:black">b</span>) ;;
- : <span style="color:black">float</span> = 5.
# <span style="color:black">b</span> ;;
<span style="color:black">Error</span>: <span style="color:black">Unbound</span> <span style="color:black">value</span> <span style="color:black">b</span></td></tr>
</table>
<!--TOC subsection id=sec24 Функциональное выражение, функции-->
<h3 id="sec24" class="subsection">2.3.4  Функциональное выражение, функции</h3><!--SEC END -->
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note1" href="#text1">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Not a Number</div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec25 Императивное программирование-->
<h1 id="sec25" class="chapter">Глава 3  Императивное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec26 Функциональный и императивный стиль-->
<h1 id="sec26" class="chapter">Глава 4  Функциональный и императивный стиль</h1><!--SEC END -->
<!--TOC chapter id=sec27 Графический интерфейс-->
<h1 id="sec27" class="chapter">Глава 5  Графический интерфейс</h1><!--SEC END -->
<!--TOC chapter id=sec28 Приложения-->
<h1 id="sec28" class="chapter">Глава 6  Приложения</h1><!--SEC END -->
<!--TOC part id=sec29 Средства разработки-->
<table class="center"><tr><td><h1 id="sec29" class="part">Часть II<br>
Средства разработки</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec30 Компиляция и переносимость-->
<h1 id="sec30" class="chapter">Глава 7  Компиляция и переносимость</h1><!--SEC END -->
<!--TOC chapter id=sec31 Библиотеки-->
<h1 id="sec31" class="chapter">Глава 8  Библиотеки</h1><!--SEC END -->
<!--TOC chapter id=sec32 Автоматический сборщик мусора-->
<h1 id="sec32" class="chapter">Глава 9  Автоматический сборщик мусора</h1><!--SEC END -->
<!--TOC chapter id=sec33 Средства анализа программ-->
<h1 id="sec33" class="chapter">Глава 10  Средства анализа программ</h1><!--SEC END -->
<!--TOC chapter id=sec34 Средства лексического и синтаксического анализа-->
<h1 id="sec34" class="chapter">Глава 11  Средства лексического и синтаксического анализа</h1><!--SEC END -->
<!--TOC section id=sec35 Введение-->
<h2 id="sec35" class="section">11.1  Введение</h2><!--SEC END --><p>Определение и реализация средств лексического и синтаксического анализа являлись
важным доменом исследования в информатике. Эта работа привела к созданию
генераторов лексического и синтаксического анализа <span style="font-family:monospace">lex</span> и
<span style="font-family:monospace">yacc</span>. Команды <span style="font-family:monospace">camllex camlyacc</span>, которые мы представим в этой
главе, являются их достойными наследниками. Два указанных инструмента стали
de–facto стандартными, однако существуют другие средства, как например потоки
или регулярные выражения из библиотеки <span style="font-family:monospace">Str</span>, которые могут быть
достаточны для простых случаев, там где не нужен мощный анализ.</p><p>Необходимость подобных инструментов особенно чувствовалась в таких доменах как
компиляция языков программирования. Однако и другие программы могут с успехом
использовать данные средства: базы данных, позволяющие определять запросы или
электронная таблица, где содержимое ячейки можно определить как результат
какой–нибудь формулы. Проще говоря, любая программа, в которой взаимодействие с
пользователем осуществляется при помощи языка, использует лексический и
синтаксический анализ.</p><p>Возьмём простой случай. Текстовый формат часто используется для хранения данных,
будь то конфигурационный системный файл или данные табличного файла. Здесь, для
использования данных, необходим лексический и синтаксический анализ.</p><p>Обобщая, скажем что лексический и синтаксический анализ преобразует линейный
поток символов в данные с более богатой структурой: последовательность слов,
структура записи, абстрактное синтаксическое дерево программы и т.д.</p><p>У каждого языка есть словарный состав (лексика) и грамматика, которая описывает
каким образом эти составные объединяются (синтаксис). Для того, чтобы машина или
программа могли корректно обрабатывать язык, этот язык должен иметь точные
лексические и синтаксические правила. У машины нет тонкого чувства для
того чтобы правильно оценить двусмысленность натуральных языков. По этой
причине к машине необходимо обращаться в соответствии с чёткими правилами, в
которых нет исключений. В соответствии с этим, понятия лексики и семантики
получили формальные определения, которые будут кратко представлены в данной
главе.
</p>
<!--TOC section id=sec36 План главы-->
<h2 id="sec36" class="section">11.2  План главы</h2><!--SEC END --><p>Данная глава знакомит нас со средствами лексического и синтаксического анализа,
которые входят в дистрибутив Objective CAML. Обычно синтаксический анализ
следует за лексическим. В первой части мы узнаем о простом инструменте
лексического анализа из модуля <span style="font-family:monospace">Genlex</span>. После этого ознакомимся с
формализмом рациональных выражений и тем самым рассмотрим более детально
определение множества лексических единиц. А так же проиллюстрируем их реализацию
в модуле <span style="font-family:monospace">Str</span> и инструменте <span style="font-family:monospace">ocamllex</span>. Во второй части мы
определим грамматику и рассмотрим правила создания фраз языка. После этого
рассмотрим два анализа фраз: восходящий и нисходящий. Они будут
проиллюстрированы использованием <span style="font-family:monospace">Stream</span> и <span style="font-family:monospace">ocamlyacc</span>. В
приведённых примерах используется контекстно–независимая грамматика. Здесь мы
узнаем как реализовать контекстный анализ при помощи Stream. В третьей части мы
вернёмся к интерпретатору BASIC (см. стр <a href="#%3F%3F">??</a>) и при помощи
<span style="font-family:monospace">ocamllex</span> и <span style="font-family:monospace">ocamlyacc</span> добавим лексические и синтаксические
функции анализа языка.

</p>
<!--TOC section id=sec37 Лексика-->
<h2 id="sec37" class="section">11.3  Лексика</h2><!--SEC END --><p>Синтаксический анализ это предварительный и необходимый этап обработки
последовательностей символов: он разделяет этот поток в последовательность слов,
так называемых лексические единицы или лексемы.</p>
<!--TOC subsection id=sec38 Модуль <span style="font-family:monospace">Genlex</span>-->
<h3 id="sec38" class="subsection">11.3.1  Модуль <span style="font-family:monospace">Genlex</span></h3><!--SEC END --><p>В данном модуле имеется элементарное средство для анализа символьного потока.
Для этого используются несколько категорий предопределённых лексических единиц.
Эти категории различаются по типу:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">type</span> <span style="color:black">token</span> = <span style="color:black">Kwd</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Ident</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Int</span> <span style="color:black">of</span> <span style="color:black">int</span>
    | <span style="color:black">Float</span> <span style="color:black">of</span> <span style="color:black">float</span>
    | <span style="color:black">String</span> <span style="color:black">of</span> <span style="color:black">string</span>
    | <span style="color:black">Char</span> <span style="color:black">of</span> <span style="color:black">char</span> ;;</td></tr>
</table><p>Таким образом мы можем распознать в потоке символов целое число (конструктор
<span style="font-family:monospace">Int</span>) и получить его значение (аргумент конструктора <span style="font-family:monospace">int</span>).
Распознаваемые символы и строки подчиняются следующим общепринятым соглашением:
строка окружена символами ("), а символ окружён (’). Десятичное число
представлено либо используя запись с точкой (например 0.01), либо с мантиссой и
экспонентой (на пример 1E-2). Кроме этого остались конструкторы <span style="font-family:monospace">Kwd</span> и
<span style="font-family:monospace">Ident</span>.</p><p>Конструктор <span style="font-family:monospace">Ident</span> предназначен для определения идентификаторов.
Идентификатором может быть имя переменной или функции языка программирования.
Они состоят из любой последовательности букв и цифр, могут включать
символ подчёркивания (_) или апостроф (’). Данная последовательность не должна
начинаться с цифры. Любая последовательность следующих операндов тоже будет
считаться идентификатором: +,*,&gt; или -. И наконец, конструктор <span style="font-family:monospace">Kwd</span>
определяет
категорию специальных идентификаторов или символов.</p><p>Категория ключевых слова — единственная из этого множества, которую можно
сконфигурировать. Для того, чтобы создать лексический анализатор, воспользуемся
следующей конструкцией, которой необходимо передать список ключевых слов на
место первого аргумента.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> ;;
- : <span style="color:black">string</span> <span style="color:black">list</span> -&gt; <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Тем самым получаем функцию, которая принимает на вход поток символов и
возвращает поток лексических единиц (с типом <span style="font-family:monospace">token</span>).</p><p>Таким образом, мы без труда реализуем лексический анализатор для интерпретатора
BASIC. Объявим множество ключевых слов:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">keywords</span> =
    [ <span style="color:black">"REM"</span>; <span style="color:black">"GOTO"</span>; <span style="color:black">"LET"</span>; <span style="color:black">"PRINT"</span>; <span style="color:black">"INPUT"</span>; <span style="color:black">"IF"</span>; <span style="color:black">"THEN"</span>; <span style="color:black">"-"</span>;
    <span style="color:black">"!"</span>; <span style="color:black">"+"</span>; <span style="color:black">"-"</span>; <span style="color:black">"*"</span>; <span style="color:black">"/"</span>; <span style="color:black">"%"</span>;
    <span style="color:black">"="</span>; <span style="color:black">"&lt;"</span>; <span style="color:black">"&gt;"</span>; <span style="color:black">"&lt;="</span>; <span style="color:black">"&gt;="</span>; <span style="color:black">"&lt;&gt;"</span>;
    <span style="color:black">"&amp;"</span>; <span style="color:black">"|"</span> ] ;;</td></tr>
</table><p>При помощи данного множества, определим функцию лексического анализа:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">line_lexer</span> <span style="color:black">l</span> = <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> <span style="color:black">keywords</span> (<span style="color:black">Stream</span>.<span style="color:black">of_string</span> <span style="color:black">l</span>) ;;
<span style="color:black">val</span> <span style="color:black">line_lexer</span> : <span style="color:black">string</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">line_lexer</span> <span style="color:black">"LET x = x + y * 3"</span> ;;
- : <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">abstr</span>&gt;</td></tr>
</table><p>Приведённая функция <span style="font-family:monospace">line_lexer</span>, из входящего потока символов создаёт
поток соответствующих лексем.</p>
<!--TOC subsection id=sec39 Использование потоков-->
<h3 id="sec39" class="subsection">11.3.2  Использование потоков</h3><!--SEC END --><p>Мы также можем реализовать лексический анализ в ручную используя потоки.</p><p>В следующем примере определён лексический анализатор арифметических выражений.
Функции lexer передаётся поток символов из которого она создаёт поток
лексических единиц с типом <span style="font-family:monospace">lexeme Stream.t</span> <sup><a id="text2" href="#note2">1</a></sup>. Символы пробел, табуляция и
переход на новую строку удаляются. Для упрощения, мы не будем обрабатывать
переменные и отрицательны целые числа.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">spaces</span> <span style="color:black">s</span> =
    <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
      [&lt;'' ' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;''\<span style="color:black">t</span>' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;''\<span style="color:black">n</span>' ; <span style="color:black">rest</span> &gt;] -&gt; <span style="color:black">spaces</span> <span style="color:black">rest</span>
      | [&lt;&gt;] -&gt; ();;
<span style="color:black">val</span> <span style="color:black">spaces</span> : <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">unit</span> = &lt;<span style="color:black">fun</span>&gt;
# <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">lexer</span> <span style="color:black">s</span> =
   <span style="color:black">spaces</span> <span style="color:black">s</span>;
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt; ''(' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"("</span>; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; '')' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">")"</span>; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''+' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"+"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''-' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"-"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''*' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"*"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''/' &gt;] -&gt; [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"/"</span> ; <span style="color:black">lexer</span> <span style="color:black">s</span> &gt;]
     | [&lt; ''0'..'9' <span style="color:black">as</span> <span style="color:black">c</span>;
       <span style="color:black">i</span>,<span style="color:black">v</span> = <span style="color:black">lexint</span> (<span style="color:black">Char</span>.<span style="color:black">code</span> <span style="color:black">c</span> - <span style="color:black">Char</span>.<span style="color:black">code</span>('0')) &gt;]
       -&gt;[&lt;'<span style="color:black">Lint</span> <span style="color:black">i</span> ; <span style="color:black">lexer</span> <span style="color:black">v</span>&gt;]
   <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">lexint</span> <span style="color:black">r</span> <span style="color:black">s</span> =
     <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
       [&lt; ''0'..'9' <span style="color:black">as</span> <span style="color:black">c</span> &gt;]
       -&gt; <span style="color:black">let</span> <span style="color:black">u</span> = (<span style="color:black">Char</span>.<span style="color:black">code</span> <span style="color:black">c</span>) - (<span style="color:black">Char</span>.<span style="color:black">code</span> '0') <span style="color:black">in</span> <span style="color:black">lexint</span> (10*<span style="color:black">r</span> + <span style="color:black">u</span>) <span style="color:black">s</span>
       | [&lt;&gt;] -&gt; <span style="color:black">r</span>,<span style="color:black">s</span> ;;
<span style="color:black">val</span> <span style="color:black">lexer</span> : <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">lexint</span> : <span style="color:black">int</span> -&gt; <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">int</span> * <span style="color:black">char</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Функция <span style="font-family:monospace">lexint</span> предназначена для анализа той части потока символов,
которая соответствует числовой постоянной. Она вызывается, когда функция
<span style="font-family:monospace">lexer</span> встречает цифры. В этом случае функция <span style="font-family:monospace">lexint</span> поглощает
все последовательные цифры и выдаёт соответствующее значение полученного числа.</p>
<!--TOC subsection id=sec40 Регулярные выражения-->
<h3 id="sec40" class="subsection">11.3.3  Регулярные выражения</h3><!--SEC END --><p>Оставим ненадолго практику и рассмотрим проблему лексических единиц с
теоретической точки зрения.</p><p>Лексическая единица является словом. Слово образуется при конкатенации элементов
алфавита. В нашем случае алфавитом является множество символов ASCII.</p><p>Теоретически, слово может вообще не содержать символов (пустое слово
<sup><a id="text3" href="#note3">2</a></sup>) или состоять из одного символа.</p><p>Теоретические исследования конкатенации элементов алфавита для образования
лексических элементов (лексем) привели к созданию простого формализма,
известного как регулярные выражения.</p>
<!--TOC subsubsection id=sec41 Определение-->
<h4 id="sec41" class="subsubsection">Определение</h4><!--SEC END --><p>Регулярные выражения позволяют определить множества слов. Пример такого
множества: идентификаторы. Принцип определения основан на некоторых
теоретико–множественный операциях. Пусть <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span> — два множества слов, тогда
мы можем определить:</p><ul class="itemize"><li class="li-itemize">
	объединение <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span>, записываемое <span style="font-style:italic">M</span> | <span style="font-style:italic">N</span>.<p>	</p></li><li class="li-itemize">дополнение <span style="font-style:italic">M</span>, записываемое ∧ <span style="font-style:italic">M</span>: множество всех слов, кроме
тех, которые входят в <span style="font-style:italic">M</span>.<p>	</p></li><li class="li-itemize">конкатенация <span style="font-style:italic">M</span> и <span style="font-style:italic">N</span>: множество всех слов созданных конкатенацией
слова из <span style="font-style:italic">M</span> и слова из <span style="font-style:italic">N</span>. Записывается просто <span style="font-style:italic">MN</span>.<p>	</p></li><li class="li-itemize">мы можем повторить операцию конкатенации слов множества <span style="font-style:italic">M</span> и тем
самым получить множество слов образованных из конечной последовательности слов
множеств <span style="font-style:italic">M</span>. Такое множество записывается <span style="font-style:italic">M</span>+. Он содержит все слова множества
<span style="font-style:italic">M</span>, все слова полученные конкатенацией двух слов множества <span style="font-style:italic">M</span>, трёх слов, и
т.д. Если мы желаем чтобы данное множество содержало пустое слово, необходимо
писать <span style="font-style:italic">M</span>*.<p>	</p></li><li class="li-itemize">для удобства, существует дополнительная конструкция <span style="font-style:italic">M</span>?, которая
включает все слова множества <span style="font-style:italic">M</span>, а так же пустое слово.
</li></ul><p>Один единственный символ ассоциируется с одно элементным множеством. В таком
случае выражение <span style="font-style:italic">a| b| c</span> описывает множество состоящее из трёх слов
<span style="font-style:italic">a</span>, <span style="font-style:italic">b</span> и <span style="font-style:italic">c</span>. Существует более компактная запись: <span style="font-style:italic">[abc]</span>.
Так как наш алфавит является упорядоченным (по порядку кодов ASCII), можно
определить интервал. Например, множество цифр запишется как [0−9]. Для
группировки выражений можно использовать скобки.</p><p>Для того, чтобы использовать в записи сами символы–операторы, как обычные
символы, необходимо ставить перед ними обратную косую черту: \.
Например множество (\ *)* обозначает множество последовательностей
звёздочек.</p>
<!--TOC subsubsection id=sec42 Пример-->
<h4 id="sec42" class="subsubsection">Пример</h4><!--SEC END --><p>Пусть существует множество из цифр (0,1,2,3,4,5,6,7,8,9), символы плюс (+) и
минус (−), точки (.) и буквы <span style="font-style:italic">E</span>. Теперь мы можем определить множество чисел
<span style="font-style:italic">num</span>. Назовем <span style="font-style:italic">integers</span> множество определённое выражением [0−9]+.
Множество неотрицательных чисел <span style="font-style:italic">unum</span> определяется так:
</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell">	<span style="font-style:italic">integers</span> ? (.<span style="font-style:italic">integers</span>) ? (<span style="font-style:italic">E</span>(\+|−) ? <span style="font-style:italic">integers</span>)?
</td></tr>
</table><p>Множество отрицательных и положительных чисел записывается:</p><table class="display dcenter"><tr style="vertical-align:middle"><td class="dcell"><span style="font-style:italic">unum</span> | −<span style="font-style:italic">unum</span>    или    −?<span style="font-style:italic">unum</span>
</td></tr>
</table>
<!--TOC subsubsection id=sec43 Распознавание-->
<h4 id="sec43" class="subsubsection">Распознавание</h4><!--SEC END --><p>Теперь, после того как множество выражений определено, остаётся проблема
распознавания принадлежности строки символов или одной из её подстрок этому
множеству. Для решения данной задачи необходимо реализовать программу обработки
выражений, которая соответствует формальным определениям множества. Для
регулярных выражений такая обработка может быть автоматизирована. Подобная
автоматизация реализована в модуле <span style="font-family:monospace">Genlex</span> из библиотеки <span style="font-family:monospace">Str</span> и
инструментом <span style="font-family:monospace">ocamllex</span>, которые будут представлены в следующих двух
параграфах.</p>
<!--TOC subsubsection id=sec44 Библиотека <span style="font-family:monospace">Str</span>-->
<h4 id="sec44" class="subsubsection">Библиотека <span style="font-family:monospace">Str</span></h4><!--SEC END --><p>В данном модуле имеется абстрактный тип <span style="font-family:monospace">regexp</span> и функция
<span style="font-family:monospace">regexp</span>. Указанный тип представляет регулярные выражения, а функция
трансформирует регулярное выражение, представленное в виде строки символов, в
абстрактное представление.</p><p>Модуль <span style="font-family:monospace">Str</span> содержит несколько функций, которые используют регулярные
выражения и манипулируют символьными строками. Синтаксис регулярных выражений
библиотеки <span style="font-family:monospace">Str</span> приведён в таблице <a href="#tbl%3Areg_exps">11.1</a>.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 11.1: Регулярные выражения</td></tr>
</table></div>
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	.</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >любой символ, кроме \ </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	*</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >ноль или несколько экземпляров предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	+</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >хотя бы один экземпляр предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	?</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >ноль или один экземпляр предыдущего выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	[..]</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >множество символов </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	.</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >любой символ, кроме \ </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >интервал записывается при помощи - (пример [0−9]) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >дополнение записывается при помощи ∧ (пример [∧ <span style="font-style:italic">A</span>−<span style="font-style:italic">Z</span>]) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	∧</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >начало строки (не путать с дополнением ∧) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	$</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >конец строки </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	|</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >вариант </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	(..)</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >группировка в одно выражение (можно ссылаться на это выражение) </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	<span style="font-style:italic">i</span></td><td style="vertical-align:top;text-align:left;border:solid 1px;" >числовая константа <span style="font-style:italic">i</span> ссылается на <span style="font-style:italic">i</span>–ый элемент группированного
выражения </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	\</td><td style="vertical-align:top;text-align:left;border:solid 1px;" >забой, используется для сопоставления зарезервированных
символов в регулярных выражениях </td></tr>
<tr><td style="vertical-align:top;text-align:center;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	<a id="tbl:reg_exps"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec45 Пример-->
<h4 id="sec45" class="subsubsection">Пример</h4><!--SEC END --><p>В следующем примере напишем функцию, которая переводит дату из английского
формата во французский. Предполагается, что входной файл состоит из строк,
разбитых на поля данных и элементы даты разделяются точкой. Определим функцию,
которая из полученной строки (строка файла), выделяет дату, разбивает её на
части, переводит во французских формат и тем самым заменяет старую дату на
новую.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">french_date_of</span> <span style="color:black">d</span> =
  <span style="color:black">match</span> <span style="color:black">d</span> <span style="color:black">with</span>
   [<span style="color:black">mm</span>; <span style="color:black">dd</span>; <span style="color:black">yy</span>] -&gt; <span style="color:black">dd</span>^<span style="color:black">"/"</span>^<span style="color:black">mm</span>^<span style="color:black">"/"</span>^<span style="color:black">yy</span>
   | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"Bad date format"</span> ;;
<span style="color:black">val</span> <span style="color:black">french_date_of</span> : <span style="color:black">string</span> <span style="color:black">list</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">english_date_format</span> = <span style="color:black">Str</span>.<span style="color:black">regexp</span> <span style="color:black">"[0-9]+\.[0-9]+\.[0-9]+"</span> ;;
<span style="color:black">val</span> <span style="color:black">english_date_format</span> : <span style="color:black">Str</span>.<span style="color:black">regexp</span> = &lt;<span style="color:black">abstr</span>&gt;

# <span style="color:black">let</span> <span style="color:black">trans_date</span> <span style="color:black">l</span> =
  <span style="color:black">try</span>
  <span style="color:black">let</span> <span style="color:black">i</span>=<span style="color:black">Str</span>.<span style="color:black">search_forward</span> <span style="color:black">english_date_format</span> <span style="color:black">l</span> 0 <span style="color:black">in</span>
  <span style="color:black">let</span> <span style="color:black">d1</span> = <span style="color:black">Str</span>.<span style="color:black">matched_string</span> <span style="color:black">l</span> <span style="color:black">in</span>
  <span style="color:black">let</span> <span style="color:black">d2</span> = <span style="color:black">french_date_of</span> (<span style="color:black">Str</span>.<span style="color:black">split</span> (<span style="color:black">Str</span>.<span style="color:black">regexp</span> <span style="color:black">"\."</span>) <span style="color:black">d1</span>) <span style="color:black">in</span>
    <span style="color:black">Str</span>.<span style="color:black">global_replace</span> <span style="color:black">english_date_format</span> <span style="color:black">d2</span> <span style="color:black">l</span>
  <span style="color:black">with</span> <span style="color:black">Not_found</span> -&gt; <span style="color:black">l</span> ;;
  <span style="color:black">val</span> <span style="color:black">trans_date</span> : <span style="color:black">string</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">trans_date</span>
<span style="color:black">"..............06.13.99............"</span> ;;
- : <span style="color:black">string</span> = <span style="color:black">"..............13/06/99............"</span></td></tr>
</table>
<!--TOC subsection id=sec46 Инструмент <span style="font-family:monospace">Ocamllex</span>-->
<h3 id="sec46" class="subsection">11.3.4  Инструмент <span style="font-family:monospace">Ocamllex</span></h3><!--SEC END --><p><span style="font-family:monospace">ocamllex</span> — это лексический генератор созданный для Objective CAML по
модели <span style="font-family:monospace">lex</span>, написанном на языке C. При помощи файла, описывающего
элементы лексики в виде множества регулярных выражений, которые необходимо
распознать, он создаёт файл–исходник на Objective CAML. К описанию каждого
лексического элемента можно привязать какое–нибудь действие, называемое
семантическое действие. В полученном коде используется абстрактный тип
<span style="font-family:monospace">lexbuf</span> из модуля <span style="font-family:monospace">Lexing</span>. В данном модуле также имеется
несколько функций управления лексическими буферами, которые могут быть
использованы программистом для того чтобы определить необходимые действия.</p><p>Обычно, файлы, описывающие лексику, имеют расширение <span style="font-family:monospace">.mll</span>. Для того,
чтобы из файла <span style="font-family:monospace">lex_file.mll</span> получить файл на Objective CAML,
необходимо выполнить следующую команду:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">ocamllex</span> <span style="color:black">lex_file</span>.<span style="color:black">mll</span></td></tr>
</table><p>После этого, мы получим файл <span style="font-family:monospace">lex_file.ml</span>, содержащий код лексического
анализатора. Теперь, данный файл можно использовать в программе на Objective
CAML. Каждому множеству правил анализа соответствует функция, которая принимает
лексический буфер (типа <span style="font-family:monospace">Lexing.lexbuf</span>) и затем возвращает значение,
определённое семантическим действием. Значит, все действия для определённого
правила должны создавать значение одного и того же типа.</p><p>Формат у файла для <span style="font-family:monospace">ocamllex</span> следующий:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">{
  <span style="color:black">header</span>
}
<span style="color:black">let</span> <span style="color:black">ident</span> = <span style="color:black">regexp</span>
        ...
<span style="color:black">rule</span> <span style="color:black">ruleset1</span> = <span style="color:black">parse</span>
                <span style="color:black">regexp</span> { <span style="color:black">action</span> }
                | ...
                | <span style="color:black">regexp</span> { <span style="color:black">action</span> }
<span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">ruleset2</span> = <span style="color:black">parse</span>
        ...
<span style="color:blue"><span style="font-weight:bold">and</span></span> ...
{
  <span style="color:black">trailer</span>-<span style="color:blue"><span style="font-weight:bold">and</span></span>-<span style="color:black">end</span>
}</td></tr>
</table><p>Части заголовок и продолжение-и-конец не являются обязательными.
Здесь вставляется код Objective CAML, определяющий типы данных, функции и т.д.
необходимые для обработки данных. В последней части используются функции,
которые используют правила анализа множества лексических данных из средней
части. Серия объявлений, которая предшествует определению правил, позволяет дать
имя некоторым регулярным выражениям. Эти имена будут использоваться в
определении правил.</p>
<!--TOC subsubsection id=sec47 Пример-->
<h4 id="sec47" class="subsubsection">Пример</h4><!--SEC END --><p>Вернёмся к нашему интерпретатору BASIC и усовершенствуем тип возвращаемых
лексических единиц. Таким образом, мы можем воспользоваться функцией
<span style="font-family:monospace">lexer</span>, (см. стр. <a href="#%3F%3F">??</a>) которая возвращает такой же тип результата
(<span style="font-family:monospace">lexeme</span>), но на входе она получает буфер типа <span style="font-family:monospace">Lexing.lexbuf</span>.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">  {
    <span style="color:black">let</span> <span style="color:black">string_chars</span> <span style="color:black">s</span> =
    <span style="color:black">String</span>.<span style="color:black">sub</span> <span style="color:black">s</span> 1 ((<span style="color:black">String</span>.<span style="color:black">length</span> <span style="color:black">s</span>)-2) ;;
  }

<span style="color:black">let</span> <span style="color:black">op_ar</span> = ['-' '+' '*' '\%' '/']
<span style="color:black">let</span> <span style="color:black">op_bool</span> = ['!' '\&amp;' '|']
<span style="color:black">let</span> <span style="color:black">rel</span> = ['=' '&lt;' '&gt;']

<span style="color:black">rule</span> <span style="color:black">lexer</span> = <span style="color:black">parse</span>
    [' ']   { <span style="color:black">lexer</span> <span style="color:black">lexbuf</span> }
  | <span style="color:black">op_ar</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">op_bool</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&lt;="</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&gt;="</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"&lt;&gt;"</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">rel</span>     { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"REM"</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"LET"</span>   { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"PRINT"</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"INPUT"</span> { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"IF"</span>    { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | <span style="color:black">"THEN"</span>  { <span style="color:black">Lsymbol</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | '-'? ['0'-'9']+   { <span style="color:black">Lint</span> (<span style="color:black">int_of_string</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>)) }
  | ['<span style="color:black">A</span>'-'<span style="color:black">z</span>']+        { <span style="color:black">Lident</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
  | '<span style="color:black">"' [^ '"</span>']* '<span style="color:black">"'  { Lstring (string_chars (Lexing.lexeme lexbuf)) }</span></td></tr>
</table><p>После обработки данного файла командой <span style="font-family:monospace">ocamllex</span> получим функцию
<span style="font-family:monospace">lexer</span> типа <span style="font-family:monospace">Lexing.lexbuf -&gt; lexeme</span>. Далее, мы рассмотрим каким
образом подобные функции используются в синтаксическом анализе (см. стр.
<a href="#%3F%3F">??</a>).

</p>
<!--TOC section id=sec48 Синтаксис-->
<h2 id="sec48" class="section">11.4  Синтаксис</h2><!--SEC END --><p>Благодаря лексическому анализу, мы в состоянии разбить поток символов на более
структурированные элементы: лексические элементы. Теперь необходимо знать как
правильно объединять эти элементы в синтаксически корректные фразы какого-нибудь
языка. Правила синтаксической группировки определены посредством грамматических
правил. Формализм, произошедший из лингвистики, был с успехом перенят
математиками, занимающимися теориями языков, и специалистами по информатике. На
странице <a href="#%3F%3F">??</a> мы уже видели пример грамматики для языка BASIC. Здесь мы
снова вернёмся к этому примеру, чтобы более углублённо ознакомится с базовыми
концепциями грамматики.</p>
<!--TOC subsection id=sec49 Грамматика-->
<h3 id="sec49" class="subsection">11.4.1  Грамматика</h3><!--SEC END --><p>Говоря формальным языком, грамматика основывается на четырёх элементах:</p><ol class="enumerate" type=1><li class="li-enumerate">
	Множество символов, называемых терминалами. Эти символы являются
лексическими элементами языка. В Бэйсике к ним относятся символы операторов,
арифметических отношений и логические (+, &amp;, &lt;, ≤, ⋯), ключевые
слова языка <span style="font-weight:bold">(GOTO, PRINT, IF, THEN, </span>⋯<span style="font-weight:bold">)</span>, целые числа (элемент
<span style="font-family:monospace">integer</span>) и переменные (элемент <span style="font-family:monospace">variable</span>).<p>	</p></li><li class="li-enumerate">Множество нетерминальных символов, которые представляют
синтаксические компоненты языка. Например, программа на языке Бэйсик состоит из
строк. Таким образом мы имеем компоненту Line, которая в свою очередь
состоит из выражений (Expression), и т.д.<p>	</p></li><li class="li-enumerate">Множество так называемых порождающих правил. Они описывают каким
образом комбинируются терминальные и нетерминальные символы, чтобы создать
синтаксическую компоненту. Строка в Бэйсике начинается с номера, за которой
следует инструкция. Смысл правила следующий:<div class="center">
	Line ::= <span style="font-style:italic">integer</span> Instruction
</div><p>Одна и та же компонента может быть порождена несколькими способами. В этом
случае варианты разделяются символом | как в:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Instruction</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >LET variable = Instruction </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >GOTO integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >PRINT Expression </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		etc</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td><td style="text-align:left;white-space:nowrap" >	</td></tr>
</table>
</div></li></ol><p>Среди всех нетерминальных символов различают один, называемый начальным.
Правило, которое порождает эту аксиому является порождающим правилом всего
языка.</p>
<!--TOC subsection id=sec50 Порождение и распознавание-->
<h3 id="sec50" class="subsection">11.4.2  Порождение и распознавание</h3><!--SEC END --><p>
<a id="page_ref:Production_and_Recognition"></a></p><p>С помощью порождающих правил можно определить принадлежит ли последовательность
лексем языку.</p><p>Рассмотрим простой язык, описывающий арифметические выражения:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp + Exp</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp * Exp</td><td style="text-align:center;white-space:nowrap" >(R3) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >( Exp )</td><td style="text-align:center;white-space:nowrap" >(R4)
	</td></tr>
</table>
</div><p>здесь <span style="font-style:italic">(R1) (R2) (R3) (R4)</span> — имена правил. По окончании лексического
анализа выражение 1*(2+3) становится последовательностью следующих лексем:</p><div class="center">
<span style="font-style:italic">integer * (integer + integer)</span>
</div><p>Для того, чтобы проанализировать эту фразу и убедиться в том что она принадлежит
языку арифметических выражений, воспользуемся правилами справа налево: если
часть выражения соответствует правому члену какого-нибудь правила, мы заменяем
это выражение соответствующим левым членом. Этот процесс продолжается до тех
пор, пока выражение не будет редуцировано до аксиомы. Ниже представлен результат
такого анализа <sup><a id="text4" href="#note4">3</a></sup>:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		integer * (integer + integer)</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (integer + integer) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp + integer) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R1)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp + Exp) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R2)</td><td style="text-align:left;white-space:nowrap" >Exp * (Exp) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R4)</td><td style="text-align:left;white-space:nowrap" >Exp * Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >(R3)</td><td style="text-align:left;white-space:nowrap" >Exp
	</td></tr>
</table>
</div><p>Начиная с последней линии, которая содержит лишь Exp и следуя стрелкам, можно
определить каким образом было полученное выражение исходя из аксиомы Exp.
Соответственно данная фраза является правильно сформированной фразой языка
арифметических выражений, определённого грамматикой.</p><p>Преобразование грамматики в программу, способную распознать принадлежность
последовательности лексем языку, который определён грамматикой, является более
сложной проблемой, чем проблема использования регулярных выражений.
Действительно, в соответствии с математическим результатом любое множество
(слов), определённое формализмом регулярных выражений, может быть определено
другим формализмом: детерминированные конечные автоматы. Такие автоматы легко
реализуются программами, принимающими поток символов. Подобный результат для
грамматик в общем не существует. Однако, имеются менее строгие (?) (weaker)
результаты устанавливающие эквивалентность между определёнными классами
грамматик и более богатыми автоматами: автомат со стеком. Здесь мы не станем
вдаваться ни в детали этих результатов, ни в точное определение таких автоматов.
Однако, мы можем определить какие классы грамматики могут использоваться в
средствах генерации синтаксических анализаторов или для реализации напрямую
анализатора.</p>
<!--TOC subsection id=sec51 Нисходящий анализ-->
<h3 id="sec51" class="subsection">11.4.3  Нисходящий анализ</h3><!--SEC END --><p>Разбор выражения 1 * (2 + 3) в предыдущем параграфе не является единственным:
мы с таким же успехом могли бы начать редуцирование <span style="font-style:italic">integer</span>, то есть
воспользоваться правилом <span style="font-style:italic">(R2)</span> редуцирования 2 + 3. Эти два способа
распознавания являются двумя типами анализа: восходящий анализ (справа налево) и
нисходящий слева направо. Последний анализ легко реализуется при помощи потоков
лексем модуля <span style="font-family:monospace">Stream</span>. Средство <span style="font-family:monospace">ocamlyacc</span> использует восходящий
анализ, при котором применяется стек, как это уже было проиллюстрировано
синтаксическим анализатором программ на Бэйсике. Выбор анализа не просто дело
вкуса, в зависимости от используемой для спецификации языка формы грамматики,
можно или нет применять нисходящий анализ.</p>
<!--TOC subsubsection id=sec52 Простой случай-->
<h4 id="sec52" class="subsubsection">Простой случай</h4><!--SEC END --><p>Каноническим примером нисходящего анализа является префиксная запись
арифметических выражений, определяемая как:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >+ Exp Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >* Exp Exp </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>В данном случае достаточно знать первую лексему, для того чтобы определить какое
правило может быть использовано. При помощи подобной предсказуемости нет
необходимости явно управлять стеком, достаточно положиться на рекурсивный вызов
анализатора. И тогда при помощи <span style="font-family:monospace">Genlex</span> и <span style="font-family:monospace">Stream</span> очень просто
написать программу реализующую нисходящий анализ. Функция <span style="font-family:monospace">infix_of</span> из
полученного префиксного выражения возвращает его инфиксный эквивалент:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">lexer</span> <span style="color:black">s</span> =
   <span style="color:black">let</span> <span style="color:black">ll</span> = <span style="color:black">Genlex</span>.<span style="color:black">make_lexer</span> [<span style="color:black">"+"</span>;<span style="color:black">"*"</span>]
   <span style="color:black">in</span> <span style="color:black">ll</span> (<span style="color:black">Stream</span>.<span style="color:black">of_string</span> <span style="color:black">s</span>);;
<span style="color:black">val</span> <span style="color:black">lexer</span> : <span style="color:black">string</span> -&gt; <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">stream_parse</span> <span style="color:black">s</span> =
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Ident</span> <span style="color:black">x</span>&gt;] -&gt; <span style="color:black">x</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Int</span> <span style="color:black">n</span>&gt;] -&gt; <span style="color:black">string_of_int</span> <span style="color:black">n</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Kwd</span> <span style="color:black">"+"</span>; <span style="color:black">e1</span>=<span style="color:black">stream_parse</span>; <span style="color:black">e2</span>=<span style="color:black">stream_parse</span>&gt;] -&gt; <span style="color:black">"("</span>^<span style="color:black">e1</span>^<span style="color:black">"+"</span>^<span style="color:black">e2</span>^<span style="color:black">")"</span>
   | [&lt;'<span style="color:black">Genlex</span>.<span style="color:black">Kwd</span> <span style="color:black">"*"</span>; <span style="color:black">e1</span>=<span style="color:black">stream_parse</span>; <span style="color:black">e2</span>=<span style="color:black">stream_parse</span>&gt;] -&gt; <span style="color:black">"("</span>^<span style="color:black">e1</span>^<span style="color:black">"*"</span>^<span style="color:black">e2</span>^<span style="color:black">")"</span>
   | [&lt;&gt;] -&gt; <span style="color:black">failwith</span> <span style="color:black">"Parse error"</span> ;;
<span style="color:black">val</span> <span style="color:black">stream_parse</span> : <span style="color:black">Genlex</span>.<span style="color:black">token</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">let</span> <span style="color:black">infix_of</span> <span style="color:black">s</span> = <span style="color:black">stream_parse</span> (<span style="color:black">lexer</span> <span style="color:black">s</span>) ;;
<span style="color:black">val</span> <span style="color:black">infix_of</span> : <span style="color:black">string</span> -&gt; <span style="color:black">string</span> = &lt;<span style="color:black">fun</span>&gt;

# <span style="color:black">infix_of</span> <span style="color:black">"* +3 11 22"</span>;;
- : <span style="color:black">string</span> = <span style="color:black">"((3+11)*22)"</span></td></tr>
</table><p>Однако не стоит забывать о некоторой примитивности лексического анализа.
Советуем периодически добавлять пробелы между различными лексическими
элементами.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">infix_of</span> <span style="color:black">"*+3 11 22"</span>;;
- : <span style="color:black">string</span> = <span style="color:black">"*+"</span></td></tr>
</table>
<!--TOC subsubsection id=sec53 Случай посложней-->
<h4 id="sec53" class="subsubsection">Случай посложней</h4><!--SEC END --><p>Синтаксический анализ при помощи потоков предсказуем, он облагает грамматику
двумя условиями:</p><ul class="itemize"><li class="li-itemize">
	В правилах грамматики не должно быть левой рекурсии. Правило
называется рекурсивным слева, если его правый член начинается с нетерминального
символа, который является левой частью правила. Например: <span style="font-family:monospace">Exp ::= Exp +
Exp</span><p>	</p></li><li class="li-itemize">Не должно существовать правил начинающихся одним и тем же выражением.
</li></ul><p>Грамматика арифметических выражений, приведённая на стр.
<a href="#page_ref%3AProduction_and_Recognition">??</a>, не подходит для нисходящего
анализа: они не удовлетворяют ни одному из условий. Для того, чтобы применить
нисходящий анализ необходимо переформулировать грамматику таким образом, чтобы
удалить левую рекурсию и неопределённость правил. Вот полученный результат:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >Atom NextExpr </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		NextExpr</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >+ Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >- Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >* Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >/ Atom </td></tr>
<tr><td style="text-align:right;white-space:nowrap" > 		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >ε </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		 Atom</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >integer </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >( Expr )
	</td></tr>
</table>
</div><p>Заметьте использование пустого слова ε в определении
<span style="font-family:monospace">NextExpr</span>. Оно необходимо, если мы хотим чтобы просто целое число
являлось выражением.</p><p>Следующий анализатор есть просто перевод вышеуказанной грамматики в код. Он
реализует абстрактное синтаксическое дерево арифметических выражений.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"># <span style="color:black">let</span> <span style="color:black">rec</span> <span style="color:black">rest</span> = <span style="color:black">parser</span>
    [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"+"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">PLUS</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"-"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">MINUS</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"*"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">MULT</span>,<span style="color:black">e2</span>)
  | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"/"</span>; <span style="color:black">e2</span> = <span style="color:black">atom</span> &gt;] -&gt; <span style="color:black">Some</span> (<span style="color:black">DIV</span>,<span style="color:black">e2</span>)
  | [&lt; &gt;] -&gt; <span style="color:black">None</span>
 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">atom</span> = <span style="color:black">parser</span>
     [&lt; '<span style="color:black">Lint</span> <span style="color:black">i</span> &gt;] -&gt; <span style="color:black">ExpInt</span> <span style="color:black">i</span>
   | [&lt; '<span style="color:black">Lsymbol</span> <span style="color:black">"("</span>; <span style="color:black">e</span> = <span style="color:black">expr</span> ; '<span style="color:black">Lsymbol</span> <span style="color:black">")"</span> &gt;] -&gt; <span style="color:black">e</span>
 <span style="color:blue"><span style="font-weight:bold">and</span></span> <span style="color:black">expr</span> <span style="color:black">s</span> =
   <span style="color:black">match</span> <span style="color:black">s</span> <span style="color:black">with</span> <span style="color:black">parser</span>
     [&lt; <span style="color:black">e1</span> = <span style="color:black">atom</span> &gt;] -&gt;
       <span style="color:black">match</span> <span style="color:black">rest</span> <span style="color:black">s</span> <span style="color:black">with</span>
          <span style="color:black">None</span> -&gt; <span style="color:black">e1</span>
        | <span style="color:black">Some</span> (<span style="color:black">op</span>,<span style="color:black">e2</span>) -&gt; <span style="color:black">ExpBin</span>(<span style="color:black">e1</span>,<span style="color:black">op</span>,<span style="color:black">e2</span>) ;;
<span style="color:black">val</span> <span style="color:black">rest</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; (<span style="color:black">bin_op</span> * <span style="color:black">expression</span>) <span style="color:black">option</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">atom</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">expression</span> = &lt;<span style="color:black">fun</span>&gt;
<span style="color:black">val</span> <span style="color:black">expr</span> : <span style="color:black">lexeme</span> <span style="color:black">Stream</span>.<span style="color:black">t</span> -&gt; <span style="color:black">expression</span> = &lt;<span style="color:black">fun</span>&gt;</td></tr>
</table><p>Сложность использования нисходящего анализа заключается в том, что грамматика
должна быть очень ограниченной формы. Если язык выражен естественно с
использованием левой рекурсии (как в инфиксных выражениях), то не всегда легко
определить эквивалентную грамматику, то есть определяющую такой же язык, которая
бы удовлетворяла требованиям нисходящего анализа. По этой причине, средства
<span style="font-family:monospace">yacc</span> и <span style="font-family:monospace">ocamlyacc</span> реализуют восходящий анализ, который
разрешает определение более естественных грамматик. Однако, мы увидим, что даже
в этом случае существуют ограничения.</p>
<!--TOC subsection id=sec54 Восходящий анализ-->
<h3 id="sec54" class="subsection">11.4.4  Восходящий анализ</h3><!--SEC END --><p>Мы уже вкратце представили на странице <a href="#%3F%3F">??</a> принципы восходящего
анализа: сдвиг и вывод <sup><a id="text5" href="#note5">4</a></sup>.
После каждого подобного действия, состояние стека изменяется. Из этой
последовательности можно вывести правила грамматики, в случае если грамматика
это позволяет, как в примере с нисходящим анализом. Опять же, сложности
возникают из-за неопределённости правил, когда невозможно выбрать между
продвинутся или сократить. Проиллюстрируем действие восходящего анализа и его
недостатки на все тех же арифметических выражениях в постфиксном и инфиксном
написании.</p>
<!--TOC subsubsection id=sec55 Положительная сторона-->
<h4 id="sec55" class="subsubsection">Положительная сторона</h4><!--SEC END --><p>Упрощённая постфиксная грамматика арифметических выражений выглядит так:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Exp</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp Exp +</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >Exp Exp -</td><td style="text-align:center;white-space:nowrap" >(R3) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Данная грамматика является двойственной по отношению к префиксной: для того
чтобы точно знать какое правило следует применить, необходимо дождаться
окончания анализа. В действительности анализ подобных выражений схож с
вычислением при помощи стека. Только вместо проталкивания результата вычисления,
проталкиваются грамматические символы. Если в начале стек пустой, то после того
как ввод закончен, необходимо получить стек содержащий лишь нетерминальную
аксиому. Приведём изменение стека: если мы продвигаемся, то проталкивается
текущий нетерминальный символ; если сокращаем, то первые символы стека
соответствуют правому члену (в обратном порядке) правила и тогда мы заменяем эти
элементы соответствующими нетерминальными элементами.</p><p>В таблице <a href="#tbl%3Abottom-up_parsing">11.2</a> приведён восходящий анализ выражения 1 2
+ 3 * 4 +. Считываемая лексическая единица подчёркивается для более удобного
чтения. Конец потока помечается символом $.</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="caption"><table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="vertical-align:top;text-align:left;" >Тадлица 11.2: Восходящий анализ</td></tr>
</table></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>1</U> 2 + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>2</U> + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[1] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>2</U> + 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[2 Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> 3 * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R2)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>3</U> * 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>*</U> 4 + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R3)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>4</U> + $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R1)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U> $</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Сдвиг, Сократить <span style="font-style:italic">(R2)</span></td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>$</U></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Exp] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
	<a id="tbl:bottom-up_parsing"></a>
<div class="center"><hr style="width:80%;height:2"></div></blockquote>
<!--TOC subsubsection id=sec56 Отрицательная сторона-->
<h4 id="sec56" class="subsubsection">Отрицательная сторона</h4><!--SEC END --><p>Вся трудность перехода от грамматики к программе распознающей язык заключается в
определении действия, которое необходимо применить. Проиллюстрируем эту проблему
на трёх примерах, приводящих к трём неопределённостям.</p><p>Первый пример есть грамматика выражений использующих операцию сложения:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(R1) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E0 + E0</td><td style="text-align:center;white-space:nowrap" >(R2) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Неопределённость данной грамматики проявляется при использовании правила <span style="font-style:italic">R2</span>. Предположим следующую ситуацию:</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><U>+</U></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >E0 + E0 … </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>В подобном случае невозможно определить необходимо сдвинуть и протолкнуть в стек
+ или сократить в соответствии с правилом <span style="font-style:italic">(R2)</span> оба E0 и присутствующий в
стеке +. Подобная ситуация называется конфликтом сдвиг-вывод (shift/reduce). Она
является следствием того, что выражение <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> может быть выведено справа двумя способами.</p><p>Первый вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Второй вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E0</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) E0 + E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E0 + <U>E0</U> + <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>Выражения, полученные двумя выводами, могут показаться одинаковыми с точки
зрения вычисления выражения,</p><p>(<span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span>) + <span style="font-style:italic">integer</span> и <span style="font-style:italic">integer</span> + (<span style="font-style:italic">integer</span>
+ <span style="font-style:italic">integer</span>)</p><p>но разными для конструкции синтаксического дерева (см. рис. <a href="#%3F%3F">??</a> на стр.
<a href="#%3F%3F">??</a>)</p><p>Второй пример грамматики, порождающей конфликт между сдвиг-вывод, содержит
такую же неопределённость: явное заключение в скобки. Но в отличии от
предыдущего случая, выбор сдвиг-вывод изменяет смысл выражения. Пусть есть
грамматика:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">integer</span> (<span style="font-style:italic">R1</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E1 + E1 (<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >E1 * E1 (<span style="font-style:italic">R3</span>)
	</td></tr>
</table>
</div><p>Здесь мы снова получаем предыдущий конфликт как в случае с + так и для *, но к
этому добавляется другой, между + и *. Опять же, одно и то же выражение может
быть получено двумя способами, так как у него существует два вывода справа:</p><p><span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> * <span style="font-style:italic">integer</span></p><p>Первый вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R3</span>) E0 * <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) <U>E1</U> * <span style="font-style:italic">integer</span> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + <U>E1</U> * <span style="font-style:italic">integer</span>
	</td></tr>
</table>
</div><p>Второй вариант:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E1</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R2</span>) E1 + E1 * <U>E1</U> </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:left;white-space:nowrap" >(<span style="font-style:italic">R1</span>) E1 + <U>E1</U> * <span style="font-style:italic">integer</span>
	</td></tr>
</table>
</div><p>В данном выражении обе пары скобок имеют разный смысл:</p><p>(<span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span>) * <span style="font-style:italic">integer</span> ≠ <span style="font-style:italic">integer</span> + (<span style="font-style:italic">integer</span> * <span style="font-style:italic">integer</span>)</p><p>Подобную проблему, мы уже встречали в выражениях Basic (см. стр. <a href="#%3F%3F">??</a>).
Она была разрешена при помощи приоритетов, которые присваиваются операторам:
сначала редуцируется правило (R3), затем (R2), что соответствует заключению в
скобки произведения.</p><p>Данную проблему выбора между + и * можно решить изменив грамматику. Для того,
введём два новых терминальных символа: член T (<span style="font-style:italic">term</span>) и множитель F
(<span style="font-style:italic">factor</span>). Отсюда получаем:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		E</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >E + T</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R1</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >T</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		T</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >T + F</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R3</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >|</td><td style="text-align:left;white-space:nowrap" >F</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R4</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		F</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" >T + <span style="font-style:italic">integer</span></td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R5</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>После этого, единственный способ получить <span style="font-style:italic">integer</span> + <span style="font-style:italic">integer</span> *
<span style="font-style:italic">integer</span>: посредством правила (<span style="font-style:italic">R1</span>).</p><p>Третий и последний случай касается условных конструкций языка программирования.
На пример в Pascal существует две конструкции: <span style="font-family:monospace">if .. then</span> и <span style="font-family:monospace">if
.. then .. else</span>. Пусть существует следующая грамматика:</p><div class="center">
	<table style="border-spacing:6px;border-collapse:separate;" class="cellpading0"><tr><td style="text-align:right;white-space:nowrap" >		Instr</td><td style="text-align:center;white-space:nowrap" >::=</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> EXP <span style="font-style:italic">then</span> Instr</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R1</span>)</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >-</td><td style="text-align:left;white-space:nowrap" ><span style="font-style:italic">if</span> EXP <span style="font-style:italic">then</span> Instr <span style="font-style:italic">else</span> Instr</td><td style="text-align:center;white-space:nowrap" >(<span style="font-style:italic">R2</span>) </td></tr>
<tr><td style="text-align:right;white-space:nowrap" >		</td><td style="text-align:center;white-space:nowrap" >-</td><td style="text-align:left;white-space:nowrap" >etc …</td><td style="text-align:center;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:right;white-space:nowrap" >	</td></tr>
</table>
</div><p>И в следующей ситуации:</p><blockquote class="table"><div class="center"><hr style="width:80%;height:2"></div>
	<div class="center">
	<table border=1  style="border-spacing:0;" class="cellpadding1"><tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	Действие</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >Вход</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >Стек </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	:</td><td style="text-align:left;border:solid 1px;white-space:nowrap" >&nbsp;</td><td style="text-align:right;border:solid 1px;white-space:nowrap" >&nbsp;</td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td><td style="text-align:left;border:solid 1px;white-space:nowrap" ><span style="font-style:italic">else</span></td><td style="text-align:right;border:solid 1px;white-space:nowrap" >[Instr <span style="font-style:italic">then</span> Epx <span style="font-style:italic">if</span> …] </td></tr>
<tr><td style="text-align:left;border:solid 1px;white-space:nowrap" >	</td></tr>
</table>
	</div>
<div class="center"><hr style="width:80%;height:2"></div></blockquote><p>Невозможно определить соответствуют ли элементы стека правила (<span style="font-style:italic">R1</span>) и в
этом случае необходимо сократить или соответствуют первому <span style="font-family:monospace">Instr</span>
правила (<span style="font-style:italic">R2</span>) и тогда необходимо сдвинуть.</p><p>Кроме конфликтов сдвиг-вывод, восходящий анализ вызывает конфликт вывод-вывод.</p><p>Мы представим здесь инструмент <span style="font-family:monospace">ocamlyacc</span>, который использует подобную
технику может встретить указанные конфликты.
</p>
<!--TOC section id=sec57 Пересмотренный Basic-->
<h2 id="sec57" class="section">11.5  Пересмотренный Basic</h2><!--SEC END --><p>Теперь, используя совместно <span style="font-family:monospace">ocamllex</span> и <span style="font-family:monospace">ocamlyacc</span>, заменим
функцию <span style="font-family:monospace">parse</span> для Бэйсика, приведённую на странице <a href="#%3F%3F">??</a>, на
функции полученные при помощи файлов спецификации лексики и синтаксиса языка.</p><p>Для этого, мы не сможем воспользоваться типами лексических единиц, в таком виде
как они были определены. Необходимо определить более точные типы, чтобы
различать операторы, команды и ключевые слова.</p><p>Так же, нам понадобится изолировать в отдельном файле <span style="font-family:monospace">basic_types.mli</span>
декларации типов, относящиеся к абстрактному синтаксису. В нем будут содержатся
декларации типа <span style="font-family:monospace">sentences</span>, а так же других типы необходимые этому.</p>
<!--TOC subsection id=sec58 Файл <span style="font-family:monospace">basic_parser.mly</span>-->
<h3 id="sec58" class="subsection">11.5.1  Файл <span style="font-family:monospace">basic_parser.mly</span></h3><!--SEC END -->
<!--TOC subsubsection id=sec59 Заголовок-->
<h4 id="sec59" class="subsubsection">Заголовок</h4><!--SEC END --><p>Данный файл содержит вызовы деклараций типов абстрактного синтаксиса и две
функции перевода строк символов в их эквивалент абстрактного синтаксиса.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%{
<span style="color:black">open</span> <span style="color:black">Basic_types</span> ;;

<span style="color:black">let</span> <span style="color:black">phrase_of_cmd</span> <span style="color:black">c</span> =
 <span style="color:black">match</span> <span style="color:black">c</span> <span style="color:black">with</span>
   <span style="color:black">"RUN"</span> -&gt; <span style="color:black">Run</span>
 | <span style="color:black">"LIST"</span> -&gt; <span style="color:black">List</span>
 | <span style="color:black">"END"</span> -&gt; <span style="color:black">End</span>
 | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"line : unexpected command"</span>
;;

<span style="color:black">let</span> <span style="color:black">bin_op_of_rel</span> <span style="color:black">r</span> =
 <span style="color:black">match</span> <span style="color:black">r</span> <span style="color:black">with</span>
   <span style="color:black">"="</span> -&gt; <span style="color:black">EQUAL</span>
 | <span style="color:black">"&lt;"</span> -&gt; <span style="color:black">INF</span>
 | <span style="color:black">"&lt;="</span> -&gt; <span style="color:black">INFEQ</span>
 | <span style="color:black">"&gt;"</span> -&gt; <span style="color:black">SUP</span>
 | <span style="color:black">"&gt;="</span> -&gt; <span style="color:black">SUPEQ</span>
 | <span style="color:black">"&lt;&gt;"</span> -&gt; <span style="color:black">DIFF</span>
 | <span style="color:black">_</span> -&gt; <span style="color:black">failwith</span> <span style="color:black">"line : unexpected relation symbol"</span>
;;

%}</td></tr>
</table>
<!--TOC subsubsection id=sec60 Декларации-->
<h4 id="sec60" class="subsubsection">Декларации</h4><!--SEC END --><p>Здесь содержится три части: декларация лексем, декларация правил ассоциативности
и приоритетов, декларация стартового символа <span style="font-family:monospace">line</span>, которая
соответствует анализу линии программы или команды.</p><p>Ниже представлены лексические единицы:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">token</span> &lt;<span style="color:black">int</span>&gt; <span style="color:black">Lint</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lident</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lstring</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lcmd</span>
%<span style="color:black">token</span> <span style="color:black">Lplus</span> <span style="color:black">Lminus</span> <span style="color:black">Lmult</span> <span style="color:black">Ldiv</span> <span style="color:black">Lmod</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lrel</span>
%<span style="color:black">token</span> <span style="color:black">Land</span> <span style="color:black">Lor</span> <span style="color:black">Lneg</span>
%<span style="color:black">token</span> <span style="color:black">Lpar</span> <span style="color:black">Rpar</span>
%<span style="color:black">token</span> &lt;<span style="color:black">string</span>&gt; <span style="color:black">Lrem</span>
%<span style="color:black">token</span> <span style="color:black">Lrem</span> <span style="color:black">Llet</span> <span style="color:black">Lprint</span> <span style="color:black">Linput</span> <span style="color:black">Lif</span> <span style="color:black">Lthen</span> <span style="color:black">Lgoto</span>
%<span style="color:black">token</span> <span style="color:black">Lequal</span>
%<span style="color:black">token</span> <span style="color:black">Leol</span></td></tr>
</table><p>Имена деклараций говорят сами за себя и они описаны в файле
<span style="font-family:monospace">basic_lexer.mll</span> (см. стр. <a href="#%3F%3F">??</a>).</p><p>Правила приоритета операторов схожи со значениями, которые определяются
функциями <span style="font-family:monospace">priority_uop</span> и <span style="font-family:monospace">priority_binop</span>, которые были
определены грамматикой Бейсика (см. стр. <a href="#%3F%3F">??</a>).</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">right</span> <span style="color:black">Lneg</span>
%<span style="color:black">left</span> <span style="color:black">Land</span> <span style="color:black">Lor</span>
%<span style="color:black">left</span> <span style="color:black">Lequal</span> <span style="color:black">Lrel</span>
%<span style="color:black">left</span> <span style="color:black">Lmod</span>
%<span style="color:black">left</span> <span style="color:black">Lplus</span> <span style="color:black">Lminus</span>
%<span style="color:black">left</span> <span style="color:black">Lmult</span> <span style="color:black">Ldiv</span>
%<span style="color:black">nonassoc</span> <span style="color:black">Lop</span></td></tr>
</table><p>Символ <span style="font-family:monospace">Lop</span> необходим для обработки унарных минусов. Он не является
терминальным символом, а псевдо–терминальным. Благодаря этому, получаем
перегрузку операторов, когда в двух случаях использования одного и того же
оператора, приоритет меняется в зависимости от контекста. Мы вернёмся к этому
случаю, когда будем рассматривать правила грамматики.</p><p>Здесь нетерминалом является <span style="font-family:monospace">line</span>. Полученная функция возвращает дерево
абстрактного синтаксиса, которое соответствует проанализированной линии.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">%<span style="color:black">start</span> <span style="color:black">line</span>
%<span style="color:black">type</span> &lt;<span style="color:black">Basic_types</span>.<span style="color:black">phrase</span>&gt; <span style="color:black">line</span></td></tr>
</table>
<!--TOC subsubsection id=sec61 Правила грамматики-->
<h4 id="sec61" class="subsubsection">Правила грамматики</h4><!--SEC END --><p>Грамматика делится на 3 нетерминальных элемента: <span style="font-family:monospace">line</span> для линии,
<span style="font-family:monospace">inst</span> для инструкции и <span style="font-family:monospace">exp</span> для выражений. Действия, которые
привязаны к каждому правилу лишь создают соответствующую часть абстрактного
синтаксиса.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"> %%
<span style="color:black">line</span> :
   <span style="color:black">Lint</span> <span style="color:black">inst</span> <span style="color:black">Leol</span>               { <span style="color:black">Line</span> {<span style="color:black">num</span>=<span style="color:black">$1</span>; <span style="color:black">inst</span>=<span style="color:black">$2</span>} }
 | <span style="color:black">Lcmd</span> <span style="color:black">Leol</span>                    { <span style="color:black">phrase_of_cmd</span> <span style="color:black">$1</span> }
 ;

<span style="color:black">inst</span> :
   <span style="color:black">Lrem</span>                         { <span style="color:black">Rem</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lgoto</span> <span style="color:black">Lint</span>                   { <span style="color:black">Goto</span> <span style="color:black">$2</span> }
 | <span style="color:black">Lprint</span> <span style="color:black">exp</span>                   { <span style="color:black">Print</span> <span style="color:black">$2</span> }
 | <span style="color:black">Linput</span> <span style="color:black">Lident</span>                { <span style="color:black">Input</span> <span style="color:black">$2</span> }
 | <span style="color:black">Lif</span> <span style="color:black">exp</span> <span style="color:black">Lthen</span> <span style="color:black">Lint</span>           { <span style="color:black">If</span> (<span style="color:black">$2</span>, <span style="color:black">$4</span>) }
 | <span style="color:black">Llet</span> <span style="color:black">Lident</span> <span style="color:black">Lequal</span> <span style="color:black">exp</span>        { <span style="color:black">Let</span> (<span style="color:black">$2</span>, <span style="color:black">$4</span>) }
 ;

<span style="color:black">exp</span> :
   <span style="color:black">Lint</span>                         { <span style="color:black">ExpInt</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lident</span>                       { <span style="color:black">ExpVar</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lstring</span>                      { <span style="color:black">ExpStr</span> <span style="color:black">$1</span> }
 | <span style="color:black">Lneg</span> <span style="color:black">exp</span>                     { <span style="color:black">ExpUnr</span> (<span style="color:black">NOT</span>, <span style="color:black">$2</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lplus</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">PLUS</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lminus</span> <span style="color:black">exp</span>               { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MINUS</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lmult</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MULT</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Ldiv</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">DIV</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lmod</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">MOD</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lequal</span> <span style="color:black">exp</span>                { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">EQUAL</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lrel</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, (<span style="color:black">bin_op_of_rel</span> <span style="color:black">$2</span>), <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Land</span> <span style="color:black">exp</span>                 { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:blue"><span style="font-weight:bold">AND</span></span>, <span style="color:black">$3</span>) }
 | <span style="color:black">exp</span> <span style="color:black">Lor</span> <span style="color:black">exp</span>                  { <span style="color:black">ExpBin</span> (<span style="color:black">$1</span>, <span style="color:black">OR</span>, <span style="color:black">$3</span>) }
 | <span style="color:black">Lminus</span> <span style="color:black">exp</span> %<span style="color:black">prec</span> <span style="color:black">Lop</span>        { <span style="color:black">ExpUnr</span>(<span style="color:black">OPPOSITE</span>, <span style="color:black">$2</span>) }
 | <span style="color:black">Lpar</span> <span style="color:black">exp</span> <span style="color:black">Rpar</span>                { <span style="color:black">$2</span> }
 ;
 %%</td></tr>
</table><p>Данные правила не нуждаются в особых комментариях, кроме следующего:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">exp</span> :
 ...
 | <span style="color:black">Lminus</span> <span style="color:black">exp</span> %<span style="color:black">prec</span> <span style="color:black">Lop</span> { <span style="color:black">ExpUnr</span>(<span style="color:black">OPPOSITE</span>, <span style="color:black">$2</span>) }</td></tr>
</table><p>Это правило касается использования унарного минуса -. Ключевое слово
<span style="font-family:monospace">%prec</span> означает, что указанная конструкция получает приоритет от
<span style="font-family:monospace">Lop</span> (в данном случае наивысший).</p>
<!--TOC subsection id=sec62 Файл <span style="font-family:monospace">basic_lexer.mll</span>-->
<h3 id="sec62" class="subsection">11.5.2  Файл <span style="font-family:monospace">basic_lexer.mll</span></h3><!--SEC END --><p>Лексический анализ содержит лишь одно множество: <span style="font-family:monospace">lexer</span>, которое точно
соответствует старой функции <span style="font-family:monospace">lexer</span> (см. стр. <a href="#%3F%3F">??</a>).</p><p>Семантическое действие, которое связано с распознаванием лексических единиц,
возвращает результат соответствующего конструктора. Необходимо загрузить файл
синтаксических правил, так как в нем декларируется тип лексических единиц.
Добавим так же функцию, которая удаляет кавычки вокруг строк.</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting">{
 <span style="color:black">open</span> <span style="color:black">Basic_parser</span> ;;

 <span style="color:black">let</span> <span style="color:black">string_chars</span> <span style="color:black">s</span> = <span style="color:black">String</span>.<span style="color:black">sub</span> <span style="color:black">s</span> 1 ((<span style="color:black">String</span>.<span style="color:black">length</span> <span style="color:black">s</span>)-2) ;;
}

<span style="color:black">rule</span> <span style="color:black">lexer</span> = <span style="color:black">parse</span>
   [' ' '\<span style="color:black">t</span>']            { <span style="color:black">lexer</span> <span style="color:black">lexbuf</span> }

 | '\<span style="color:black">n</span>'                  { <span style="color:black">Leol</span> }

 | '!'                   { <span style="color:black">Lneg</span> }
 | '&amp;'                   { <span style="color:black">Land</span> }
 | '|'                   { <span style="color:black">Lor</span> }
 | '='                   { <span style="color:black">Lequal</span> }
 | '%'                   { <span style="color:black">Lmod</span> }
 | '+'                   { <span style="color:black">Lplus</span> }
 | '-'                   { <span style="color:black">Lminus</span> }
 | '*'                   { <span style="color:black">Lmult</span> }
 | '/'                   { <span style="color:black">Ldiv</span> }

 | ['&lt;' '&gt;']             { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"&lt;="</span>                  { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"&gt;="</span>                  { <span style="color:black">Lrel</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }

 | <span style="color:black">"REM"</span> [^ '\<span style="color:black">n</span>']*       { <span style="color:black">Lrem</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"LET"</span>                 { <span style="color:black">Llet</span> }
 | <span style="color:black">"PRINT"</span>               { <span style="color:black">Lprint</span> }
 | <span style="color:black">"INPUT"</span>               { <span style="color:black">Linput</span> }
 | <span style="color:black">"IF"</span>                  { <span style="color:black">Lif</span> }
 | <span style="color:black">"THEN"</span>                { <span style="color:black">Lthen</span> }
 | <span style="color:black">"GOTO"</span>                { <span style="color:black">Lgoto</span> }

 | <span style="color:black">"RUN"</span>                { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"LIST"</span>               { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | <span style="color:black">"END"</span>                { <span style="color:black">Lcmd</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }

 | ['0'-'9']+           { <span style="color:black">Lint</span> (<span style="color:black">int_of_string</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>)) }
 | ['<span style="color:black">A</span>'-'<span style="color:black">z</span>']+           { <span style="color:black">Lident</span> (<span style="color:black">Lexing</span>.<span style="color:black">lexeme</span> <span style="color:black">lexbuf</span>) }
 | '<span style="color:black">"' [^ '"</span>']* '<span style="color:black">"'     { Lstring (string_chars (Lexing.lexeme lexbuf)) }</span></td></tr>
</table><p>Заметьте, что нам пришлось изолировать символ =, который используется
одновременно в выражениях и приравниваниях.</p><p>Для двух рациональных выражений необходимо привести определённые объяснения.
Линия комментариев соответствует выражению <span style="font-family:monospace">("REM"
[</span>∧<span style="font-family:monospace">’</span>\<span style="font-family:monospace">n’]*)</span>, где за ключевым словом <span style="font-family:monospace">REM</span> следует какое
угодно количество символов и затем перевод строки. Правило, которое
соответствует символьным строкам, <span style="font-family:monospace">(’"’ [</span>∧<span style="font-family:monospace"> ’"’]* ’"’)</span>,
подразумевает последовательность символов, отличных от " и заключённых в
кавычки ".</p>
<!--TOC subsection id=sec63 Компиляция, компоновка-->
<h3 id="sec63" class="subsection">11.5.3  Компиляция, компоновка</h3><!--SEC END --><p>Компиляция должна быть реализована в определённом порядке. Это связано с
взаимозависимостью деклараций лексем. Поэтому в нашем случае, необходимо
выполнить команды в следующем порядке:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_types</span>.<span style="color:black">mli</span>
<span style="color:black">ocamlyacc</span> <span style="color:black">basic_parser</span>.<span style="color:black">mly</span>
<span style="color:black">ocamllex</span> <span style="color:black">basic_lexer</span>.<span style="color:black">mll</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_parser</span>.<span style="color:black">mli</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_lexer</span>.<span style="color:black">ml</span>
<span style="color:black">ocamlc</span> -<span style="color:black">c</span> <span style="color:black">basic_parser</span>.<span style="color:black">ml</span></td></tr>
</table><p>После чего получим файлы <span style="font-family:monospace">basic_lexer.cmo</span> и <span style="font-family:monospace">basic_parser.cmo</span>,
которые можно использовать в нашей программе.</p><p>Теперь, у нас есть весь необходимый арсенал, для того чтобы переделать
программу.</p><p>Удалим все типы и функции параграфов лексический анализ (стр.
<a href="#%3F%3F">??</a>) и синтаксический анализ (стр. <a href="#%3F%3F">??</a>) для программы
Бэйсик. Также в функции <span style="font-family:monospace">one_command</span> (стр. <a href="#%3F%3F">??</a>) заменим
выражение:</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">match</span> <span style="color:black">parse</span> (<span style="color:black">input_line</span> <span style="color:black">stdin</span>) <span style="color:black">with</span></td></tr>
</table><p>на</p><table class="lstframe" style="padding:1ex;border-style:none none none solid;"><tr><td class="lstlisting"><span style="color:black">match</span> <span style="color:black">line</span> <span style="color:black">lexer</span> (<span style="color:black">Lexing</span>.<span style="color:black">from_string</span> ((<span style="color:black">input_line</span> <span style="color:black">stdin</span>)^<span style="color:black">"\n"</span>)) <span style="color:black">with</span></td></tr>
</table><p>Заметьте, что необходимо поместить в конце линии символ конца ’\n’,
который был удалён функцией <span style="font-family:monospace">input_line</span>. Это необходимо, потому что
данный символ используется для указания конца командной линии (<span style="font-family:monospace">Leol</span>).
</p>
<!--TOC section id=sec64 Exercises-->
<h2 id="sec64" class="section">11.6  Exercises</h2><!--SEC END -->
<!--TOC section id=sec65 Резюме-->
<h2 id="sec65" class="section">11.7  Резюме</h2><!--SEC END --><p>В данной главе были описаны различные средства лексического и синтаксического
анализа Objective CAML. По порядку описания:</p><ul class="itemize"><li class="li-itemize">
	модуль <span style="font-family:monospace">Str</span> для фильтрования рациональных выражений<p>	</p></li><li class="li-itemize">модуль <span style="font-family:monospace">Genlex</span> для быстрого создания простых лексических
анализаторов<p>	</p></li><li class="li-itemize"><span style="font-family:monospace">ocamllex</span> представитель семейства <span style="font-family:monospace">lex</span><p>	</p></li><li class="li-itemize"><span style="font-family:monospace">ocamlyacc</span> представитель семейства <span style="font-family:monospace">yacc</span><p>	</p></li><li class="li-itemize">потоки, для построения нисходящих анализаторов, в том числе и
контекстных
</li></ul><p>При помощи инструментов o<span style="font-family:monospace">camllex</span> и <span style="font-family:monospace">ocamlyacc</span> мы переделали
синтаксический анализ Бэйсика, который проще поддерживать, чем анализатор
представленный на стр. <a href="#%3F%3F">??</a>.
</p>
<!--TOC section id=sec66 To Learn More-->
<h2 id="sec66" class="section">11.8  To Learn More</h2><!--SEC END -->
<!--BEGIN NOTES chapter-->
<hr class="footnoterule"><dl class="thefootnotes"><dt class="dt-thefootnotes">
<a id="note2" href="#text2">1</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">тип
<span style="font-family:monospace">lexeme</span> определён на стр. <a href="#%3F%3F">??</a></div>
</dd><dt class="dt-thefootnotes"><a id="note3" href="#text3">2</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">традиционно, такое слово обозначается греческой буквой эпсилон:
ε</div>
</dd><dt class="dt-thefootnotes"><a id="note4" href="#text4">3</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">анализируемая часть выражения подчёркнута, а так же
указано используемое правило </div>
</dd><dt class="dt-thefootnotes"><a id="note5" href="#text5">4</a></dt><dd class="dd-thefootnotes"><div class="footnotetext">Обычно на русский язык термины <span style="font-weight:bold">shift</span> и
<span style="font-weight:bold">reduce</span> переводят как сдвиг и вывод, но в данной книге для термина <span style="font-weight:bold">reduce</span> будет также использоваться перевод сокращение — прим. пер. </div>
</dd></dl>
<!--END NOTES-->
<!--TOC chapter id=sec67 Взаимодействие с языком C-->
<h1 id="sec67" class="chapter">Глава 12  Взаимодействие с языком C</h1><!--SEC END -->
<!--TOC chapter id=sec68 Приложения-->
<h1 id="sec68" class="chapter">Глава 13  Приложения</h1><!--SEC END -->
<!--TOC part id=sec69 Устройство программы-->
<table class="center"><tr><td><h1 id="sec69" class="part">Часть III<br>
Устройство программы</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec70 Модульное программирование-->
<h1 id="sec70" class="chapter">Глава 14  Модульное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec71 Объектно-ориентированное программирование-->
<h1 id="sec71" class="chapter">Глава 15  Объектно-ориентированное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec72 Сравнение моделей устройств программ-->
<h1 id="sec72" class="chapter">Глава 16  Сравнение моделей устройств программ</h1><!--SEC END -->
<!--TOC chapter id=sec73 Приложения-->
<h1 id="sec73" class="chapter">Глава 17  Приложения</h1><!--SEC END -->
<!--TOC part id=sec74 Параллелизм и распределение-->
<table class="center"><tr><td><h1 id="sec74" class="part">Часть IV<br>
Параллелизм и распределение</h1></td></tr>
</table><!--SEC END -->
<!--TOC chapter id=sec75 Процессы и связь между процессами-->
<h1 id="sec75" class="chapter">Глава 18  Процессы и связь между процессами</h1><!--SEC END -->
<!--TOC chapter id=sec76 Параллельное программирование-->
<h1 id="sec76" class="chapter">Глава 19  Параллельное программирование</h1><!--SEC END -->
<!--TOC chapter id=sec77 Распределённое программирование-->
<h1 id="sec77" class="chapter">Глава 20  Распределённое программирование</h1><!--SEC END -->
<!--TOC chapter id=sec78 Приложения-->
<h1 id="sec78" class="chapter">Глава 21  Приложения</h1><!--SEC END -->
<!--TOC part id=sec79 Разработка программ с помощью Objective CAML-->
<table class="center"><tr><td><h1 id="sec79" class="part">Часть V<br>
Разработка программ с помощью Objective CAML</h1></td></tr>
</table><!--SEC END -->
<!--TOC part id=sec80 Приложения-->
<table class="center"><tr><td><h1 id="sec80" class="part">Часть VI<br>
Приложения</h1></td></tr>
</table><!--SEC END --><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<hr style="height:2"><blockquote class="quote"><em>Этот документ был преобразован из L<sup>A</sup>T<sub>E</sub>X
</em><a href="http://hevea.inria.fr/index.html"><em>H</em><em><span style="font-size:small"><sup>E</sup></span></em><em>V</em><em><span style="font-size:small"><sup>E</sup></span></em><em>A</em></a><em>.</em></blockquote></body>
</html>
