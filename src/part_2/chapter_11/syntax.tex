\section{Синтаксис}

Благодаря лексическому анализу, мы в состоянии разбить поток символов на более
структурированные элементы: лексические элементы. Теперь необходимо знать как
правильно объединять эти элементы в синтаксически корректные фразы какого-нибудь
языка. Правила синтаксической группировки определены посредством грамматических
правил. Формализм, произошедший из лингвистики, был с успехом перенят
математиками, занимающимися теориями языков, и специалистами по информатике. На
странице \ref{??} мы уже видели пример грамматики для языка BASIC. Здесь мы
снова вернёмся к этому примеру, чтобы более углублённо ознакомится с базовыми
концепциями грамматики.

\subsection{Грамматика}

Говоря формальным языком, грамматика основывается на четырёх элементах:

\begin{enumerate}
	\item Множество символов, называемых терминалами. Эти символы являются
лексическими элементами языка. В Бэйсике к ним относятся символы операторов,
арифметических отношений и логические (+, $\&$, <, $\le$, $\cdots$), ключевые
слова языка {\bf (GOTO, PRINT, IF, THEN, $\cdots$)}, целые числа (элемент
\texttt{integer}) и переменные (элемент \texttt{variable}).

	\item Множество нетерминальных символов, которые представляют
синтаксические компоненты языка. Например, программа на языке Бэйсик состоит из
строк. Таким образом мы имеем компоненту Line, которая в свою очередь
состоит из выражений (Expression), и т.д.

	\item Множество так называемых порождающих правил. Они описывают каким
образом комбинируются терминальные и нетерминальные символы, чтобы создать
синтаксическую компоненту. Строка в Бэйсике начинается с номера, за которой
следует инструкция. Смысл правила следующий:

\begin{center}
	Line ::= {\it integer} Instruction
\end{center}

Одна и та же компонента может быть порождена несколькими способами. В этом
случае варианты разделяются символом | как в:

\begin{center}
	\begin{tabular}{rcl}
		Instruction & ::= & LET variable = Instruction \\
		 & | & GOTO integer \\
		 & | & PRINT Expression \\
		etc & &
	\end{tabular}
\end{center}


\end{enumerate}

    Среди всех нетерминальных символов различают один, называемый начальным.
Правило, которое порождает эту аксиому является порождающим правилом всего
языка.

\subsection{Порождение и распознавание}
\label{page_ref:Production_and_Recognition}

С помощью порождающих правил можно определить принадлежит ли последовательность
лексем языку.

Рассмотрим простой язык, описывающий арифметические выражения:

\begin{center}
	\begin{tabular}{rclc}
		Exp & ::= & {\it integer} & (R1) \\
		 & | & Exp + Exp & (R2) \\
		 & | & Exp * Exp & (R3) \\
		 & | & ( Exp ) & (R4)
	\end{tabular}
\end{center}

здесь {\it (R1) (R2) (R3) (R4)} --- имена правил. По окончании лексического
анализа выражение $1*(2+3)$ становится последовательностью следующих лексем:

\begin{center}
{\it integer * (integer + integer)}
\end{center}

Для того, чтобы проанализировать эту фразу и убедиться в том что она принадлежит
языку арифметических выражений, воспользуемся правилами справа налево: если
часть выражения соответствует правому члену какого-нибудь правила, мы заменяем
это выражение соответствующим левым членом. Этот процесс продолжается до тех
пор, пока выражение не будет редуцировано до аксиомы. Ниже представлен результат
такого анализа \footnote{анализируемая часть выражения подчёркнута, а так же
указано используемое правило }:

\begin{center}
	\begin{tabular}{rcl}
		integer * (integer + integer) & (R1) & Exp * (integer + integer) \\
		& (R1) & Exp * (Exp + integer) \\
		& (R1) & Exp * (Exp + Exp) \\
		& (R2) & Exp * (Exp) \\
		& (R4) & Exp * Exp \\
		& (R3) & Exp
	\end{tabular}
\end{center}

Начиная с последней линии, которая содержит лишь Exp и следуя стрелкам, можно
определить каким образом было полученное выражение исходя из аксиомы Exp.
Соответственно данная фраза является правильно сформированной фразой языка
арифметических выражений, определённого грамматикой.

Преобразование грамматики в программу, способную распознать принадлежность
последовательности лексем языку, который определён грамматикой, является более
сложной проблемой, чем проблема использования регулярных выражений.
Действительно, в соответствии с математическим результатом любое множество
(слов), определённое формализмом регулярных выражений, может быть определено
другим формализмом: детерминированные конечные автоматы. Такие автоматы легко
реализуются программами, принимающими поток символов. Подобный результат для
грамматик в общем не существует. Однако, имеются менее строгие (?) (weaker)
результаты устанавливающие эквивалентность между определёнными классами
грамматик и более богатыми автоматами: автомат со стеком. Здесь мы не станем
вдаваться ни в детали этих результатов, ни в точное определение таких автоматов.
Однако, мы можем определить какие классы грамматики могут использоваться в
средствах генерации синтаксических анализаторов или для реализации напрямую
анализатора.

\subsection{Нисходящий анализ}

Разбор выражения $1 * (2 + 3)$ в предыдущем параграфе не является единственным:
мы с таким же успехом могли бы начать редуцирование {\it integer}, то есть
воспользоваться правилом {\it (R2)} редуцирования $2 + 3$. Эти два способа
распознавания являются двумя типами анализа: восходящий анализ (справа налево) и
нисходящий слева направо. Последний анализ легко реализуется при помощи потоков
лексем модуля \texttt{Stream}. Средство \texttt{ocamlyacc} использует восходящий
анализ, при котором применяется стек, как это уже было проиллюстрировано
синтаксическим анализатором программ на Бэйсике. Выбор анализа не просто дело
вкуса, в зависимости от используемой для спецификации языка формы грамматики,
можно или нет применять нисходящий анализ.

\subsubsection{Простой случай}

Каноническим примером нисходящего анализа является префиксная запись
арифметических выражений, определяемая как:

\begin{center}
	\begin{tabular}{rcl}
		Exp & ::= & integer \\
		& | & + Exp Exp \\
		& | & * Exp Exp \\
	\end{tabular}
\end{center}

В данном случае достаточно знать первую лексему, для того чтобы определить какое
правило может быть использовано. При помощи подобной предсказуемости нет
необходимости явно управлять стеком, достаточно положиться на рекурсивный вызов
анализатора. И тогда при помощи \texttt{Genlex} и \texttt{Stream} очень просто
написать программу реализующую нисходящий анализ. Функция \texttt{infix\_of} из
полученного префиксного выражения возвращает его инфиксный эквивалент:

\begin{lstlisting}[language=Caml]
# let lexer s =
   let ll = Genlex.make_lexer ["+";"*"]
   in ll (Stream.of_string s);;
val lexer : string -> Genlex.token Stream.t = <fun>

# let rec stream_parse s =
   match s with parser
     [<'Genlex.Ident x>] -> x
   | [<'Genlex.Int n>] -> string_of_int n
   | [<'Genlex.Kwd "+"; e1=stream_parse; e2=stream_parse>] -> "("^e1^"+"^e2^")"
   | [<'Genlex.Kwd "*"; e1=stream_parse; e2=stream_parse>] -> "("^e1^"*"^e2^")"
   | [<>] -> failwith "Parse error" ;;
val stream_parse : Genlex.token Stream.t -> string = <fun>

# let infix_of s = stream_parse (lexer s) ;;
val infix_of : string -> string = <fun>

# infix_of "* +3 11 22";;
- : string = "((3+11)*22)"
\end{lstlisting}

Однако не стоит забывать о некоторой примитивности лексического анализа.
Советуем периодически добавлять пробелы между различными лексическими
элементами.

\begin{lstlisting}[language=Caml]
# infix_of "*+3 11 22";;
- : string = "*+"
\end{lstlisting}

\subsubsection{Случай посложней}

Синтаксический анализ при помощи потоков предсказуем, он облагает грамматику
двумя условиями:

\begin{itemize}
	\item В правилах грамматики не должно быть левой рекурсии. Правило
называется рекурсивным слева, если его правый член начинается с нетерминального
символа, который является левой частью правила. Например: \texttt{Exp ::= Exp +
Exp}

	\item Не должно существовать правил начинающихся одним и тем же выражением.
\end{itemize}

Грамматика арифметических выражений, приведённая на стр.
\pageref{page_ref:Production_and_Recognition}, не подходит для нисходящего
анализа: они не удовлетворяют ни одному из условий. Для того, чтобы применить
нисходящий анализ необходимо переформулировать грамматику таким образом, чтобы
удалить левую рекурсию и неопределённость правил. Вот полученный результат:

\begin{center}
	\begin{tabular}{rcl}
		Exp & ::= & Atom NextExpr \\
		NextExpr & ::= & + Atom \\
		 & | & - Atom \\
		 & | & * Atom \\
		 & | & / Atom \\
 		 & | & $\varepsilon$ \\
		 Atom & ::= & integer \\
		 & | & ( Expr )
	\end{tabular}
\end{center}

Заметьте использование пустого слова $\varepsilon$ в определении
\texttt{NextExpr}. Оно необходимо, если мы хотим чтобы просто целое число
являлось выражением.

Следующий анализатор есть просто перевод вышеуказанной грамматики в код. Он
реализует абстрактное синтаксическое дерево арифметических выражений.

\begin{lstlisting}[language=Caml]
# let rec rest = parser
    [< 'Lsymbol "+"; e2 = atom >] -> Some (PLUS,e2)
  | [< 'Lsymbol "-"; e2 = atom >] -> Some (MINUS,e2)
  | [< 'Lsymbol "*"; e2 = atom >] -> Some (MULT,e2)
  | [< 'Lsymbol "/"; e2 = atom >] -> Some (DIV,e2)
  | [< >] -> None
 and atom = parser
     [< 'Lint i >] -> ExpInt i
   | [< 'Lsymbol "("; e = expr ; 'Lsymbol ")" >] -> e
 and expr s =
   match s with parser
     [< e1 = atom >] ->
       match rest s with
          None -> e1
        | Some (op,e2) -> ExpBin(e1,op,e2) ;;
val rest : lexeme Stream.t -> (bin_op * expression) option = <fun>
val atom : lexeme Stream.t -> expression = <fun>
val expr : lexeme Stream.t -> expression = <fun>
\end{lstlisting}

Сложность использования нисходящего анализа заключается в том, что грамматика
должна быть очень ограниченной формы. Если язык выражен естественно с
использованием левой рекурсии (как в инфиксных выражениях), то не всегда легко
определить эквивалентную грамматику, то есть определяющую такой же язык, которая
бы удовлетворяла требованиям нисходящего анализа. По этой причине, средства
\texttt{yacc} и \texttt{ocamlyacc} реализуют восходящий анализ, который
разрешает определение более естественных грамматик. Однако, мы увидим, что даже
в этом случае существуют ограничения.

\subsection{Восходящий анализ}

Мы уже вкратце представили на странице \pageref{??} принципы восходящего
анализа: сдвиг и вывод \footnote{Обычно на русский язык термины {\bf shift} и
{\bf reduce} переводят как сдвиг и вывод, но в данной книге для термина {\bf
reduce} будет также использоваться перевод \enq{сокращение} --- прим. пер. }.
После каждого подобного действия, состояние стека изменяется. Из этой
последовательности можно вывести правила грамматики, в случае если грамматика
это позволяет, как в примере с нисходящим анализом. Опять же, сложности
возникают из-за неопределённости правил, когда невозможно выбрать между
продвинутся или сократить. Проиллюстрируем действие восходящего анализа и его
недостатки на все тех же арифметических выражениях в постфиксном и инфиксном
написании.

\subsubsection{Положительная сторона}

Упрощённая постфиксная грамматика арифметических выражений выглядит так:

\begin{center}
	\begin{tabular}{rclc}
		Exp & ::= & {\it integer} & (R1) \\
		 & | & Exp Exp + & (R2) \\
		 & | & Exp Exp - & (R3) \\
	\end{tabular}
\end{center}

Данная грамматика является двойственной по отношению к префиксной: для того
чтобы точно знать какое правило следует применить, необходимо дождаться
окончания анализа. В действительности анализ подобных выражений схож с
вычислением при помощи стека. Только вместо проталкивания результата вычисления,
проталкиваются грамматические символы. Если в начале стек пустой, то после того
как ввод закончен, необходимо получить стек содержащий лишь нетерминальную
аксиому. Приведём изменение стека: если мы продвигаемся, то проталкивается
текущий нетерминальный символ; если сокращаем, то первые символы стека
соответствуют правому члену (в обратном порядке) правила и тогда мы заменяем эти
элементы соответствующими нетерминальными элементами.

В таблице \ref{tbl:bottom-up_parsing} приведён восходящий анализ выражения 1 2
+ 3 * 4 +. Считываемая лексическая единица подчёркивается для более удобного
чтения. Конец потока помечается символом \$.

\begin{table}[hс]
	\caption{Восходящий анализ}
	\begin{center}
	\begin{tabular}{|l|l|r|}
	\hline
	Действие  & Вход & Стек \\
	\hline
	 & \underline{1} 2 + 3 * 4 + \$ & [] \\
	\hline
	Сдвиг & & \\
	\hline
	 & \underline{2} + 3 * 4 + \$ & [1] \\
	\hline
	Сократить {\it (R1)} & & \\
	\hline
	 & \underline{2} + 3 * 4 + \$ & [Exp] \\
	\hline
	Сдвиг & & \\
	\hline
	 & \underline{+} 3 * 4 + \$ & [2 Exp] \\
	\hline
	Сдвиг, Сократить {\it (R1)} & & \\
	\hline
	 & \underline{+} 3 * 4 + \$ & [Exp Exp] \\
	\hline
	Сдвиг, Сократить {\it (R2)} & & \\
	\hline
	 & \underline{3} * 4 + \$ & [Exp] \\
	\hline
	Сдвиг, Сократить {\it (R1)} & & \\
	\hline
	 & \underline{*} 4 + \$ & [Exp Exp] \\
	\hline
	Сдвиг, Сократить {\it (R3)} & & \\
	\hline
	 & \underline{4} + \$ & [Exp] \\
	\hline
	Сдвиг, Сократить {\it (R1)} & & \\
	\hline
	 & \underline{+} \$ & [Exp Exp] \\
	\hline
	Сдвиг, Сократить {\it (R2)} & & \\
	\hline
	 & \underline{\$} & [Exp] \\
	\hline
	\end{tabular}
	\end{center}
	\label{tbl:bottom-up_parsing}
\end{table}

\subsubsection{Отрицательная сторона}

Вся трудность перехода от грамматики к программе распознающей язык заключается в
определении действия, которое необходимо применить. Проиллюстрируем эту проблему
на трёх примерах, приводящих к трём неопределённостям.

Первый пример есть грамматика выражений использующих операцию сложения:

\begin{center}
	\begin{tabular}{rclc}
		E0 & ::= & {\it integer} & (R1) \\
		 & | & E0 + E0 & (R2) \\
	\end{tabular}
\end{center}

Неопределённость данной грамматики проявляется при использовании правила {\it
R2}. Предположим следующую ситуацию:

\begin{table}[hс]
	\begin{center}
	\begin{tabular}{|l|l|r|}
	\hline
	Действие  & Вход & Стек \\
	\hline
	: & & \\
	\hline
	& \underline{+} & E0 + E0 $\ldots$ \\
	\hline
	: & & \\
	\hline
	\end{tabular}
	\end{center}
\end{table}

В подобном случае невозможно определить необходимо сдвинуть и протолкнуть в стек
+ или сократить в соответствии с правилом {\it (R2)} оба E0 и присутствующий в
стеке +. Подобная ситуация называется конфликтом сдвиг-вывод (shift/reduce). Она
является следствием того, что выражение {\it integer} + {\it integer} + {\it
integer} может быть выведено справа двумя способами.

Первый вариант:

\begin{center}
	\begin{tabular}{rl}
		E0 & ({\it R2}) E0 + \underline{E0} \\
		 & ({\it R1}) \underline{E0} + {\it integer} \\
		 & ({\it R2}) E0 + \underline{E0} + {\it integer} \\
	\end{tabular}
\end{center}

Второй вариант:

\begin{center}
	\begin{tabular}{rl}
		E0 & ({\it R2}) E0 + \underline{E0} \\
		 & ({\it R1}) E0 + E0 + \underline{E0} + {\it integer} \\
		 & ({\it R2}) E0 + \underline{E0} + {\it integer} \\
	\end{tabular}
\end{center}

Выражения, полученные двумя выводами, могут показаться одинаковыми с точки
зрения вычисления выражения,

({\it integer} + {\it integer}) + {\it integer} и {\it integer} + ({\it integer}
+ {\it integer})

но разными для конструкции синтаксического дерева (см. рис. \ref{??} на стр.
\pageref{??})


Второй пример грамматики, порождающей конфликт между сдвиг-вывод, содержит
такую же неопределённость: явное заключение в скобки. Но в отличии от
предыдущего случая, выбор сдвиг-вывод изменяет смысл выражения. Пусть есть
грамматика:

\begin{center}
	\begin{tabular}{rcl}
		E1 & ::= & {\it integer} ({\it R1}) \\
		 & | & E1 + E1 ({\it R2}) \\
		 & | & E1 * E1 ({\it R3})
	\end{tabular}
\end{center}

Здесь мы снова получаем предыдущий конфликт как в случае с + так и для *, но к
этому добавляется другой, между + и *. Опять же, одно и то же выражение может
быть получено двумя способами, так как у него существует два вывода справа:

{\it integer} + {\it integer} * {\it integer}

Первый вариант:

\begin{center}
	\begin{tabular}{rl}
		E1 & ({\it R3}) E0 * \underline{E1} \\
		 & ({\it R1}) \underline{E1} * {\it integer} \\
		 & ({\it R2}) E1 + \underline{E1} * {\it integer}
	\end{tabular}
\end{center}

Второй вариант:

\begin{center}
	\begin{tabular}{rl}
		E1 & ({\it R2}) E1 + \underline{E1} \\
		 & ({\it R2}) E1 + E1 * \underline{E1} \\
		 & ({\it R1}) E1 + \underline{E1} * {\it integer}
	\end{tabular}
\end{center}

В данном выражении обе пары скобок имеют разный смысл:

({\it integer} + {\it integer}) * {\it integer} $\neq$ {\it integer} + ({\it
integer} * {\it integer})

Подобную проблему, мы уже встречали в выражениях Basic (см. стр. \pageref{??}).
Она была разрешена при помощи приоритетов, которые присваиваются операторам:
сначала редуцируется правило (R3), затем (R2), что соответствует заключению в
скобки произведения.

Данную проблему выбора между + и * можно решить изменив грамматику. Для того,
введём два новых терминальных символа: член T ({\it term}) и множитель F
({\it factor}). Отсюда получаем:

\begin{center}
	\begin{tabular}{rclc}
		E & ::= & E + T & ({\it R1})\\
		 & | & T & ({\it R2}) \\
		T & ::= & T + F & ({\it R3})\\
		 & | & F & ({\it R4}) \\
		F & ::= & T + {\it integer} & ({\it R5})\\
	\end{tabular}
\end{center}

После этого, единственный способ получить {\it integer} + {\it integer} *
{\it integer}: посредством правила ({\it R1}).

Третий и последний случай касается условных конструкций языка программирования.
На пример в Pascal существует две конструкции: \texttt{if .. then} и \texttt{if
.. then .. else}. Пусть существует следующая грамматика:

\begin{center}
	\begin{tabular}{rclc}
		Instr & ::= & {\it if} EXP {\it then} Instr & ({\it R1})\\
		 & - & {\it if} EXP {\it then} Instr {\it else} Instr & ({\it R2}) \\
		 & - & etc $\ldots$ & \\
	\end{tabular}
\end{center}

И в следующей ситуации:

\begin{table}[hс]
	\begin{center}
	\begin{tabular}{|l|l|r|}
	\hline
	Действие  & Вход & Стек \\
	\hline
	: & & \\
	\hline
	& {\it else} & [Instr {\it then} Epx {\it if} $\ldots$] \\
	\hline
	\end{tabular}
	\end{center}
\end{table}

Невозможно определить соответствуют ли элементы стека правила ({\it R1}) и в
этом случае необходимо сократить или соответствуют первому \texttt{Instr}
правила ({\it R2}) и тогда необходимо сдвинуть.

Кроме конфликтов сдвиг-вывод, восходящий анализ вызывает конфликт вывод-вывод.

Мы представим здесь инструмент \texttt{ocamlyacc}, который использует подобную
технику может встретить указанные конфликты.