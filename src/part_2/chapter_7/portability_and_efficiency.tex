\section{Переносимость и эффективность}
\label{sec:portability_and_efficiency}

Интерес компиляции для абстрактной машины заключается в том что, мы получим код
который может быть запущен на какой угодно реальной архитектуре. Основным
неудобством является интерпретация виртуальных инструкций. Нативный компилятор
создаёт более эффективный код, однако он предназначен лишь для одной
определённой архитектуры. Поэтому, желательно чтобы у нас был выбор типа
компиляции в зависимости от разрабатываемого программного обеспечения. Автономия
исполняемого файла, то есть его независимость от установленного дистрибутива
Objective CAML, лишает приложение переносимости.

\subsection{Автономность и переносимость}

Для того чтобы получить автономный исполняемый файл, компилятор отредактировал
связи байт--код файла \texttt{t.cmo} с \texttt{runtime} библиотекой,
интерпретатором байт--кода и некоторым кодом на C. Предполагается, что в системе
установлен компилятор C. Вставка машинного кода означает, что файл не может быть
выполнен на другой архитектуре или системе.

Дело обстоит по другому в случае байт--код файла. Так как виртуальные инструкции
одни и те же для всех архитектур, лишь присутствие интерпретатора имеет
значение. Такой файл может быть запущен на любой системе, где присутствует
команда \texttt{ocamlrun}, являющаяся частью дистрибутива Objective CAML для
Sparc и Solaris, Intel и Windows и т.д. Всегда желательно использовать одни и те
же версии компилятора и интерпретатора.

Переносимость файлов в байт--код формате позволяет напрямую распространять и
сразу же использовать библиотеки в подобной форме, на машине с интерпретатором
Objective CAML.

\subsection{Эффективность выполнения}

Компилятор байт--кода генерирует инструкции машины Zinc, они будут
интерпретированны \texttt{ocamlrun}. Эта фаза интерпретации кода негативно
влияет на скорость выполнения. Мы можем представить себе интерпретатор Zinc в
действии как большое сопоставление с образцом (сопоставление \texttt{match
\ldots with}), где каждая инструкция есть образец сопоставления, а ответвления
расчёта изменяют состояние стека и счётчика (адрес следующей инструкции).
Несмотря на то, что данное сопоставление оптимизировано, оно все же снижает
эффективность выполнения.

Следующий пример, хоть он и не тестирует все составные части языка, иллюстрирует
разницу во времени выполнения между байт--кодом и автономным вариантом расчёта
чисел Фибоначчи. Пусть у нас есть следующая программа \texttt{fib.ml}:

\begin{lstlisting}[language=OCaml]
let rec fib n =
  if n < 2 then 1
  else (fib (n-1)) + (fib(n-2));;
\end{lstlisting}

и главная программа main.ml:

\begin{lstlisting}[language=OCaml]
for i = 1 to 10 do
  print_int (Fib.fib 30);
  print_newline()
done;;
\end{lstlisting}

Откомпилируем их следующим образом:

\begin{lstlisting}[language=Bash]
$ ocamlc -o fib.exe fib.ml main.ml
$ ocamlopt -o fibopt.exe fib.ml main.ml
\end{lstlisting}

Мы получим два файла \texttt{fib.exe} и \texttt{fibopt.exe}. При помощи команды
\texttt{time} системы Unix на процессоре Pentium 350 с установленной
операционной системой Linux, получим следующие значения:

\begin{tabular}{|l|l|}
\hline
\texttt{fib.exe} (байт--код) & \texttt{fibopt.exe} (машинный) \\
\hline
7 сек. & 1 сек. \\
\hline
\end{tabular}

То есть для одной и той же программы скорость её двух версий отличается в 7 раз.
Данная программа не проверяет все свойства языка, полученная выгода значительно
зависит от типа приложения.