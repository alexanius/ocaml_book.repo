\section{Стандартная библиотека}
\label{sec:standard_library}

В стандартной библиотеке сгруппированы стабильные, платформонезависимые модули. 
На данный момент библиотека содержит 29 модулей, которые в свою очередь состоят 
из 400 функций, 30 типов, половина из которых абстрактные, 8 исключений, 10 
под–модулей и 3 параметризованных модуля. Конечно, мы не будем детально 
рассматривать все объявления модулей, для этого существует справочное 
руководство \cite{??}. Представим лишь модули вводящие новые концепции или 
сложные в использовании.

Стандартная библиотека может быть разбита на 4 большие части:

\begin{itemize}
	\item {\it линейные структуры данных} (15 модулей), некоторые из них мы уже 
видели в первой части.

	\item {\it ввод/вывод} (4 модуля), для форматирования вывода, сохраняемость 
и создание криптографических ключей.

	\item {\it синтаксический и лексический анализ} (4 модуля), их описание 
дано в главе \ref{??}.

	\item {\it системный интерфейс} при помощи которого мы можем передавать, 
анализировать параметры переданные команде, перемещаться в каталогах и 
обращаться к файлам.
\end{itemize}

К этим четырём частям добавим пятую, в которой содержатся полезные функции 
манипуляции или создания структур данных, как например функция текстовой 
обработки или генерации псевдо--случайных чисел и т.д.

\subsection{Утилиты}
\label{subsec:utilities}

Модули, которые мы назовём \enq{полезными}, содержат:

\begin{itemize}
	\item символы: модуль \code{Char} состоит в основном из функций перевода 
(conversion);

	\item клонирование объектов: ОП будет представлено в главе \ref{??}; 
отложенное вычисление: модуль \code{Lazy} рассмотрен в первой части книги на 
\ref{??};

	\item генератор случайных чисел: модуль \code{Random}, описание которого 
проведено ниже.
\end{itemize}

\subsubsection{Генератор случайных чисел}
\label{subsubsec:generation_of_random_numbers}

При помощи модуля \code{Random} можно генерировать случайные числа. Он 
реализует функцию генерации чисел, которая производит начальную установку 
счётчика при помощи списка чисел или одного числа. Для того чтобы эта функция 
не выдавала одно и тоже число, программист должен инициализировать её разными 
числами. Основываясь на этом числе, функция вычисляет список случайных чисел. 
Однако функция, инициализированная одним и тем же числом, выдаст одинаковый 
список. Поэтому, для корректной установки счётчика, нам понадобится внешний 
источник, как например компьютерное время или время прошедшее с момента запуска 
программы.

Ниже приведены функции модуля:

\begin{itemize}
	\item инициализация: \code{init} с типом \type{int -> unit} и
\code{full\_init} с типом \type{int array -> unit} инициализирующие генератор.
Вторая функция ожидает на входе вектор.

	\item генерировать случайное число: \code{bits} с типом \type{unit -> int}
возвращает позитивное целое число, \type{int} с типом \type{int -> int}
возвращает целое число между 0 и пределом, переданным в аргументе и 
\type{float}, которая возвращает число с плавающей запятой между 0 и пределом, 
переданным в аргументе. 
\end{itemize}

\subsection{Линейные структуры данных}
\label{subsec:linear_data_structures}

В следующем списке представлены модули линейных структур данных:

\begin{itemize}
	\item простые модули: \code{Array}, \code{String}, \code{List}, 
\code{Sort}, \code{Stack}, \code{Queue}, \code{Buffer}, \code{Hashtbl}
(параметризован) и \code{Weak};

	\item параметризованные модули: \code{Hashtbl} (с параметром 
\type{HashedType}), \code{Map} и \code{Set} (с параметром \type{OrderedType}).
\end{itemize}

Параметризованные модули построены на основе других модулей, благодаря чему они 
становятся ещё более общими (generic). Создание параметризованных модулей будет 
представлено в главе \ref{??}.

\subsubsection{Линейные структуры простых данных}
\label{subsubsec:simple_linear_data_structures}

Имя модуля указывает на структуру данных, которыми он умеет манипулировать. Если 
тип абстрактный, то есть представление типа спрятано, то в соответствии с 
принятым соглашением, подобный тип именуется \code{t} внутри модуля. Такие 
модули реализуют следующие структуры: 

\begin{itemize}
	\item модуль \code{Array}: векторы

	\item модуль \code{List}: списки

	\item модуль \code{String}: символьные строки

	\item модуль \code{Hashtbl}: хэш--таблицы (абстрактный тип)

	\item модуль \code{Buffer}: расширяемые символьные строки (абстрактный тип)

	\item модуль \code{Stack}: стек (абстрактный тип)

	\item модуль \code{Queue}: очереди или FIFO (абстрактный тип)

	\item модуль \code{Weak}: вектор weak указателей.
\end{itemize}


Укажем так же последний модуль манипулирующий линейными структурами данных:

\begin{itemize}
	\item модуль \code{Sort}: сортировка списков и векторов, объединение списков
\end{itemize}

\paragraph{Семейство общих функций}

За исключением модуля \code{Sort}, все остальные модули определяют структуры 
данных, функции создания таких структур и доступа к элементам этих структур, а 
так же функции манипуляции, включая функцию перевода в другие типы данных. 
Только модуль \code{List} обходится без физического изменения данных. Мы не 
станем давать полное описание всех функций, ограничимся лишь семейством 
функций, используемых этими модулями. Модули \code{List} и \code{Array} будут 
рассмотрены в деталях, так как это наиболее часто встречающиеся структуры в 
императивном и функциональном программировании.

Следующие функции можно найти во всех или почти всех модулях:

\begin{itemize}
	\item функция \code{lenght}, которая вычисляет размер типа переданного в 
аргументе

	\item функция \code{clear} очищает структуры, если она изменяемая 

	\item функция \code{add} для добавления элемента, она может иметь другое 
имя, в зависимости от \enq{обычаев} (как например \code{push} для стека) 

	\item функция доступа к i-тому элементу, обычно называемой \code{get}

	\item функция удаления элемента (часто первого) \code{remove} или 
\code{take}
\end{itemize}

По тому же принципу, в нескольких модулях можно встретить функции просмотра и
обработки элементов:

\begin{itemize}
	\item \code{map}: применяет функцию ко всем элементам структуры и 
возвращает новую структуру с результатами. 

	\item \code{iter}: схожа с \code{map}, но возвращает \type{()}. 
\end{itemize}

Для структур с индексированными элементами существуют следующие функции.

\begin{itemize}
	\item \code{fill}: изменяет часть структуры на новое значение;

	\item \code{blit}: копирует часть структуры в другую того же типа;

	\item \code{sub}: копирует часть структуры и создаёт новую.
\end{itemize}


\subsubsection{Модули \code{List} и \code{Array}}
\label{subsubsec:modules_list_and_array}

 Описывая функции этих библиотек, мы сконцентрируем внимание на особенности и 
общие черты каждой из них. Для функций одинаковых для обоих модулей тип 
\type{t} означает \type{'a list} или \type{a' array}. Для функций специфичных 
одному модулю воспользуемся синтаксисом с точкой.

\paragraph{Схожие или аналогичные функции}

Первая из них --- подсчёт длинны.

\begin{tabular}{|c|c|c|}
	\hline
	\code{List.length} & : & \type{'a t -> int} \\
	\hline
\end{tabular}

Две функции для конкатенации двух структур или всех структур списка. 

\begin{tabular}{|c|c|c|}
	\hline
	\code{append} & : & \type{'a t-> 'a t-> 'a t} \\
	\hline
	\code{concat} & : & \type{'a t list -> 'a t} \\
	\hline
\end{tabular}

Каждый модуль включает функцию доступа к элементу структуры по позиции. 

\begin{tabular}{|c|c|c|}
	\hline
	\code{List.nth} & : & \type{'a list -> int -> 'a} \\
	\hline
	\code{Array.get} & : & \type{'a array -> int -> 'a} \\
	\hline
\end{tabular}

В связи с тем что Функция для доступа к i-тому элементу вектора \code{t} часто
используется у неё есть укороченный синтаксис: \code{t.(i)}.

Две функции, позволяющие выполнить определённое действие (функцию) над всеми 
элементами структуры.

\begin{tabular}{|c|c|c|}
	\hline
	\code{iter} & : & \type{('a -> unit) -> 'a t -> unit} \\
	\hline
	\code{map} & : & \type{('a -> 'b) -> 'a t -> 'b t} \\
	\hline
\end{tabular}

Чтобы вывести все элементы списка или вектора, воспользуемся \code{iter}.

\begin{lstlisting}[language=OCaml]
# let print_content iter print_item xs = 
   iter (fun x -> print_string"("; print_item x; print_string")") xs;
   print_newline() ;;
val print_content : (('a -> unit) -> 'b -> 'c) -> ('a -> 'd) -> 'b -> unit =
  <fun>
# print_content List.iter print_int [1;2;3;4;5] ;;
(1)(2)(3)(4)(5)
- : unit = ()
# print_content Array.iter print_int [|1;2;3;4;5|] ;;
(1)(2)(3)(4)(5)
- : unit = ()
\end{lstlisting}

Функция \code{map} создаёт новую структуру, которая содержит результаты 
применения функции к элементам списка или вектора. Проверим это на векторе с 
изменяемым содержимым: 

\begin{lstlisting}[language=OCaml]
# let a = [|1;2;3;4|] ;;
val a : int array = [|1; 2; 3; 4|]
# let b = Array.map succ a ;;
val b : int array = [|2; 3; 4; 5|]
# a, b;;
- : int array * int array = [|1; 2; 3; 4|], [|2; 3; 4; 5|]
\end{lstlisting}

При помощи следующих итераторов можно создать частичное применение функции для 
каждого элемента вектора:

\begin{tabular}{|c|c|c|}
	\hline
	\code{fold\_left} & : & \type{(('a -> 'b -> 'a) -> 'a -> 'b t -> 'a} \\
	\hline
	\code{fold\_right} & : & \type{(('a -> 'b -> 'b) -> 'a t -> 'b -> 'b} \\
	\hline
\end{tabular}

Этим итераторам необходимо указать базовый случай со значением по умолчанию, 
которое будет возвращено в случае если структура пустая.

\code{fold\_left f r [v1; v2; ...; vn] 	= 	f ... ( f (f r v1) v2 ) ... vn \\
fold\_right f [v1; v2; ...; vn] r 	= 	f v1 ( f v2 ... (f vn r) ... )}

При помощи этих функций можно легко превратить бинарную функцию в n--арную. Для 
коммутативной и ассоциативной операции итерация слева на право или справа налево 
одинакова:

\begin{lstlisting}[language=OCaml]
# List.fold_left (+) 0 [1;2;3;4] ;;
- : int = 10
# List.fold_right (+) [1;2;3;4] 0 ;;
- : int = 10
# List.fold_left List.append [0] [[1];[2];[3];[4]] ;;
- : int list = [0; 1; 2; 3; 4]
# List.fold_right List.append [[1];[2];[3];[4]] [0] ;;
- : int list = [1; 2; 3; 4; 0]
\end{lstlisting}

Отметим, что пустой лист является нейтральным элементом слева и справа для 
двоичного сложения. Для этого частного случая следующие выражения эквивалентны:

\begin{lstlisting}[language=OCaml]
# List.fold_left List.append [] [[1];[2];[3];[4]] ;;
- : int list = [1; 2; 3; 4]
# List.fold_right List.append [[1];[2];[3];[4]] [] ;;
- : int list = [1; 2; 3; 4]
\end{lstlisting}

Таким образом мы \enq{создали} функцию \code{List.concat}.

\paragraph{Операции над списками}

Следующие полезные функции находятся в модуле \code{List}.

\begin{tabular}{|l|c|l|}
	\hline
	\code{List.hd} & : & \type{'a list -> 'a} \\
	 & & первый элемент списка \\
	\hline
	\code{List.tl} & : & \type{'a list -> 'a} \\
	 & & список, без первого элемента \\
	\hline
	\code{List.rev} & : & \type{'a list -> 'a list} \\
	 & & список в обратном порядке \\
	\hline
	\code{List.mem} & : & \type{'a -> 'a list -> bool} \\
	 & & тест на принадлежность списку \\
	\hline
	\code{List.flatten} & : & \type{'a list list -> 'a list} \\
	 & & \enq{разложить} список списков \\
	\hline
	\code{List.rev\_append} & : & \type{'a list -> 'a list -> 'a list} \\
	 & & то же что и \code{append (rev l1) l2} \\
	\hline
\end{tabular}

Первые две функции являются частичными, если им передать пустой список, то 
исключение \code{Failure} будет возбуждено. Существует вариант \code{mem: 
memq}, использующий физическое равенство.

\begin{lstlisting}[language=OCaml]
# let c = (1,2) ;;
val c : int * int = 1, 2
# let l = [c] ;;
val l : (int * int) list = [1, 2]
# List.memq (1,2) l ;;
- : bool = false
# List.memq c l ;;
- : bool = true
\end{lstlisting}

В модуле \code{List} имеется два особенных итератора, обобщающих булеву 
конъюнкцию и дизъюнкцию (and/or): \code{List.for\_all} и \code{List.exists}
определяются следующим образом.

\begin{lstlisting}[language=OCaml]
# let for_all f xs = List.fold_right (fun x -> fun b -> (f x) & b) xs true ;;
val for_all : ('a -> bool) -> 'a list -> bool = <fun>
# let exists f xs = List.fold_right (fun x -> fun b -> (f x) or b) xs false ;;
val exists : ('a -> bool) -> 'a list -> bool = <fun>
\end{lstlisting}

В модуле \code{List} имеется различные варианты итераторов (\code{iter2}, 
\code{map2}, etc.), которые принимают на входе два листа и обходят их 
параллельно. В случае если листы имеют разную длину, возбуждается исключение 
\code{Invalid\_argument}.

Следующие функции позволяют осуществлять поиск элемента в списке при помощи 
критерия в виде булевой функции:

\begin{tabular}{|c|c|c|}
	\hline
	\code{List.find} & : & \type{('a -> bool) -> 'a list -> 'a} \\
	\hline
	\code{List.find\_all} & : & \type{('a -> bool) -> 'a list -> 'a list} \\
	\hline
\end{tabular}

У функции \code{find\_all} существует псевдоним \code{filter}.

A variant of the general search function is the partitioning of a list: 

\begin{tabular}{|c|c|c|}
	\hline
	\code{List.partition} & : & \type{('a -> bool) -> 'a list -> 'a list * 'a
list} \\
	\hline
\end{tabular}

Часто используемые функции из модуля \code{List} для разбиения или создания 
списка из списка пар:

\begin{tabular}{|c|c|c|}
	\hline
	\code{List.split} & : & \type{('a * 'b) list -> 'a list * 'b list} \\
	\hline
	\code{List.combine} & : & \type{'a list -> 'b list -> ('a * 'b) list} \\
	\hline
\end{tabular}

И наконец, часто используемая структура, совмещающая список с парой: список 
ассоциаций. Такая структура удобна когда необходимо хранить данные 
ассоциированные ключу. Она состоит из списка пар, первый элемент которой ключ, а 
второй --- связанное с этим ключом значение. Для подобных списков имеются 
следующие функции:

\begin{tabular}{|l|c|l|}
	\hline
	\code{List.assoc} & : & \type{'a -> ('a * 'b) list -> 'b} \\
	 & & извлекает информацию связанную с ключом \\
	\hline
	\code{List.mem\_assoc} & : & \type{'a -> ('a * 'b) list -> bool} \\
	 & & проверяет существование ключа \\
	\hline
	\code{List.remove\_assoc} & : & \type{'a -> ('a * 'b) list -> ('a * 'b) 
list} \\
	 & & удаляет элемент связанный с ключом \\
	\hline
\end{tabular}

У каждой из этих функций существует аналог, использующий физическое равенство 
вместо структурного: \code{List.assq}, \code{List.mem\_assq} и 
\code{List.remove\_assq}

\paragraph{Манипуляции над векторами}

Векторы, так часто используемые в императивном программировании, являются 
физически изменяемыми структурами. В модуле \code{Array} имеется функция для 
изменения значения элемента: 

\begin{tabular}{|l|c|l|}
	\hline
	\code{Array.set} & : & \type{'a array -> int -> 'a -> unit} \\
	\hline
\end{tabular}

Как и функция \code{get}, у функции \code{set} имеется укороченная запись: 
\code{t.(i) <- a}

Существует 3 функции выделения памяти под вектор: 

\begin{tabular}{|l|c|l|}
	\hline
	\code{Array.create} & : & \type{int -> 'a -> 'a array} \\
	 & & создать вектор заданного размера, все элементы которого 
инициализированы одинаковым значением \\
	\hline
	\code{Array.make} & : & \type{int -> 'a -> 'a array} \\
	 & & укороченная запись для \code{create} \\
	\hline
	\code{Array.init} & : & \type{int -> (int -> 'a) -> 'a array} \\
	 & & создать вектор заданного размера, все элементы которого 
инициализированы результатом функции от индекса инициализируемого элемента \\
	\hline
\end{tabular}

Так как матрицы это часто встречающаяся структура, в модуле \code{Array} 
имеется две функции создания матриц: 

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.create\_matrix} & : & \type{int -> int -> 'a -> 'a array array} 
\\
	\hline
	\code{Array.make\_matrix} & : & \type{int -> int -> 'a -> 'a array array} \\
	\hline
\end{tabular}

Функция \code{set} превращается в функцию изменяющую значения интервала, 
который указан индексом началом и длиной:

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.fill} & : & \type{'a array -> int -> int -> 'a -> unit} \\
	\hline
\end{tabular}

При помощи следующих функций можно скопировать целый вектор или часть вектора,
указанного началом и длиной. При этом мы получаем новую структуру:

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.copy} & : & \type{'a array -> 'a array} \\
	\hline
	\code{Array.sub} & : & \type{'a array -> int -> int -> 'a array} \\
	\hline
\end{tabular}

Копия или вырезка могут реализовываться и в существующий вектор: 

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.blit} & : & \type{'a array -> int -> 'a array -> int -> int -> 
unit} \\
	\hline
\end{tabular}

Первый целочисленных аргумент является индексом в первом векторе, второй 
аргумент --- индекс второго вектора и третий число копируемых элементов. 
Функции \code{blit}, \code{sub} и \code{fill} возбуждают исключения 
\code{Invalid\_argument}.

В связи с тем что доступ к элементам массива обычно происходит при помощи 
индекса, были определены следующие два итератора: 

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.iteri} & : & \type{(int -> 'a -> unit) -> 'a array -> unit} \\
	\hline
	\code{Array.mapi} & : & \type{(int -> 'a -> 'b) -> 'a array -> 'b array} \\
	\hline
\end{tabular}

Они применяют функцию, первый аргумент которой является индекс желаемого
элемента.

\begin{lstlisting}[language=OCaml]
#   let f i a = (string_of_int i) ^ ":" ^ (string_of_int a) in
   Array.mapi f  [| 4; 3; 2; 1; 0 |] ;;
- : string array = [|"0:4"; "1:3"; "2:2"; "3:1"; "4:0"|]
\end{lstlisting}

В модуле \code{Array} не имеется функции--аналога \code{map} для списков, 
которая бы могла изменить содержимое каждой ячейки вектора на результат функции 
от значения этой ячейки. Но мы можем получить тоже самое при помощи функции 
\code{iteri}:

\begin{lstlisting}[language=OCaml]
# let iter_and_set f t =
  Array.iteri (fun i -> fun x -> t.(i) <- f x) t ;;
val iter_and_set : ('a -> 'a) -> 'a array -> unit = <fun>
# let v = [|0;1;2;3;4|] ;;
val v : int array = [|0; 1; 2; 3; 4|]
# iter_and_set succ v ;;
- : unit = ()
# v ;;
- : int array = [|1; 2; 3; 4; 5|]
\end{lstlisting}

И наконец, модуль \code{Array} предоставляет две функции для создания списка из 
вектора и наоборот.

\begin{tabular}{|c|c|c|}
	\hline
	\code{Array.of\_list} & : & \type{'a list -> 'a array} \\
	\hline
	\code{Array.to\_list} & : & \type{'a array -> 'a list} \\
	\hline
\end{tabular}

\subsubsection{Ввод/Вывод}
\label{subsubsec:input_output}

В стандартной библиотеке имеется четыре модуля ввода--вывода

\begin{itemize}
	\item \code{Printf}: для форматированного вывода
	\item \code{Format}: для форматирования блоками с автоматической поддержкой 
переноса строки
	\item \code{Marshal}: реализует механизм постоянных (persistent) значений
	\item \code{Digest}: для создания уникальных ключей 
\end{itemize}

Детали модуля \code{Marshal} будут приведены позже в этой главе, когда мы 
займемся обработкой постоянных данных (persistent data structures) (см. 
\ref{??}).

\subsubsection{Модуль \code{Printf}}
\label{subsubsec:module_printf}

При помощи модуля \code{Printf} мы можем форматировать текст на манер функции 
\code{printf} из стандартной библиотеки языка C. Желаемый формат представлен 
строкой, которая будет обработана в соответствии со стандартами функции 
\code{printf}, то есть используя символ \code{\%}. Этот символ, если за ним 
следует буква, определяет тип данных на данной позиции. Следующая запись 
\code{"(x=\%d, y=\%d)"} означает что вместо \code{\%d} нужно вывести два целых 
числа.

\paragraph{Спецификация формата}

Формат указывает параметры для выводимой строки. Базовые типы: \type{int},
\type{float}, \type{char} и \type{string} будут преобразованы в строки и 
подставлены на их места в распечатываемой строке. В результате передачи значений 
77 и 43 формату \code{"(x=\%d, y=\%d)"} получим строку \code{"(x=77, y=43)"}. 
Основные символы, определяющие тип преобразования приведены в таблице 
\ref{tbl:conversion_conventions}.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:conversion_conventions} Символы преобразования типов}
	\begin{tabular}{|l|l|l|}
		\hline
		Тип & Символ & Результат \\
		\hline
		целое & \code{d} или \code{i} & десятичное со знаком \\
		\hline
		 & \code{u} & десятичное без знака \\
		\hline
		 & \code{x} & шестнадцатеричное без знака в нижнем регистре \\
		\hline
		 & \code{X} & то же самое в верхнем регистре \\
		\hline
		символ & \code{c} & символ \\
		\hline
		строка & \code{s} & строка \\
		\hline
		действительное & \code{f} & десятичное \\
		\hline
		 & \code{e} или \code{E} & экспоненциальная запись \\
		\hline
		 & \code{g} или \code{G} & то же самое \\
		\hline
		логический & \code{b} & \code{true} или \code{false} \\
		\hline
		специальный & \code{a} или \code{t} & функциональный параметр \\
		\hline
	 	 & & типа \type{(out\_channel -> 'a -> unit) -> 'a -> unit} \\
		\hline
	 	 & & или \type{out\_channel -> unit} \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

В формате можно так же установить выравнивание выводимых строк. Для этого 
необходимо указать размер в символах преобразования типа. Делается это так: 
между символом \% и типом преобразования вставляется число, например \%10d, 
после чего мы получаем выравнивание справа по десяти символам. Если размер 
результата превосходит размер ограничения, то это ограничение будет 
проигнорировано. Отрицательное значение реализует выравнивание слева. Для 
перевода действительных чисел стоит указать точность результата. В этом случае 
после \% вставим точку и целое число. Следующая запись \%.5f указывает, что мы 
желаем пять чисел после запятой.

Существует два специальных формата: a и t, они указывают функциональный 
аргумент. Typically, a print function defined by the user. В этом заключается 
специфичность Objective CAML.

\paragraph{Функции модуля}

Тип пяти функций модуля \code{Printf} приведён в таблице 
\ref{tbl:printf_formatting_functions}.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:printf_formatting_functions} Функции форматирования 
\code{printf}}
	\begin{tabular}{|l|l|l|}
		\hline
		\code{fprintf} & : & \type{out\_channel -> ('a, out\_channel, unit) 
format -> 'a} \\
		\hline
		\code{printf} & : & \type{('a, out\_channel, unit) format -> 'a} \\
		\hline
		\code{eprintf} & : & \type{('a, out\_channel, unit) format -> 'a} \\
		\hline
		\code{sprintf} & : & \type{('a, unit, string) format -> 'a} \\
		\hline
		\code{bprintf} & : & \type{Buffer.t -> ('a, Buffer.t, string) format -> 
'a} \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

Функции \code{fprintf} ожидает три параметра: имя канала, формат и аргументы с 
типами, описанными форматом. Функции \code{еprintf} и \code{printf} есть 
специализированные версии для стандартного выхода и стандартного выхода ошибок. 
И наконец, \code{sprintf} и \code{bprintf} не выводят результат на экран, а 
записывают его в строку.

Вот несколько примеров использования различных форматов: 

\begin{lstlisting}[language=OCaml]
# Printf.printf "(x=%d, y=%d)" 34 78 ;;
(x=34, y=78)- : unit = ()
# Printf.printf "name = %s, age = %d" "Patricia" 18 ;;
name = Patricia, age = 18- : unit = ()
# let s = Printf.sprintf "%10.5f\n%10.5f\n" (-.12.24) (2.30000008) ;;
val s : string = " -12.24000\n   2.30000\n"
# print_string s ;;
-12.24000
   2.30000
- : unit = ()
\end{lstlisting}

В следующем примере, создадим функцию для распечатки матрицы вещественных чисел 
в заданном формате:

\begin{lstlisting}[language=OCaml]
# let print_mat m = 
   Printf.printf "\n" ;
   for i=0 to (Array.length m)-1 do
     for j=0 to (Array.length m.(0))-1 do   
       Printf.printf "%10.3f" m.(i).(j)
     done ;
     Printf.printf "\n"
   done ;;    
val print_mat : float array array -> unit = <fun>
# print_mat (Array.create 4  [| 1.2; -.44.22; 35.2 |]) ;;

     1.200   -44.220    35.200
     1.200   -44.220    35.200
     1.200   -44.220    35.200
     1.200   -44.220    35.200
- : unit = ()
\end{lstlisting}

\paragraph{Замечания по типу формата}

Описание формата задаётся в виде символьной строки, но оно не является типом 
\code{string}. При распознавании формата создаётся значение с типом 
\code{format}, в котором параметр \type{'a} реализуется либо в \code{unit}, 
если формат не указывает параметр, либо в функциональный тип, который 
соответствует функции с нужным количеством аргументов и возвращающей значение 
\code{unit}.

Проиллюстрируем это на примере, частично применив функцию к формату.

\begin{lstlisting}[language=OCaml]
# let p3 = 
   Printf.printf "begin\n%d is val1\n%s is val2\n%f is val3\n" ;;
begin
val p3 : int -> string -> float -> unit = <fun>
\end{lstlisting}

Таким образом мы получили функцию ожидающую три аргумента. Заметьте, что слово 
\enq{begin} уже было выведено. Другой формат приводит к созданию функции 
другого типа.

\begin{lstlisting}[language=OCaml]
# let p2 = 
   Printf.printf "begin\n%f is val1\n%s is val2\n";;
begin
val p2 : float -> string -> unit = <fun>
\end{lstlisting}

Передавая аргументы, одни за одним функции \code{p3} получим постепенный 
результат:

\begin{lstlisting}[language=OCaml]
# let p31 = p3 45 ;;
45 is val1
val p31 : string -> float -> unit = <fun>
# let p32 = p31 "hello" ;;
hello is val2
val p32 : float -> unit = <fun>
# let p33 = p32 3.14 ;;
3.140000 is val3
val p33 : unit = ()
# p33 ;;
- : unit = ()
\end{lstlisting}

Последнее получено значение ничего не выводит, оно возвращает значение
\code{()} типа \type{unit}.

Мы не сможем создать значение \code{format} используя значения типа
\type{string}:

\begin{lstlisting}[language=OCaml]
# let f d =
  Printf.printf (d^d);;
Characters 27-30:
This expression has type string but is here used with type
  ('a, out_channel, unit) format
\end{lstlisting}

Компилятор не знает значение строки, переданной в аргументе, в следствии чего он 
не знает тип который реализует параметр \code{'a} типа \type{format}.

С другой стороны, строки символов являются физически изменяемым типом, то есть 
мы можем поменять \type{\%d} на другую букву, таким образом динамически 
изменить формат вывода. Это не совместимо со статической генерацией функции 
перевода.

\subsubsection{Модуль \code{Digest}}
\label{subsubsec:module_digest}

Из символьной строки, какого угодно размера, хэш функции возвращает строку 
фиксированного размера, чаще всего меньшего размера. Такие функции возвращают 
отпечаток (digest).

Такие функции используются для создания хэш таблиц, как на пример модуль 
\code{Hashtbl}, позволяющий проверить присутствует ли определённый элемент в 
таблице прямым доступом (direct access) используя отпечаток. Например, функция 
\code{f\_mod\_n} подсчитывает остаток от деления суммы кодов символов ASCII 
строки на n и является хэш функция. Если мы создадим таблицу размером n, то 
благодаря отпечаткам получим прямой доступ к элементам. Однако, две строки могут 
иметь одинаковый отпечаток. В случае подобных коллизий, в хэш таблицу 
добавляется дополнительное \enq{хранилище} для хранения таких элементов. Когда 
таких коллизий становится много, доступ к таблице становится малоэффективным. 
Если \code{n} --- размер отпечатка \code{a}, тогда вероятность возникновения 
коллизий между двумя разными строка равна $1/2^n$.

Вероятность возникновения коллизий у non--reversible хэш функции очень мала, 
таким образом трудно подобрать строку к конкретному отпечатку. Конечно, функция 
\code{f\_mod\_n} таковой не является. Таким образом non--reversible хэш функции 
позволяют идентифицировать (authentification) символьную строку полученную по 
Интернету, файл, и т.д.

Модуль \code{Digest} использует алгоритм MD5, как аббревиатура Message Digest 
5. Размер возвращаемого отпечатка 128 бит. Несмотря на то, что алгоритм 
свободно доступен, на сегодняшний день невозможно создать строку имея отпечаток. 
В этом модуле определён тип \type{Digest.t} как аббревиатура {\it string}. В 
таблице \ref{tbl:functions_of_the_digest_module} приведены основные функции 
этого модуля.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:functions_of_the_digest_module} Функции модуля 
\code{Digest}}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{string} & : & \type{string -> t} \\
		& & возвращает отпечаток строки \\
		\hline
		\code{file} & : & \type{string -> t} \\
		& & возвращает отпечаток файла \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

В следующем примере мы используем функцию \code{string} на небольшой строке и
на большой строке, построенной из первой. Заметьте, что размер отпечатка
остаётся такой же:

\begin{lstlisting}[language=OCaml]
# let s = "The small cat is dead...";;
val s : string = "The small cat is dead..."
# Digest.string s;;
- : Digest.t = "xr6\127\171(\134=\238`\252F\028\t\210$"

# let r = ref s in
   for i=1 to 100 do r:= s^ !r done;
   Digest.string !r;;
- : Digest.t = "\232\197|C]\137\180{>\224QX\155\131D\225"
\end{lstlisting}

Применяя отпечатки программ, мы тем самым гарантируем, что версия используемой 
программы правильная. К примеру, во время динамической загрузки кода (см. 
\ref{??}), используются отпечатки для загрузки файла с байт--кодом.

\begin{lstlisting}[language=OCaml]
# Digest.file "basic.ml" ;;
- : Digest.t = "\179\026\191\137\157Ly|^w7\183\164:\167q"
\end{lstlisting}

\subsection{Persistence}
\label{subsec:persistence}

Сохраняемость это способность сохранять значения переменных когда программа не 
выполняется. Примером может служить сохранение переменных в файле. Эта 
переменная доступная любой программе, которая может читать этот файл. Чтение и 
запись сохраняемого значения требует определённый формат данных. Необходимо 
определить способ сохранения сложной структуры в памяти компьютера, например 
дерева, в линейную структуру --- последовательность байтов в файле. По этой 
причине кодировка сохраняемых значений называется линеаризацией \footnote{В JAVA 
используется термин сериализация}.

\subsubsection{Реализация и трудности линеаризации}
\label{subsubsec:realization_and_difficulties_of_linearization}

При реализации механизма линеаризации данных необходимо сделать определённый 
выбор и встречаются следующие трудности:

\begin{description}
	\item[чтение запись структур данных] Память компьютера может быть 
рассмотрена как вектор байтов, тогда значение  можно представить как часть 
памяти которое оно занимает. В этом случае мы можем  сжать значение, сохранив 
лишь полезную часть.

	\item[разделение или копия] При линеаризации данных нужно ли сохранять 
разделение (sharing). Типичный случай --- бинарное дерево, у которого имеется 
два одинаковых (в физическом смысле) узла, здесь мы можем указать для второго 
узла, что он уже сохранен. Это свойство влияет на размер сохраняемых данных и на 
затраченное время. On the other hand, in the presence of physically modifiable 
values, this could change the behavior of this value after a recovery depending 
on whether or not sharing was conserved.

	\item[циклические структуры] В подобном случае, линеаризация без разделения 
рискует зациклиться. Таким образом необходимо сохранить это разделение. 
функциональные значения.

	\item[циклические структуры] Функциональные значения, или замыкания, состоят 
из двух частей: окружения и кода. Часть кода состоит из адреса по которому 
находится код. Что в данном случае происходит с кодом? Мы конечно можем 
сохранить этот адрес, но в этом случае только та же программа сможет правильно 
распознать этот адрес. Мы так же можем сохранить последовательность инструкций 
этой функции, однако нам будет необходим механизм динамической загрузки кода.

	\item[гарантия типа при загрузке] В этом заключается основная трудность 
данного механизма. Статическая типизация гарантирует что значения не создадут 
ошибок типа во время выполнения, но это касается лишь значений принадлежащих 
исполняющейся программе. Какой тип нужно дать внешнему, по отношению к 
программе, значению, которое не было проверено анализатором типов. Лишь только 
для того чтобы, прочитанное значение имело мономорфный тип сгенерированный 
компилятором, необходима передача этого значения в момент сохранения и проверка 
в момент чтения.
\end{description}

\subsubsection{Модуль \code{Marshal}}
\label{subsubsec:module_marshal}

Механизм линеаризации модуля \code{Marshal} предоставляет нам выбор: сохранить 
или нет разделение для обрабатываемых значений. Он так же умеет обращаться с 
замыканиями, но здесь сохраняется лишь указатель на адрес по которому находится 
код.

Этот модуль состоит в основном из функций линеаризации в какой--нибудь канал 
либо строку и функции получающие данные из канала или строки. Функции 
линеаризации параметризуются. У следующего типа может быть два возможных случая:

\begin{lstlisting}[language=OCaml]
type external_flag = 
  No_sharing
| Closures;;
\end{lstlisting}

Константный конструктор \code{No\_sharing} указывает что разделение значений не 
должно быть сохранено, так как по умолчанию разделение сохраняется. Конструктор 
\code{Closures} необходим когда мы имеем дело с замыканиями, в этом случае 
сохраняется указатель на код. Если этот конструктор отсутствует и мы попытаемся 
сохранить функциональное значение, то будет возбуждено исключение.

{\it \bf Warning}

Конструктор \code{Closures} не может использоваться в интерактивном режиме, а 
лишь в командной строке. Функции записи и чтения данного модуля приведённые в 
таблице \ref{tbl:functions_of_the_marshal_module}

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:functions_of_the_marshal_module} Функции модуля 
\code{Marshal}}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{to\_channel} & : & \type{out\_channel -> 'a -> extern\_flag list 
-> unit} \\
		\hline
		\code{to\_string} & : & \type{'a -> extern\_flag list -> string} \\
		\hline
		\code{to\_buffer} & : & \type{string -> int -> int -> 'a -> 
extern\_flag list -> unit} \\
		\hline
		\code{from\_channel} & : & \type{in\_channel -> 'a} \\
		\hline
		\code{from\_string} & : & \type{string -> int -> 'a} \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

У функции \code{to\_channel} три аргумента: выходной канал, значение и список 
опций, она записывает переданное значение в указанный канал. Функция 
\code{to\_string} создаёт строку, которая соответствует линеаризации указанного 
значения, тогда как \code{to\_buffer} делает то же самое, изменяя часть строки 
переданной в аргументе. Функция \code{from\_channel} возвращает прочитанное из 
канала линеаризованное значение. У функции \code{from\_string} два аргумента: 
строка из которой необходимо прочитать значение и позиция в строке с которого 
начинается это значение. В файле или строке можно сохранить Несколько 
линеаризованных значений. В первом случае такие значения читаются 
последовательно,во втором достаточно указать правильный отступ от начала строки, 
чтобы прочитать необходимое значение.

\begin{lstlisting}[language=OCaml]
# let s = Marshal.to_string [1;2;3;4] [] in String.sub s 0 10;;
- : string = "\132\149\166\190\000\000\000\t\000\000"
\end{lstlisting}

{\it \bf Warning}

Использование данного модуля приводит к потере гарантии статической типизации 
(см. \ref{??})

При перечитывании сохраняемого объекта получаем значение неопределённого типа:

\begin{lstlisting}[language=OCaml]
# let x = Marshal.from_string (Marshal.to_string [1; 2; 3; 4] []) 0;;
val x : '_a = <poly>
\end{lstlisting}

Эта неопределённость отмечена в Objective CAML переменной нестрого типа 
\type{'\_a}. Поэтому желательно указать ожидаемый тип:

\begin{lstlisting}[language=OCaml]
# let l = 
   let s = (Marshal.to_string [1; 2; 3; 4] []) in 
     (Marshal.from_string s 0 : int list) ;;
val l : int list = [1; 2; 3; 4]
\end{lstlisting}

На странице \ref{??} мы вернёмся к этому моменту. 

Замечание

Функция \code{output\_value} подгружаемой библиотеки соответствует вызову 
\code{to\_channel} с пустым списком опций. Функция \code{input\_value} модуля 
\code{Pervasives} вызывает функцию \code{from\_channel}. Они сохранены для 
совместимости со старыми программами.

\subsubsection{Пример: сохранение экрана}
\label{subsubsec:example_backup_screens}

Наша задача --- сохранить bitmap всего экрана в виде матрицы цветов. Функция 
\code{save\_screen} забирает \code{bitmap}, конвертирует его в вектор цветов и 
сохраняет в файле, имя которого преданно функции.

\begin{lstlisting}[language=OCaml]
# let save_screen name = 
  let i = Graphics.get_image 0 0 (Graphics.size_x ()) 
                                 (Graphics.size_y ())  in 
   let j = Graphics.dump_image i in 
   let oc = open_out name in 
     output_value oc j;
     close_out oc;;
val save_screen : string -> unit = <fun>
\end{lstlisting}

Функция \code{load\_screen} выполняет обратную операцию; открывает файл, имя 
которого указанно, считывает сохранённые данные, конвертирует полученную 
матрицу цветов в bitmap и затем рисует на экране.

\begin{lstlisting}[language=OCaml]
# let load_screen name = 
   let ic = open_in name in 
   let image = ((input_value ic) : Graphics.color array array) in
     close_in ic;
     Graphics.close_graph();
     Graphics.open_graph (" "^(string_of_int(Array.length image.(0)))
                        ^"x"^(string_of_int(Array.length image)));
    let image2 = Graphics.make_image image in 
      Graphics.draw_image image2 0 0; image2 ;;
val load_screen : string -> Graphics.image = <fun>
\end{lstlisting}

{\it \bf Warning}

Значения абстрактных типов не могут быть сохраняемыми.

По этой причине в предыдущем примере не используется абстрактный тип 
\code{Graphics.image}, а конкретный тип \type{color array array}. Абстракция 
типов обсуждается в главе \ref{??}.

\subsubsection{Разделение}
\label{subsubsec:sharing}

Потеря данного свойства для значения может порой привести к тому что оно станет 
неиспользуемым. Вернёмся к примеру генератора символов на 
\ref{subsec:closures_and_side_effects}. Пусть нам необходимо сохранить 
функциональные значения \code{new\_s} и \code{reset\_s}, для того чтобы снова 
получить значения этих счётчиков. Напишем следующий код:

\begin{lstlisting}[language=OCaml]
# let reset_s,new_s = 
   let c = ref 0 in 
   ( function () -> c := 0 ) ,
   ( function s ->  c:=!c+1; s^(string_of_int !c) ) ;;

# let save = 
   Marshal.to_string (new_s,reset_s) [Marshal.Closures;Marshal.No_sharing] ;;

# let (new_s1,reset_s1) = 
  (Marshal.from_string save 0 : ((string -> string ) * (unit -> unit))) ;;

# (* 1 *)
 Printf.printf "new_s : \%s\n" (new_s "X"); 
 Printf.printf "new_s : \%s\n" (new_s "X");
 (* 2 *)
 Printf.printf "new_s1 : \%s\n" (new_s1 "X"); 
 (* 3 *)
 reset_s1(); 
 Printf.printf "new_s1 (after reset_s1) : \%s\n" (new_s1 "X") ;;
Characters 148-154:
Unbound value new_s1
\end{lstlisting}

Первые два вывода \code{(* 1 *)} выводят правильный результат. Вывод \code{(* 2 
*)}, после прочтения замыкания тоже кажется корректным (после \code{X2} следует 
\code{X3}). Но на самом деле разделение счётчика \code{c} между функциями 
\code{new\_s1} \code{reset\_s1} утеряно. Об этом мы можем судить по выводу 
\code{X4}, несмотря на то что мы обнулили перед этим счётчик. Каждое из 
замыканий имеет свой собственный счётчик и вызов \code{reset\_s1} не 
инициализирует счётчик \code{new\_s1}. То есть мы не должны были указывать опцию 
\code{No\_sharing} во время линеаризации.

Чаще всего необходимо сохранять разделение. Однако, там где важна скорость 
выполнения отсутствие разделения ускоряет сохранение значений. В следующем 
примере функция копирует матрицу. В данном случае желательно избавится от 
разделения.

\begin{lstlisting}[language=OCaml]
# let copy_mat_f (m : float array array) = 
  let s = Marshal.to_string m [Marshal.No_sharing] in 
    (Marshal.from_string s 0 : float array array);;
val copy_mat_f : float array array -> float array array = <fun>
\end{lstlisting}

Мы можем воспользоваться этой функцией для создания матрицы без разделения:

\begin{lstlisting}[language=OCaml]
# let create_mat_f n m v = 
   let m = Array.create n (Array.create m v) in 
     copy_mat_f m;;
val create_mat_f : int -> int -> float -> float array array = <fun>
# let a = create_mat_f 3 4 3.14;;
val a : float array array =
  [|[|3.14; 3.14; 3.14; 3.14|]; [|3.14; 3.14; 3.14; 3.14|];
    [|3.14; 3.14; 3.14; 3.14|]|]
# a.(1).(2) <- 6.28;;
- : unit = ()
# a;;
- : float array array =
[|[|3.14; 3.14; 3.14; 3.14|]; [|3.14; 3.14; 6.28; 3.14|];
  [|3.14; 3.14; 3.14; 3.14|]|]
\end{lstlisting}

Поведение этой функции больше сходит на \code{Array.create\_matrix} чем 
\code{Array.create}.

\subsubsection{Размер значений}
\label{subsubsec:size_of_values}

Порой необходимо бывает знать размер сохраняемого значения. Если разделение 
сохранено, то указанный размер достаточно точно отображает информацию. Хоть 
кодировка порой оптимизирует размер непосредственных 2 (или элементарных) 
значений, информация о размере их кодировки позволяет нам сравнить различные 
реализации структур данных. С другой стороны, для программ, которые выполняются 
без остановки, как во встроенных системах или даже серверах, просмотр размер 
структур данных помогает отловить утечки памяти. Две функции для вычисления 
размера и константа модуля \code{Marshal} описаны в таблице 
\ref{tbl:size_functions_of_the_marshal_module}.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:size_functions_of_the_marshal_module} Функции полученя 
размеров в модуле \code{Marshal}}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{theader\_size} & : & \type{int} \\
		\hline
		\code{header\_size} & : & \type{int} \\
		\hline
		\code{total\_size} & : & \type{string -> int -> int} \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

Размер сохраняемого значения есть сумма размера его данных и размер заголовка.

В следующем примере мы приводим сравнение двух бинарных деревьев при помощи 
функции MD5:

\begin{lstlisting}[language=OCaml]
# let size x = Marshal.data_size (Marshal.to_string x []) 0;;
val size : 'a -> int = <fun>
# type 'a bintree1 = Empty1 | Node1 of 'a * 'a bintree1 * 'a bintree1 ;;
type 'a bintree1 = | Empty1 | Node1 of 'a * 'a bintree1 * 'a bintree1
# let s1 = 
  Node1(2, Node1(1, Node1(0, Empty1, Empty1), Empty1), 
           Node1(3, Empty1, Empty1)) ;;
val s1 : int bintree1 =
  Node1
   (2, Node1 (1, Node1 (0, Empty1, Empty1), Empty1),
    Node1 (3, Empty1, Empty1))
# type 'a bintree2 = 
  Empty2 | Leaf2 of 'a | Node2 of 'a * 'a bintree2 * 'a bintree2 ;;
type 'a bintree2 =
  | Empty2
  | Leaf2 of 'a
  | Node2 of 'a * 'a bintree2 * 'a bintree2
# let s2 =
  Node2(2, Node2(1, Leaf2 0, Empty2), Leaf2 3) ;;
val s2 : int bintree2 = Node2 (2, Node2 (1, Leaf2 0, Empty2), Leaf2 3)
# let s1, s2 = size s1, size s2 ;;
val s1 : int = 13
val s2 : int = 9
\end{lstlisting}

Полученные при помощи функции \code{size} значения совпадают с предполагаемым 
размером деревьев \code{s1} и \code{s2}.

\subsubsection{Проблемы типизации}
\label{subsubsec:typing_problem}

Действительной проблемой сохраняемых значений является возможность нарушить 
механизм типизации Objective CAML. Функции записи создают правильный мономорфный 
тип: \type{unit} и \type{string}. Тогда как функции чтения возвращают 
полиморфный тип \type{'a}. С таким сохраняемым значением мы можем сделать что 
угодно. Вот самый худший вариант (см. гл. \ref{chpt:functional_programming} на 
\ref{sec:polymorphism_and_return_values_of_functions}): создание функции 
\code{magic\_copy} с типом \type{'a -> 'b}.

\begin{lstlisting}[language=OCaml]
# let magic_copy a = 
  let s = Marshal.to_string a [Marshal.Closures] in 
    Marshal.from_string s 0;;
val magic_copy : 'a -> 'b = <fun>
\end{lstlisting}

Использование подобной функции приведёт к аварийной остановке программы:

\begin{lstlisting}[language=OCaml]
#  (magic_copy 3 : float) +. 3.1;;
Segmentation fault
\end{lstlisting}

В интерактивной среде (в Линукс) текущая сессия заканчивается с сообщением об 
ошибке памяти.

\subsection{Системный интерфейс}
\label{subsec:interface_with_the_system}

В стандартной библиотеке содержится 6 модулей системного интерфейса:

\begin{itemize}
	\item модуль \code{Sys}: для взаимодействия программы с системой

	\item модуль \code{Arg}: для анализа переданных программе аргументов

	\item модуль \code{Filename}: для перемещения по каталогам (независимо от 
операционной системы)

	\item модуль \code{Printexc}: для перехвата и вывода исключений

	\item модуль \code{Gc}: для контроля автоматического сборщика памяти, 
который будет описан в главе \ref{??}

	\item модуль Callback: для вызова функций Objective CAML в программе на C, 
об этом читайте в главе \ref{??}.
\end{itemize}

Описание четырёх первых модулей приведено ниже.

\subsubsection{Модуль \code{Sys}}
\label{subsubsec:module_sys}

Данный модуль содержит полезные функции для взаимодействия с операционной 
системой, а так же для обработки сигналов, полученных программой. В таблице 
\ref{tbl:information_about_the_system} приведены значения содержащие информацию 
о системе.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:information_about_the_system} Данные об операционной 
системе}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{OS\_type} & : & \type{string} \\
		& & тип системы \\
		\hline
		\code{interactive} & : & \type{bool ref} \\
		& & истина, если интерактивный режим \\
		\hline
		\code{word\_size} & : & \type{string} \\
		& & размер слова (32 или 64 бита) \\
		\hline
		\code{max\_string\_length} & : & \type{int} \\
		& & максимальный размер символьной строки \\
		\hline
		\code{max\_array\_length} & : & \type{int} \\
		& & максимальный размер вектора \\
		\hline
		\code{time} & : & \type{unit -> float} \\
		& & время в секундах, истекшее с начала выполнения программы \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

Связь между программой и операционной системой осуществляется через командную 
строку, переменную окружения и запуском другой программы. Эти функции описаны в 
таблице \ref{tbl:communication_with_the_system}.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:communication_with_the_system} Связь с операционной 
системой}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{argv} & : & \type{string array} \\
		& & содержит вектор параметров \\
		\hline
		\code{getenv} & : & \type{string -> string} \\
		& & получить значение переменной окружения \\
		\hline
		\code{command} & : & \type{string -> int} \\
		& & выполнения команды с указанным именем \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

При помощи Функции в таблице \ref{tbl:file_manipulation} можно 
\enq{использовать} файловую систему.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:file_manipulation} Операции с файловой 
системой}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{file\_exists} & : & \type{string -> bool} \\
		& & возвращает истина, если файл существует \\
		\hline
		\code{remove} & : & \type{string -> unit} \\
		& & удалить файл \\
		\hline
		\code{rename} & : & \type{string -> string -> unit} \\
		& & переименовать файл \\
		\hline
		\code{chdir} & : & \type{string -> unit} \\
		& & сменить текущий каталог \\
		\hline
		\code{getcwd} & : & \type{unit -> string} \\
		& & вернуть имя текущего каталога \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

Обработка сигналов будет описано в специальной главе о системном 
программировании \ref{??}.

Напишем следующую программу, в ней мы вновь вернёмся к примеру с сохранением 
графического окна в виде вектора цветов. Функция \code{main} проверяет не 
запущена ли она в интерактивном режиме, затем считывает имена файлов в командной 
строке, проверяет существуют ли они и затем выводит их на экран (при помощи 
функции \code{load\_screen}). Между двумя выводами, мы вставляем ожидание 
нажатия на клавишу.

\begin{lstlisting}[language=OCaml]
# let main () =
   if not (!Sys.interactive) then 
     for i = 0 to Array.length(Sys.argv) -1 do 
       let name = Sys.argv.(i) in 
         if Sys.file_exists name then 
         begin
           ignore(load_screen name);
           ignore(Graphics.read_key)
         end
     done;;
val main : unit -> unit = <fun>
\end{lstlisting}

\subsubsection{Модуль \code{Arg}}
\label{subsubsec:module_arg}

Модуль \code{Arg} определяет синтаксис для анализа аргументов командной строки. 
В нем имеется функция для синтаксического анализа, а так же определение 
действия, которое будет связано с анализируемым элементом.

Элементы командой строки разделены между собой одним или несколькими пробелами. 
Все они хранятся в векторе \code{Sys.argv}. В синтаксисе определённом 
\code{Sys.argv} некоторые элементы начинаются знаком минус ('-'). Такие 
элементы называются ключевыми словами командной строки. Ключевым словам можно 
привязать определённое действие, которое ожидает аргумент с типом 
\type{string}, \type{int} или \type{float}. Значения аргументов инициализируются 
значениями командной строки, которые непосредственно следуют за ключевым словом. 
В таком случае вызывается функция перевода значения из строки в ожидаемый тип 
данных. Другие аргументы командной строки называются анонимными. Им 
ассоциируется общее действие, которое принимает их значение в виде аргумента. 
Если указана неопределённая опция, то на экран выводится небольшая помощь, 
которая определяется пользователем.

Действия, связанные с ключевыми словами определены следующим типом:

\begin{lstlisting}[language=OCaml]
type spec =
  | Unit of (unit -> unit)     (* Call the function with unit argument*)
  | Set of bool ref            (* Set the reference to true*)
  | Clear of bool ref          (* Set the reference to false*)
  | String of (string -> unit) (* Call the function with a string 
                                argument *)
  | Int of (int -> unit)       (* Call the function with an int 
                                argument *)
  | Float of (float -> unit)   (* Call the function with a float 
                                argument *)
  | Rest of (string -> unit)   (* Stop interpreting keywords and call the
                                function with each remaining argument*)
\end{lstlisting}

Для анализа командной строки существует следующая функция:

\begin{lstlisting}[language=OCaml]
# Arg.parse ;;
- : (string * Arg.spec * string) list -> (string -> unit) -> string -> unit =
<fun>
\end{lstlisting}

Первым аргументом является список кортежей формы (\code{key}, \code{spec}, 
\code{doc}), где: 

\begin{itemize}
	\item \type{key} есть строка соответствующая ключевому слову. Эта стока 
начинается со специального символа '\_'

	\item \type{spec} есть значение типа \type{spec}, которое ассоциирует 
действие ключу \type{key}

	\item \type{doc} есть символьная строка, содержащая описание опции 
\type{key}. Она выводится в случае синтаксической ошибки.
\end{itemize}

вторым аргументом передаётся функция обработки анонимных аргументов командной 
строки. Последним аргументом является строка, которая выводится в заголовке 
помощи.

В модуле \code{Arg} имеется так же:

\begin{itemize}
	\item \code{Bad}: исключение с входным аргументом типа строка. Оно может 
быть использовано обрабатывающими функциями. 

	\item \code{usage} : типа \type{(string * Arg.spec * string) list -> string 
-> unit}. Эта функция выводит подсказку об использовании программы. Желательно 
ей передавать те же самые аргументы что и для \code{parse}

	\item \code{current}: типа \type{int ref}. Содержит ссылку на текущее 
значение индекса вектора \code{Sys.argv}. Это значение может быть изменено при 
необходимости. 
\end{itemize}

Примера ради, напишем функцию \code{read\_args}, которая инициализирует игру 
\enq{Сапёр}, представленную в главе \ref{sec:minesweeper}. Возможные опции будут 
следующими: \code{-col}, \code{-lin} и \code{-min}. За ними буду следовать 
целые числа, указывающие число столбцов, число линий и число мин соответственно. 
Эти значения не должны быть меньше значений по умолчанию: 10,10 и 15.

Для этого создадим три функции обработки:

\begin{lstlisting}[language=OCaml]
# let set_nbcols cf n = cf := {!cf with nbcols = n} ;;
# let set_nbrows cf n = cf := {!cf with nbrows = n} ;;
# let set_nbmines cf n = cf := {!cf with nbmines = n} ;;
\end{lstlisting}

У всех этих функций одинаковый тип: \type{config ref -> int -> unit}. Функции 
анализа командной строки можно написать следующим образом:

\begin{lstlisting}[language=OCaml]
# let read_args() =
  let cf = ref default_config in
  let speclist = 
   [("-col", Arg.Int (set_nbcols cf), "number of columns (>=10)");
    ("-lin", Arg.Int (set_nbrows cf), "number of lines (>=10)");
    ("-min", Arg.Int (set_nbmines cf), "number of mines (>=15)")]
  in   
  let usage_msg = "usage : minesweep [-col n] [-lin n] [-min n]" in
   Arg.parse speclist (fun s -> ()) usage_msg; !cf ;;
val read_args : unit -> config = <fun>
\end{lstlisting}

При помощи переданных параметров эта функция вычисляет конфигурацию, которая 
затем будет передана функции открывающей графическое окно \code{open\_wcf} при 
запуске игры. Каждая из опций, не является обязательной, как на то указывает 
само слово опция. Если одна из них отсутствует в командной строки, то будет 
использоваться значение по умолчанию. Порядок опций не имеет значений.

\subsubsection{Модуль \code{Filename}}
\label{subsubsec:module_filename}

В модуле \code{Filename} реализованы операции по доступу к файловой системе, 
независимо от операционной системы. Правила по которым называются имена в 
Windows, Unix и MacOS сильно различаются.

\subsubsection{Модуль \code{Printexc}}
\label{subsubsec:module_printexc}

Этом совсем небольшой модуле из трёх функций (таблица 
\ref{tbl:handling_exceptions}) предоставляет нам сборщик исключений. Он очень 
удобен, особенно для программ запускаемых с командной строки 3, чтобы быть 
уверенным в том что ни одно исключение не будет упущено и это не приведёт к 
остановке программы.

\begin{table}[hl]
	\begin{center}
	\caption{\label{tbl:handling_exceptions} Сборщик исключений}
	\begin{tabular}{|l|c|l|}
		\hline
		\code{catch} & : & \type{('a -> 'b) -> 'a -> 'b} \\
		& & сборщик исключений \\
		\hline
		\code{print} & : & \type{('a -> 'b) -> 'a -> 'b} \\
		& & вывести и перевозбудить исключение \\
		\hline
		\code{to\_string} & : & \type{exn -> string} \\
		& & перевести исключение в строку \\
		\hline
	\end{tabular}
	\end{center}
\end{table}

Функция \code{catch} применяет свой первый аргумент ко второму, это приведёт к 
запуску основной функции программы. Если исключение будет возбуждено на уровне 
\code{catch}, то есть не выловленное внутри программы, то \code{catch} выведет 
своё имя и прекратит программу. Функция \code{print} ведёт себя схожим образом, 
с разницей в том что после вывода на экран она снова возбуждает исключение. И 
наконец функция \code{to\_string} переводит исключение в строку символов. Она 
используется двумя предыдущими функциями. Если бы мы переписывали программу 
просмотра \code{bitmap}, то мы бы скрыли функцию \code{main} внутри функции 
\code{go}:

\begin{lstlisting}[language=OCaml]
# let go () = 
   Printexc.catch main ();;
val go : unit -> unit = <fun>
\end{lstlisting}

Это позволит нормально закончить программу и вывести при этом значение 
неотловленного исключения.
