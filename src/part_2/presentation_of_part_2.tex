\section*{Содержимое второй части}

Представленные здесь компоненты окружения являются частью дистрибутива Objective
CAML. Это различные компиляторы, многочисленные библиотеки, средства анализа
программы, средства лексического и синтаксического анализа и интерфейса с языком
C.

Objective CAML является компилируемым языком, с двумя способами генерации кода:

\begin{itemize}
	\item byte-code выполняемый виртуальной машиной

	\item нативный код, выполняемый напрямую процессором
\end{itemize}

Интерактивный цикл Objective CAML использует byte-code для выполнения введённых
фраз. Он является первейшим средством помощи при разработке. Интерактивный цикл
позволяет типизировать, компилировать и быстро проверять определения функций. К
тому же он выдаёт значения входных аргументов и возврата функций.

Другие привычные средства разработки входят в дистрибутив: вычисление
зависимостей между файлами, отладка и профилирование. При помощи
средств отладки программы мы можем пошагово выполнять программы, устанавливать
метки остановки и просмотреть значения переменных. Средство анализа выдаёт число
вызовов функций, время затраченное на вызов функции или на выполнение
определённой части кода. Последние два инструмента доступны только на платформах
Unix.

Богатство языка происходит не только из его ядра, но и из различных
библиотек; множество повторно используемых программ, входящих в дистрибутив
языка. Objective CAML тому пример. Графическая библиотека, включённая в
дистрибутив, уже не раз упоминалась. Далее в книге, мы опишем немало новых
библиотек. Они вносят большое число новых возможностей, однако обратной стороной
медали являются некоторые трудности, в особенности в строгости типов.

Какой бы не была богатой библиотека, всегда необходимо уметь связывается с
другим языком программирования. Дистрибутив языка Objective CAML содержит все
необходимое для интерфейса с языком C. То есть мы можем вызывать функции C в
коде Objective CAML и наоборот. Разница в управлении памятью в Objective CAML и
C может стать препятствием в понимании и использовании этого интерфейса. Эта
разница заключается в том, что в Objective CAML имеется автоматический сборщик
мусора.

И в C и в Objective CAML мы можем динамически выделять память и таким образом
достаточно гибко управлять пространством в соответствии с нуждами программы.
Естественно, это имеет смысл лишь если мы можем затем высвободить память для
других нужд выполнения программы. Автоматический сборщик освобождает
программиста от этой задачи, которая является частым источником ошибок и берет
на себя управление сборкой памяти. Эта особенность является одним из элементов
надёжности языка Objective CAML.

Однако, данный механизм отражается (влияет?) на представление данных. То есть
для того, чтобы правильно связывать код на Objective CAML и C, необходимо чётко
представлять себе принципы управления памятью.

В 6 главе мы рассмотрим базовые элементы системы Objective CAML: виртуальная
машина, компиляторы и библиотеки. Здесь мы так же затронем различные методы
компиляции и сравним переносимость с эффективностью.

В 7 даётся глобальный обзор множества типов, функций и исключений, поставляемых
с дистрибутивом. Однако, она не заменяет официального руководства, в котором
подробно описаны эти библиотеки. Но здесь мы рассматриваются новые возможности
предоставляемые некоторыми модуля библиотек. В частности, можно привести пример
форматированного вывода, системный интерфейс и persistence of values

В 8 представлены различные методы автоматической сборки мусора, а затем описан
принцип, используемый сборщиком Objective CAML.

В 9 мы рассмотрим способы отладки программ Objective CAML. Не смотря на
некоторые недостатки, при помощи этих средств можно легко обнаружить проблемное
место программы.

В 10 описываются некоторые проблемы лексического и синтаксического анализа
языка: библиотека регулярный выражений, средства ocamlex и ocamlyacc,
использование потоков (stream).

Сюжет 11 главы — интерфейс с языком C. На сегодня, язык программирования не
может быть полностью изолированным от других. При помощи данного интерфейса,
программы на Objective CAML могут вызвать функцию на C и передать ей значения
Objective CAML и наоборот. Основное затруднение интерфейса заключается в модели
памяти. По этой причине, желательно прочитать главу 8.

В 12 представлены два приложения: обогащённая графическая библиотека, основанная
на иерархической структуре, как AWT2 JAVA, классическая программа поиска пути в
графе с наименьшей стоимостью с новым графическим интерфейсом и кэш--памятью.