\section{Функциональное ядро Objective CAML}
\label{sec:caml_kernel}

Как любой другой язык функционального программирования, Objective CAML --- это
язык выражений, состоящий в основном из создания функций и их применения.
Результатом вычисления одного из таких выражений является значение данного языка
(value in the language) и выполнение программы заключается в вычислении всех
выражений из которых она состоит.

\subsection{Значения, функции и базовые типы}
\label{sec:values_funcs_base_types}

В Objective CAML определены следующие типы: целые числа, числа с плавающей
запятой, символьный, строковый и логический.

\subsubsection{Числа}

Различают целые \texttt{int} и числа с плавающей запятой \texttt{float}.
Objective CAML следует спецификации IEEE 754 для представления чисел с плавающей
запятой двойной точности. Операции с этими числами описаны в таблице
\ref{tbl:operations_on_numbers}. Если результат целочисленной операции выходит
за интервал значений типа \texttt{int}, то это не приведёт к ошибке. Результат
будет находиться в интервале целых чисел, то есть все действия над целыми
ограниченны операцией \texttt{modulo} с границами интервала.

\begin{table}[hl]
\begin{center}
	\label{tbl:operations_on_numbers}
	\caption{Операции над числами}
	\begin{tabular}{|p{7.2cm}|p{7.2cm}|}
	\hline
	целые & плавающие \\
	\hline
	+ сложение & +. сложение \\
	\hline
	- вычитание и унарный минус & -. вычитание и унарный минус \\
	\hline
	* умножение & *. умножение \\
	\hline
	/ деление & /. деление \\
	\hline
	\texttt{mod} остаток целочисленного деления & ** возведение в степень \\
	\hline
	\end{tabular}
%\vspace{12}
	\begin{tabular}{|p{7.2cm}|p{7.2cm}|}
	\hline
{\begin{lstlisting}[language=OCaml,frame=none]
# 1 ;;
- : int = 1
# 1 + 2 ;;
- : int = 3
# 9 / 2 ;;
- : int = 4
# 11 mod 3 ;;
- : int = 2
(* limits of the representation  *)
(* of integers                   *)
# 2147483650 ;;
- : int = 2
\end{lstlisting}}
 &
{\begin{lstlisting}[language=OCaml,frame=none]
# 2.0 ;;
- : float = 2
# 1.1 +. 2.2 ;;
- : float = 3.3
# 9.1 /. 2.2 ;;
- : float = 4.13636363636
# 1. /. 0. ;;
- : float = inf
(* limits of the representation  *)
(* of floating-point numbers     *)
# 222222222222.11111 ;;
- : float = 222222222222
\end{lstlisting}}
\\
	\hline
	\end{tabular}
\end{center}
\end{table}

\subsubsection{Разница между целыми числами и числами с плавающей запятой.}

Значения разных типов, таких как \texttt{float} и \texttt{int}, не могут
сравниваться между собой напрямую. Для этого существует функции перевода одного
типа в другой (\texttt{float\_of\_int} и \texttt{int\_of\_float}).

\begin{lstlisting}[language=OCaml]
# 2 = 2.0;;
Error: This expression has type float but an expression was expected of type
         int
# 3.0 = float_of_int 3;;
- : bool = true
\end{lstlisting}

Аналогично, операции над целыми числами и числами с плавающей запятой различны:

\begin{lstlisting}[language=OCaml]
# 3 + 2;;
- : int = 5
# 3.0 +. 2.0;;
- : float = 5.
# 3.0 + 2.0;;
Error: This expression has type float but an expression was expected of type
         int
# sin 3.14159;;
- : float = 2.65358979335273e-06
\end{lstlisting}

Неопределённый результат, например получаемый при делении на ноль, приведет к
возникновению исключения (см. \ref{??}, стр. \pageref{??}), которое остановит
вычисление. Числа с плавающей запятой имеют специальные значения для бесконечных
величин (\texttt{Inf}) и для не определённого результата (\texttt{NaN}
\footnote{Not a Number}). Основные операции над этими числами приведены в
таблице \ref{tbl:functions_on_floats}

\begin{table}[hl]
\begin{center}
	\label{tbl:functions_on_floats}
	\caption{Функции над числами с плавающей запятой}
	\begin{tabular}{|p{7.2cm}|p{7.2cm}|}
	\hline
	\texttt{ceil} & \texttt{cos} косинус \\
	\hline
	\texttt{floor} & \texttt{sin} синус \\
	\hline
	\texttt{sqrt} --- квадратный корень & \texttt{tan} тангенс \\
	\hline
	\texttt{exp} --- экспонента & \texttt{acos} арккосинус \\
	\hline
	\texttt{log} --- натуральный логарифм & \texttt{asin} арксинус \\
	\hline
	\texttt{log10} --- логарифм по базе 10 & \texttt{atan} арктангенс \\
	\hline
	\end{tabular}
%\vspace{12}
	\begin{tabular}{|p{7.2cm}|p{7.2cm}|}
	\hline
{\begin{lstlisting}[language=OCaml,frame=none]
# ceil 3.4 ;;
- : float = 4.
# floor 3.4 ;;
- : float = 3.
# ceil (-.3.4) ;;
- : float = -3.
# floor (-.3.4) ;;
- : float = -4.
\end{lstlisting}}
 &
{\begin{lstlisting}[language=OCaml,frame=none]
# sin 1.57078 ;;
- : float = 0.999999999866717837
# sin (asin 0.707) ;;
- : float = 0.707
# acos 0.0 ;;
- : float = 1.57079632679489656
# asin 3.14 ;;
- : float = nan
\end{lstlisting}}
\\
	\hline
	\end{tabular}
\end{center}
\end{table}

\subsubsection{Символы и строки}

Символы, тип \texttt{char}, соответствуют целым числам в интервале от 0 до 255,
первые 128 значений соответствуют кодам ASCII. Функция \texttt{char\_of\_int} и
\texttt{int\_of\_char} преобразуют один тип в другой. Строки, тип
\texttt{string} --- это последовательность символов определенной длинны (не
длиннее $224^{24} - 6$). Оператором объединения строк (конкатенации) является
шапка $\wedge$. Следующие функции необходимы для перевода типов
\texttt{int\_of\_string}, \texttt{string\_of\_int}, \texttt{string\_of\_float} и
\texttt{float\_of\_string}.

\begin{lstlisting}[language=OCaml]
# 'B' ;;
- : char = 'B'
# int_of_char 'B' ;;
- : int = 66
# "est une chaîne" ;;
- : string = "est une cha\195\174ne"
# (string_of_int 1987) ^ " est l'année de la création de CAML" ;;
- : string = "1987 est l'ann\195\169e de la cr\195\169ation de CAML"
\end{lstlisting}

Если строка состоит из цифр, то мы не сможем использовать ее в численных
операциях, не выполнив явного преобразования.

\begin{lstlisting}[language=OCaml]
# "1999" + 1 ;;
Error: This expression has type string but an expression was expected of type
         int
# (int_of_string "1999") + 1 ;;
- : int = 2000
\end{lstlisting}

В модуле \texttt{String} собрано много функций для работы со строками (стр.
\pageref{??})

\subsubsection{Булевый тип}

Значение типа \texttt{boolean} принадлежит множеству состоящему из двух
элементов: \texttt{true} и \texttt{false}. Основные операторы описаны в таблице
\ref{tbl:boolean_operations}. По историческим причинам операторы \texttt{and} и
\texttt{or} имеют две формы.

\begin{table}[hl]
	\label{tbl:boolean_operations}
\begin{center}
	\caption{Булевы операторы}
	\begin{tabular}{|p{5cm}|p{5cm}|}
	\hline
	not --- отрицание & \\
	\hline
	\&\& логическое и & \& синоним \&\& \\
	\hline
	|| логическое или & \texttt{or} синоним | \\
	\hline
	\end{tabular}
\end{center}
\end{table}

\begin{lstlisting}[language=OCaml]
# true ;;
- : bool = true
# not true ;;
- : bool = false
# true && false ;;
- : bool = false
\end{lstlisting}

Операторы \&\& и || или их синонимы, вычисляют аргумент слева и в зависимости от
его значения, вычисляют правый аргумент. Они могут быть переписаны в виде
условной структуры (см. \ref{??} стр. \pageref{??}).

\begin{table}[hl]
	\label{tbl:comparison_operations}
\begin{center}
	\caption{Операторы сравнения и равенства}
	\begin{tabular}{|p{5cm}|p{5cm}|}
	\hline
	= равенство структурное & < меньше \\
	\hline
	== равенство физическое & > больше \\
	\hline
	<> отрицание = & <= меньше или равно \\
	\hline
	!= отрицание == & >= больше или равно \\
	\hline
	\end{tabular}
\end{center}
\end{table}

Операторы сравнения и равенства описаны в таблице
\ref{tbl:comparison_operations}. Это полиморфные операторы, то есть они
применимы как для сравнения двух целых, так и двух строк. Единственное
ограничение это то что операнды должны быть одного типа (см. \ref{} стр.
\pageref{}).

\begin{lstlisting}[language=OCaml]
# 1<=118 && (1=2 || not(1=2)) ;;
- : bool = true
# 1.0 <= 118.0 && (1.0 = 2.0 || not (1.0 = 2.0)) ;;
- : bool = true
# "one" < "two" ;;
- : bool = true
# 0 < '0' ;;
Error: This expression has type char but an expression was expected of type
         int
\end{lstlisting}

Структурное равенство при проверке двух переменных сравнивает значение полей
структуры, тогда как физическое равенство проверяет занимают ли эти переменные
одно и то же место в памяти. Оба оператора возвращают одинаковый результат для
простых типов: \texttt{boolean}, \texttt{char}, \texttt{int} и константные
конструкторы (см. \ref{??} стр. \pageref{??}).

\subsubsection{Осторожно}

Числа с плавающей запятой и строки рассматриваются как структурные типы.

\subsubsection{Объединения}

Тип \texttt{unit} определяет множество из всего одного элемента, обозначается:
()

\begin{lstlisting}[language=OCaml]
# () ;;
- : unit = ()
\end{lstlisting}

Это значение будет широко использоваться в императивных программах (см. \ref{}
стр. \pageref{}), в функциях с побочным эффектом. Функции, результат которых
равен (), соответствуют понятию процедуры, которое отсутствует в Objective CAML,
так же как и аналог типа \texttt{void} в языке C.

\subsubsection{Декартово произведение, кортежи}

Значения разных типов могут быть сгруппированы в кортежи. Значения из которых
состоит кортеж разделяются запятой. Для конструкции кортежа, используется символ
\texttt{*}. \texttt{int*string} есть кортеж, в котором первый элемент целое
число и второй строка.

\begin{lstlisting}[language=OCaml]
# ( 12 , "October" ) ;;
- : int * string = (12, "October")
\end{lstlisting}

Иногда мы можем использовать более простую форму записи.

\begin{lstlisting}[language=OCaml]
# 12 , "October" ;;
- : int * string = (12, "October")
\end{lstlisting}

Функции \texttt{fst} и \texttt{snd} дают доступ первому и второму элементу
соответственно.

\begin{lstlisting}[language=OCaml]
# fst ( 12 , "October" ) ;;
- : int = 12
# snd ( 12 , "October" ) ;;
- : string = "October"
\end{lstlisting}

Эти обе функции полиморфные, входной аргумент может быть любого типа.

\begin{lstlisting}[language=OCaml]
# fst;;
- : 'a * 'b -> 'a = <fun>
# fst ( "October", 12 ) ;;
- : string = "October"
\end{lstlisting}

Тип \texttt{int*char*string} --- это триплет, в котором первый элемент типа
\texttt{int}, второй \texttt{char}, а третий --- \texttt{string}.

\begin{lstlisting}[language=OCaml]
# ( 65 , 'B' , "ascii" ) ;;
- : int * char * string = (65, 'B', "ascii")
\end{lstlisting}

\subsubsection{Осторожно}

Если аргумент функций \texttt{fst} и \texttt{snd} не пара, а другой n--кортеж,
то мы получим ошибку.

\begin{lstlisting}[language=OCaml]
# snd ( 65 , 'B' , "ascii" ) ;;
Error: This expression has type int * char * string
       but an expression was expected of type 'a * 'b
\end{lstlisting}

Существует разница между парой и триплетом: тип \texttt{int*int*int} отличен от
\texttt{(int*int)*int} и \texttt{int*(int*int)}. Методы доступа к элементам
триплета (и других кортежей) не определены в стандартной библиотеке. В случае
необходимости мы используем сопоставление с образцом (см. \ref{}).

\subsubsection{Списки}

Значения одного и того же типа могут быть объединены в списки. Список может быть
либо пустым, либо содержать однотипные элементы.

\begin{lstlisting}[language=OCaml]
# [] ;;
- : 'a list = []
# [ 1 ; 2 ; 3 ] ;;
- : int list = [1; 2; 3]
# [ 1 ; "two" ; 3 ] ;;
Error: This expression has type string but an expression was expected of type
         int
\end{lstlisting}

Для того чтобы добавить элемент в начало списка существует следующая функция в
виде инфиксного оператора :: --- аналог \texttt{cons} в Caml.

\begin{lstlisting}[language=OCaml]
# 1 :: 2 :: 3 :: [] ;;
- : int list = [1; 2; 3]
\end{lstlisting}

Для объединения (конкатенации) списков существует инфиксный оператор: @.

\begin{lstlisting}[language=OCaml]
# [ 1 ]  @  [ 2 ; 3 ] ;;
- : int list = [1; 2; 3]
# [ 1 ; 2 ]  @  [ 3 ] ;;
- : int list = [1; 2; 3]
\end{lstlisting}

Остальные функции манипуляции списками определены в библиотеке \texttt{List}.
Функции \texttt{hd} и \texttt{tl} дают доступ к первому и последнему элементу
списка.

\begin{lstlisting}[language=OCaml]
# List.hd [ 1 ; 2 ; 3 ] ;;
- : int = 1
# List.hd [] ;;
Exception: Failure "hd".
\end{lstlisting}

В последнем примере получить первый элемент пустого списка действительно
\enq{сложно}, поэтому возбуждается исключение (см. \ref{}).

\subsection{Структуры условного контроля}
\label{subsec:conditional_control_structure}

Одна из структур контроля необходимая в каждом языка программирования ---
условный оператор.

Синтаксис:

\begin{lstlisting}[language=OCaml]
if expr1 then expr2 else expr3
\end{lstlisting}

Тип выражения \texttt{expr1} равен \texttt{bool}. Выражения \texttt{expr2} и
\texttt{expr3} должны быть одного и того же типа.

\begin{lstlisting}[language=OCaml]
# if 3=4 then 0 else 4 ;;
- : int = 4
# if 3=4 then "0" else "4" ;;
- : string = "4"
# if 3=4 then 0 else  "4";;
Error: This expression has type string but an expression was expected of type
         int
\end{lstlisting}

\subsubsection{Замечание}
Ветка \texttt{else} может быть опущена, в этом случае будет подставлено значение
по умолчанию равное \texttt{else ()}, в соответствии с этим выражение
\texttt{expr2} должно быть типа \texttt{unit} (см. \ref{} стр. \pageref{}).

\subsection{Объявление значений}

Определение связывает имя со значением. Различают глобальные и локальные
определения. В первом случае, объявленные имена видны во всех выражениях,
следуют за ним, во втором --- имена доступны только в текущем выражении. Мы
также можем одновременно объявить несколько пар имя-значение.

\subsubsection{Глобальные объявления}

Синтаксис:

\begin{lstlisting}[language=OCaml]
let name = expr ;;
\end{lstlisting}

Глобальное объявление определяет связь имени \texttt{nom} со значением выражения
\texttt{expr}, которое будет доступно всем следующим выражениям.

\begin{lstlisting}[language=OCaml]
# let yr = "1999" ;;
val yr : string = "1999"
# let x = int_of_string(yr) ;;
val x : int = 1999
# x ;;
- : int = 1999
# x + 1 ;;
- : int = 2000
# let new_yr = string_of_int (x + 1) ;;
val new_yr : string = "2000"
\end{lstlisting}

\subsubsection{Одновременное глобальное объявление}

Синтаксис:

\begin{lstlisting}[language=OCaml]
let nom1 = expr1
and nom2 = expr2
:
and nomn = exprn;;
\end{lstlisting}

При одновременном объявлении переменные будут известны только к концу всех
объявлений.

\begin{lstlisting}[language=OCaml]
# let x = 1 and y = 2 ;;
val x : int = 1
val y : int = 2
# x + y ;;
- : int = 3
# let z = 3 and t = z + 2 ;;
Error: Unbound value z
\end{lstlisting}

Можно сгруппировать несколько глобальных объявлений в одной фразе, вывод типов и
значений произойдёт к концу фразы, отмеченной \enq{;;}. В данном случае
объявления будут вычислены по порядку.

\begin{lstlisting}[language=OCaml]
# let x = 2
  let y = x + 3  ;;
val x : int = 2
val y : int = 5
\end{lstlisting}

Глобальное объявление может быть скрыто локальным с тем же именем (см. \ref{??}
стр. \pageref{??}).

\subsubsection{Локальное объявление}

Синтаксис:

\begin{lstlisting}[language=OCaml]
let nom = expr1 in expr2;;
\end{lstlisting}

Имя \texttt{nom} связанное с выражением \texttt{expr1} известно только для
вычисления \texttt{expr2}.

\begin{lstlisting}[language=OCaml]
# let xl = 3 in xl * xl ;;
- : int = 9
\end{lstlisting}

Локальное объявление, которое связывает \texttt{xl} со значением \texttt{3},
существует только в ходе вычисления \texttt{xl*xl}.

\begin{lstlisting}[language=OCaml]
# xl ;;
Error: Unbound value xl
\end{lstlisting}

Локальное объявление скрывает любое глобальные с тем же именем, но как только мы
выходим из блока в котором была оно определено, мы находим старое значение
связанное с этим именем.

\begin{lstlisting}[language=OCaml]
# let x = 2 ;;
val x : int = 2
# let x = 3 in x * x ;;
- : int = 9
# x * x ;;
- : int = 4
\end{lstlisting}

Локальное объявление --- это обычное выражение, соответственно оно может быть
использовано для построения других выражений.

\begin{lstlisting}[language=OCaml]
# (let x = 3 in x * x) + 1 ;;
- : int = 10
\end{lstlisting}

Локальные объявления так же могут быть одновременными.

\begin{lstlisting}[language=OCaml]
let 	name1 = expr1
and 	name2 = expr2
:
and 	namen = exprn
in 	expr ;;
\end{lstlisting}

\begin{lstlisting}[language=OCaml]
# let a = 3.0 and b = 4.0 in sqrt (a*.a +. b*.b) ;;
- : float = 5.
# b ;;
Error: Unbound value b
\end{lstlisting}

\subsection{Функциональное выражение, функции}

Функциональное выражение состоит из параметра и тела. Формальный параметр — это
имя переменной, а тело --- это выражение. Обычно говорят что формальный параметр
является абстрактным, по этой причине функциональное выражение тоже называется
абстракцией.

Синтаксис:

\begin{lstlisting}[language=OCaml]
function p -> expr
\end{lstlisting}

Таким образом функция возведения в квадрат будет выглядеть так:

\begin{lstlisting}[language=OCaml]
# function x -> x*x ;;
- : int -> int = <fun>
\end{lstlisting}

Objective CAML сам определяет тип. Функциональный тип \texttt{int->int} это
функция с параметром типа \texttt{int}, возвращающая значение типа \texttt{int}.

Функция с одним аргументом пишется как функция и аргумент следующий за ней.

\begin{lstlisting}[language=OCaml]
# (function x -> x * x) 5 ;;
- : int = 25
\end{lstlisting}

Вычисление функции состоит в вычисление её тела, в данном случае \texttt{x*x},
где формальный параметр \texttt{x}, заменён значением аргумента (эффективным
параметром), здесь он равен 5.

При конструкции функционального выражения \texttt{expr} может быть любым
выражением, в частности функциональным.

\begin{lstlisting}[language=OCaml]
# function x -> (function y -> 3*x + y) ;;
- : int -> int -> int = <fun>
\end{lstlisting}

Скобки не обязательны, мы можем писать просто:

\begin{lstlisting}[language=OCaml]
# function x -> function y -> 3*x + y ;;
- : int -> int -> int = <fun>
\end{lstlisting}

В простом случае мы скажем, что функция ожидает два аргумента целого типа на
входе и возвращает значение целого типа. Но когда речь идёт о функциональном
языке, таком как Objective CAML, то скорее это соответствует типу функции с
входным аргументом типа \texttt{int} и возвращающая функциональное значение типа
\texttt{int->int}:

\begin{lstlisting}[language=OCaml]
# (function x -> function y -> 3*x + y) 5 ;;
- : int -> int = <fun>
\end{lstlisting}

Естественно, мы можем применить это функциональное выражение к двум аргументам.
Для этого напишем:

\begin{lstlisting}[language=OCaml]
# (function x -> function y -> 3*x + y) 4 5 ;;
- : int = 17
\end{lstlisting}

Когда мы пишем \texttt{f a b}, подразумевается применение \texttt{(f a) к b}.

Давайте подробно рассмотрим выражение

\begin{lstlisting}[language=OCaml]
(function x -> function y -> 3*x + y) 4 5
\end{lstlisting}

Для того чтобы вычислить это выражение, необходимо сначала вычислить значение

\begin{lstlisting}[language=OCaml]
(function x -> function y -> 3*x + y) 4
\end{lstlisting}

что есть {\it функциональное выражение} равное

\begin{lstlisting}[language=OCaml]
function y -> 3*4 + y
\end{lstlisting}

в котором \texttt{x} заменён на 4 в выражении \texttt{3 * x + y}. Применяя это
значение (являющееся функцией) к 5, мы получаем конечное значение \texttt{3 * 4
+ 5 = 17}:

\begin{lstlisting}[language=OCaml]
# (function x -> function y -> 3*x + y) 4 5 ;;
- : int = 17
\end{lstlisting}

\subsubsection{Арность функции}

Арностью функции называется число аргументов функции. По правилам,
унаследованным из математики, аргументы функции задаются в скобках после имени
функции. Мы пишем: \texttt{f(4,5)}. Как было указанно ранее, в Objective CAML мы
чаще используем следующий синтаксис: \texttt{f 4 5}. Естественно, можно написать
функциональное выражение применимое к (\texttt{4,5)}:

\begin{lstlisting}[language=OCaml]
# function (x,y) -> 3*x + y ;;
- : int * int -> int = <fun>
\end{lstlisting}

Но в данном случае, функция ожидает не два аргумента, а один; тип которого пара
целых. Попытка применить два аргумента к функции ожидающей пару или наоборот,
передать пару функции для двух аргументов приведёт к ошибке:

\begin{lstlisting}[language=OCaml]
# (function (x,y) -> 3*x + y) 4 5 ;;
Error: This function is applied to too many arguments;
maybe you forgot a `;'
#  (function x -> function y -> 3*x + y) (4, 5) ;;
Error: This expression has type int * int
       but an expression was expected of type int
\end{lstlisting}

\subsubsection{Альтернативный синтаксис}

Существует более компактная форма записи функций с несколькими аргументами,
которая дошла к нам из старых версий {\it Caml}. Выглядит она так:

Синтаксис 

\begin{lstlisting}[language=OCaml]
fun p1 ... pn -> expr
\end{lstlisting}

Это позволяет не повторять слово \texttt{function} и стрелки. Данная запись
эквивалентна

\begin{lstlisting}[language=OCaml]
function p1 -> -> function pn -> expr
# fun x y -> 3*x + y ;;
- : int -> int -> int = <fun>
# (fun x y -> 3*x + y) 4 5 ;;
- : int = 17
\end{lstlisting}

Эту форму можно часто встретить в библиотеках идущих в поставку с Objective
CAML.

\subsubsection{Замыкание}

Objective CAML рассматривает функциональное выражение также как любое другое.
Значение возвращаемое функциональным выражением называется замыканием. Каждое
выражение Objective CAML вычисляется в окружении состоящем из соответствий
имя–значение, которые были объявлены до вычисляемого выражения. Замыкание может
быть описано как триплет, состоящий из имени формального параметра, тела функции
и окружения выражения. Нам необходимо хранить это окружение, поскольку в теле
функции кроме формальных параметров могут использоваться другие переменные. В
функциональном выражении эти переменные называются свободными, нам понадобится
их значение в момент применения функционального выражения.

\begin{lstlisting}[language=OCaml]
# let m = 3 ;;
val m : int = 3
# function x -> x + m ;;
- : int -> int = <fun>
#  (function x -> x + m) 5 ;;
- : int = 8
\end{lstlisting}

В случае когда применение замыкания к аргументу возвращает новое замыкание, оно
(новое замыкание) получает в своё окружение все необходимые связи для следующего
применения. Раздел \ref{??} подробно рассматривает эти понятия. В главе
\ref{??}, а так же в главе \ref{??} мы вернёмся к тому как замыкание
представляется в памяти.

До сих пор рассмотренные функциональные выражения были {\it анонимными}, однако
мы можем дать им имя.
Объявление функциональных значений

\subsubsection{Объявление функциональных значений}

Функциональное значение объявляется так же как и другие, при помощи конструктора
\texttt{let}

\begin{lstlisting}[language=OCaml]
# let succ = function x -> x + 1 ;;
val succ : int -> int = <fun>
# succ 420 ;;
- : int = 421
# let g = function x -> function y -> 2*x + 3*y ;;
val g : int -> int -> int = <fun>
# g 1 2;;
- : int = 8
\end{lstlisting}

Для упрощения записи, можно использовать следующий синтаксис:

Синтаксис:
\label{sec:def_func_val_let}

\begin{lstlisting}[language=OCaml]
let nom p1 ... pn = expr
\end{lstlisting}

что эквивалентно:

\begin{lstlisting}[language=OCaml]
let nom=function p1->->function pn-> expr
\end{lstlisting}

Следующие объявления \texttt{succ} и g эквивалентны предыдущим:

\begin{lstlisting}[language=OCaml]
# let succ x = x + 1 ;;
val succ : int -> int = <fun>
# let g x y = 2*x + 3*y ;;
val g : int -> int -> int = <fun>
\end{lstlisting}

В следующем примере демонстрируется функциональная сторона Objective CAML, где
функция \texttt{h1} получена применением \texttt{g} к аргументу. В данном случае
мы имеем дело с частичным применением.

\begin{lstlisting}[language=OCaml]
# let h1 = g 1 ;;
val h1 : int -> int = <fun>
# h1 2 ;;
- : int = 8
\end{lstlisting}

С помощью \texttt{g} мы можем определить другую функцию \texttt{h2} фиксируя
значение второго параметра \texttt{y}:

\begin{lstlisting}[language=OCaml]
# let h2 = function x -> g x 2 ;;
val h2 : int -> int = <fun>
# h2 1 ;;
- : int = 8
\end{lstlisting}

\subsubsection{Объявление инфиксных функций}

Некоторые бинарные функции могут быть использованы в инфиксной форме. Например
при сложении двух целых мы пишем \texttt{3 + 5} для применения \texttt{+} к
\texttt{3} и \texttt{5}. Для того чтобы использовать символ \texttt{+} как
классическое функциональное значение, необходимо указать это, окружая символ
скобками (\texttt{op}).

В следующем примере определяется функция \texttt{succ} используя \texttt{(+)}:

\begin{lstlisting}[language=OCaml]
# (+) ;;
- : int -> int -> int = <fun>
# let succ = (+) 1 ;;
val succ : int -> int = <fun>
# succ 3 ;;
- : int = 4
\end{lstlisting}

Таким образом мы можем определить новые операторы, что мы и сделаем определив
\texttt{++} для сложения двух пар целых.

\begin{lstlisting}[language=OCaml]
# let (++) c1 c2 = (fst c1)+(fst c2), (snd c1)+(snd c2) ;;
val ( ++ ) : int * int -> int * int -> int * int = <fun>
# let c = (2,3) ;;
val c : int * int = (2, 3)
# c ++ c ;;
- : int * int = (4, 6)
\end{lstlisting}

Существуют однако ограничения на определение новых операторов, они должны
содержать только {\it символы} (такие как \texttt{*,+,\$}, etc.), исключая буквы
и цифры. Следующие функции являются исключением:

\begin{lstlisting}[language=OCaml]
or mod land lor lxor lsr asr
\end{lstlisting}

\subsubsection{Функции высшего порядка}

Функциональное значение (замыкание) может быть возвращено как результат, а так
же передано как аргумент функции. Такие функции, берущие на входе или
возвращающие функциональные значения, называются функциями высшего порядка.

\begin{lstlisting}[language=OCaml]
# let h = function f -> function y -> (f y) + y ;;
val h : (int -> int) -> int -> int = <fun>
\end{lstlisting}

{\it Замечание}
Выражения группируются справа налево, но функциональные типы объединяются слева
направо. Таким образом тип функции \texttt{h} может быть написан:

\begin{lstlisting}[language=OCaml]
(int -> int) -> int -> int или (int -> int) -> (int -> int)
\end{lstlisting}

При помощи функций высшего порядка можно элегантно обрабатывать списки. К
примеру функция \texttt{List.map} применяет какую-нибудь функцию ко всем
элементам списка и возвращает список результатов.

\begin{lstlisting}[language=OCaml]
# List.map ;;
- : ('a -> 'b) -> 'a list -> 'b list = <fun>
# let square x = string_of_int (x*x) ;;
val square : int -> string = <fun>
# List.map square [1; 2; 3; 4] ;;
- : string list = ["1"; "4"; "9"; "16"]
\end{lstlisting}

Другой пример --- функция \texttt{List.for\_all} проверяет соответствуют ли
элементы списка определённому критерию.

\begin{lstlisting}[language=OCaml]
# List.for_all ;;
- : ('a -> bool) -> 'a list -> bool = <fun>
# List.for_all (function n -> n<>0) [-3; -2; -1; 1; 2; 3] ;;
- : bool = true
# List.for_all (function n -> n<>0) [-3; -2; 0; 1; 2; 3] ;;
- : bool = false
\end{lstlisting}

\subsubsection{Видимость переменных}

Для вычисления выражения, необходимо чтобы все используемые им переменные были
определены, как, например, выражение \texttt{e} в определении

\begin{lstlisting}[language=OCaml]
let p=e
\end{lstlisting}

Переменная \texttt{p} не известна в этом выражении, она может быть использована
только в случае если \texttt{p} была объявлена ранее.

\begin{lstlisting}[language=OCaml]
# let p = p ^ "-suffixe" ;;
Error: Unbound value p
# let p = "préfixe" ;;
val p : string = "pr\195\169fixe"
# let p = p ^ "-suffixe" ;;
val p : string = "pr\195\169fixe-suffixe"
\end{lstlisting}

В Objective CAML переменные связаны статически. При применении замыкания
используется окружение в момент её (замыкания) объявления (статическая
видимость), а не в момент её применения (динамическая видимость)

\begin{lstlisting}[language=OCaml]
# let p = 10 ;;
val p : int = 10
# let k x = (x, p, x+p) ;;
val k : int -> int * int * int = <fun>
# k p ;;
- : int * int * int = (10, 10, 20)
# let p = 1000 ;;
val p : int = 1000
# k p ;;
- : int * int * int = (1000, 10, 1010)
\end{lstlisting}

В функции \texttt{k} имеется свободная переменная \texttt{p}, которая была
определена в глобальном окружении, поэтому определение \texttt{k} принято. Связь
между именем \texttt{p} и значением 10 в окружении замыкания \texttt{k}
статическая, то есть не зависит от последнего определения \texttt{p}.

\subsubsection{Рекурсивное объявление}

Объявление переменной называется рекурсивным, если оно использует свой
собственный идентификатор в своём определении. Эта возможность часто
используется для определения рекурсивных функций. Как мы видели ранее,
\texttt{let} не позволяет делать это, поэтому необходимо использовать
специальный синтаксис:

\begin{lstlisting}[language=OCaml]
let rec nom = expr ;;
\end{lstlisting}

Другой способ записи для функции с аргументами:

\begin{lstlisting}[language=OCaml]
let rec nom p1 ... pn = expr ;;
\end{lstlisting}

Определим функцию \texttt{sigma} вычисляющую сумму целых от \texttt{0} до
значения указанного аргументом:

\begin{lstlisting}[language=OCaml]
# let rec sigma x = if x = 0 then 0 else x + sigma (x-1) ;;
val sigma : int -> int = <fun>
# sigma 10 ;;
- : int = 55
\end{lstlisting}

Как заметил читатель, эта функция рискует \enq{не закончится} если входной
аргумент меньше 0.

Обычно, рекурсивное значение --- это функция, компилятор не принимает некоторые
рекурсивные объявления, значения которых не функциональные.

\begin{lstlisting}[language=OCaml]
# let rec x = x + 1 ;;
Error: This kind of expression is not allowed as right-hand side of `let rec'
\end{lstlisting}

Как мы увидим позднее, такие определения все таки возможны в некоторых случаях
(см. \ref{??} стр. \pageref{??}).

Объявление \texttt{let rec} может быть скомбинировано с \texttt{and}. В этом
случае функции определённые на одном и том же уровне, видны всем остальным. Это
может быть полезно при декларации взаимно рекурсивных функций.

\begin{lstlisting}[language=OCaml]
# let rec pair n = (n<>1) && ((n=0) or (impair (n-1))) and impair n = (n<>0) &&
((n=1) or (pair (n-1)));;
val pair : int -> bool = <fun>
val impair : int -> bool = <fun>
# pair 4 ;;
- : bool = true
# impair 5 ;;
- : bool = true
\end{lstlisting}

По тому же принципу, локальные функции могут быть рекурсивными. Новое
определение функции \texttt{sigma} проверяет корректность входного аргумента,
перед тем как посчитать сумму локальной функцией \texttt{sigma\_rec}.

\begin{lstlisting}[language=OCaml]
# let sigma x = let rec sigma_rec x = if x = 0 then 0 else x + sigma_rec (x-1)
in if (x<0) then "erreur : argument negatif" else "sigma = " ^ (string_of_int
(sigma_rec x)) ;;
val sigma : int -> string = <fun>
\end{lstlisting}

{\it Замечание}

Мы вынужденны были определить возвращаемый тип как \texttt{string}, поскольку
необходимо чтобы он был один и тот же, независимо от входного аргумента,
отрицательного или положительного. Какое значение должна вернуть \texttt{sigma}
если аргумент больше нуля? Далее, мы увидим правильный способ решения этой
проблемы (см. \ref{??} стр. \ref{??}).

\subsection{Полиморфизм и ограничение типа}

Некоторые функции выполняют одни и те же инструкции независимо от типа
аргументов. К примеру, для создание пары из двух значений нет смысла определять
функции для каждого известного типа. Другой пример, доступ к первому полю пары
не зависит от того, какого типа это поле.

\begin{lstlisting}[language=OCaml]
# let make_pair a b = (a,b) ;;
val make_pair : 'a -> 'b -> 'a * 'b = <fun>
# let p = make_pair "papier" 451 ;;
val p : string * int = ("papier", 451)
# let a = make_pair 'B' 65 ;;
val a : char * int = ('B', 65)
# fst p ;;
- : string = "papier"
# fst a ;;
- : char = 'B'
\end{lstlisting}

Функция, для которой не нужно указывать тип входного аргумента или возвращаемого
значения называется полиморфной. Синтезатор типов, включённый в компилятор
Objective CAML находит наиболее общий тип для каждого выражения. В этом случае
Objective CAML использует переменные, здесь они обозначены как \texttt{'a} и
\texttt{'b}, для указания общих типов. Эти переменные конкретизируются типом
аргумента в момент применения функции.

При помощи полиморфных функций, мы получаем возможность написания универсального
кода для любого типа переменных, сохраняя при этом надёжность статической
типизации. Действительно, несмотря на то что \texttt{make\_paire} полиморфная,
значение созданное (\texttt{make\_paire '6' 65}) имеет строго определённый тип,
который отличен от (\texttt{make\_paire "paire" 451}). Проверка типов
реализуется в момент компиляции, таким образом универсальность кода никак не
сказывается на эффективности программы.

\subsubsection{Пример функций и полиморфных значений}

В следующем примере приведена полиморфная функция с входным параметром
функционального типа.

\begin{lstlisting}[language=OCaml]
# let app = function f -> function x -> f x ;;
val app : ('a -> 'b) -> 'a -> 'b = <fun>
\end{lstlisting}

Мы можем применить её к функции \texttt{impaire}, которая была определена ранее.

\begin{lstlisting}[language=OCaml]
# app impair 2;;
- : bool = false
\end{lstlisting}

Функция тождества (\texttt{id}) возвращает полученный аргумент.

\begin{lstlisting}[language=OCaml]
# let id x = x ;;
val id : 'a -> 'a = <fun>
# app id 1 ;;
- : int = 1
\end{lstlisting}

Следующая функция, \texttt{compose} принимает на входе две функции и ещё один
аргумент, к которому применяет две первые.

\begin{lstlisting}[language=OCaml]
# let compose f g x = f (g x) ;;
val compose : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b = <fun>
# let add1 x = x+1 and mul5 x = x*5 in compose mul5 add1 9 ;;
- : int = 50
\end{lstlisting}

Как мы видим, тип результата возвращаемого \texttt{g} должен быть таким же как и
тип входного аргумента \texttt{f}.

Не только функциональные значения могут быть полиморфными, проиллюстрируем это
на примере пустого списка.

\begin{lstlisting}[language=OCaml]
# let l = [] ;;
val l : 'a list = []
\end{lstlisting}

Следующий пример иллюстрирует тот факт, что создание типов основывается на
разрешении ограничений, накладываемых применением функций, а вовсе не на
значениях, полученных в процессе выполнения.

\begin{lstlisting}[language=OCaml]
# let q = List.tl [2] ;;
val q : int list = []
\end{lstlisting}

Здесь тип равен \texttt{List.tl 'a list->'a list}, то есть эта функция
применяется к списку целых и возвращает список целых. Тот факт что в момент
выполнения возвращён пустой список, не влияет на его тип.

Objective CAML создаёт параметризованные типы для каждой функции, которые не
зависят от её аргументов. Этот вид полиморфизма называется {\it параметрическим
полиморфизмом} \footnote{Некоторые встроенные функции не подчиняются этому
правилу, особенно функция структурного равенства (\texttt{=}), которая является
полиморфной (её тип \texttt{'a -> 'a -> bool}), но она исследует структуру своих
аргументов для проверки равенства.}.

\subsubsection{Ограничение типа}

Синтезатор типа Objective CAML образует самый общий тип и иногда бывает
необходимо уточнить тип выражения.

Синтаксис ограничения типа следующий:

\begin{lstlisting}[language=OCaml]
(expr:t)
\end{lstlisting}

В этом случае синтезатор типа воспользуется этим ограничением при конструкции
типа выражения. Использование ограничения типа позволяет

\begin{itemize}
	\item сделать видимым тип параметра функции

	\item запретить использование функции вне свой области применения

	\item уточнить тип выражения, это окажется необходимым в случае физически
изменяемых значений (см. \ref{??} стр. \pageref{??}).
\end{itemize}

Рассмотрим использование ограничения типа.

\begin{lstlisting}[language=OCaml]
# let add (x:int) (y:int) = x + y ;;
val add : int -> int -> int = <fun>
# let make_pair_int (x:int) (y:int) = x,y;;
val make_pair_int : int -> int -> int * int = <fun>
# let compose_fn_int (f : int -> int) (g : int -> int) (x:int) = compose f g x;;
val compose_fn_int : (int -> int) -> (int -> int) -> int -> int = <fun>
# let nil = ([] : string list);;
val nil : string list = []
# 'H'::nil;;
Error: This expression has type string list
       but an expression was expected of type char list
\end{lstlisting}

Это ограничение полиморфизма позволяет лучше контролировать тип выражений, тем
самым ограничивая тип определённый системой. В таких выражениях можно
использовать любой определённый тип.

\begin{lstlisting}[language=OCaml]
# let llnil = ([] : 'a list list) ;;
val llnil : 'a list list = []
# [1;2;3]:: llnil ;;
- : int list list = [[1; 2; 3]]
\end{lstlisting}

\texttt{llint} является списком списков любого типа.

В данном случае подразумевается ограничение типа, а не явная типизация
заменяющая тип, который определил Objective CAML. В частности, мы не можем
обобщить тип, более чем это позволяет вывод типов Objective CAML.

\begin{lstlisting}[language=OCaml]
# let add_general (x:'a) (y:'b) = add x y ;;
val add_general : int -> int -> int = <fun>
\end{lstlisting}

Ограничения типа будут использованы в интерфейсах модулей \ref{??}, а так же в
декларации классов \ref{??}

\subsection{Примеры}
\label{sec:caml_kernel:examples}

В этом параграфе мы приведём несколько примеров функций. Большинство из них уже
определены в Objective CAML, мы делаем это только в \enq{педагогических} целях.

Тест остановки рекурсивных функций реализован при помощи проверки, имеющей стиль
более близкий к \texttt{Lisp}. Мы увидим как это сделать в стиле ML (см.
\ref{??}).

\subsubsection{Размер списка}

Начнём с функции проверяющей пустой список или нет.

\begin{lstlisting}[language=OCaml]
# let null l = (l=[]);;
val null : 'a list -> bool = <fun>
\end{lstlisting}

Определим функцию \texttt{size} вычисления размера списка (т.е. число
элементов).

\begin{lstlisting}[language=OCaml]
# let rec size l = if null l then 0 else 1+(size(List.tl l));;
val size : 'a list -> int = <fun>
# size [] ;;
- : int = 0
# size [1;2;18;22] ;;
- : int = 4
\end{lstlisting}

Функция \texttt{size} проверяет список: если он пуст возвращает 0, иначе
прибавляет 1 к длине остатка списка.

\subsubsection{Итерация композиций (Iteration of composition)}

Выражение \texttt{iterate n f} вычисляет $f^n$, соответствующее применение
функции \texttt{f n} раз.

\begin{lstlisting}[language=OCaml]
# let rec iterate n f =
   if n = 0 then (function x -> x)
   else compose f (iterate (n-1) f) ;;
val iterate : int -> ('a -> 'a) -> 'a -> 'a = <fun>
\end{lstlisting}

Функция \texttt{iterate} проверяет аргумент n на равенство нулю, если аргумент
равен, то возвращаем функцию идентичности, иначе возвращаем композицию
\texttt{f} с итерацией \texttt{f n-1} раз.

Используя \texttt{iterate} можно определить операцию возведения в степень, как
итерацию умножения.

\begin{lstlisting}[language=OCaml]
# let rec power i n =
  let i_times = ( * ) i in
   iterate n i_times 1 ;;
val power : int -> int -> int = <fun>
# power 2 8 ;;
- : int = 256
\end{lstlisting}

Функция \texttt{power} повторяет n раз функциональное выражение
\texttt{i\_times}, затем применяет этот результат к 1, таким образом мы получаем
n-ю степень целого числа.

\subsubsection{Таблица умножения}

Напишем функцию \texttt{multab}, которая вычисляет ряд таблицы умножения
соответствующую целому числу переданному в аргументе.

Для начала определим функцию \texttt{apply\_fun\_list}. Пусть \texttt{f\_list}
список функций, тогда вызов \texttt{apply\_fun\_list x f\_list} возвращает
список результатов применения каждого элемента списка \texttt{f\_list} к
\texttt{x}.

\begin{lstlisting}[language=OCaml]
# let rec apply_fun_list x f_list =
  if null f_list then []
  else ((List.hd f_list) x)::(apply_fun_list x (List.tl f_list)) ;;
val apply_fun_list : 'a -> ('a -> 'b) list -> 'b list = <fun>
# apply_fun_list 1 [(+) 1;(+) 2;(+) 3] ;;
- : int list = [2; 3; 4]
\end{lstlisting}

Функция \texttt{mk\_mult\_fun\_list} возвращает список функций умножающих их
аргумент на i, \texttt{0<=i<=n}.

\begin{lstlisting}[language=OCaml]
# let mk_mult_fun_list n =
    let rec mmfl_aux p =
      if p = n then [ ( * ) n ]
      else (( * ) p) :: (mmfl_aux (p+1))
    in  (mmfl_aux 1) ;;
val mk_mult_fun_list : int -> (int -> int) list = <fun>
\end{lstlisting}

Подсчитаем ряд для 7

\begin{lstlisting}[language=OCaml]
# let multab n = apply_fun_list n (mk_mult_fun_list 10) ;;
val multab : int -> int list = <fun>
# multab 7 ;;
- : int list = [7; 14; 21; 28; 35; 42; 49; 56; 63; 70]
\end{lstlisting}

\subsubsection{Итерация в списке}

Вызов функции \texttt{fold\_left f a [e1; e2; $\ldots$; en]} возвращает
\texttt{f$\ldots$(f (f a e1) e2) $\ldots$ en}, значит получаем n применений.

\begin{lstlisting}[language=OCaml]
# let rec fold_left f a l =
   if null l then a
   else fold_left f ( f a (List.hd l)) (List.tl l) ;;
val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = <fun>
\end{lstlisting}

С помощью функции \texttt{fold\_left} можно компактно определить функцию
вычисления суммы элементов списка целых чисел.

\begin{lstlisting}[language=OCaml]
# let sum_list = fold_left (+) 0 ;;
val sum_list : int list -> int = <fun>
# sum_list [2;4;7] ;;
- : int = 13
\end{lstlisting}

Или, например, конкатенация элементов списка строк.

\begin{lstlisting}[language=OCaml]
# let sum_list = fold_left (+) 0 ;;
val sum_list : int list -> int = <fun>
# sum_list [2;4;7] ;;
- : int = 13
\end{lstlisting}
