\section{Полиморфизм и значения возвращаемые функциями}

Полиморфизм Objective CAML позволяет определить функции, тип возвращаемого
выражения которых конкретно не определён. Например:

\begin{lstlisting}[language=OCaml]
# let id x = x ;;
val id : 'a -> 'a = <fun>
\end{lstlisting}

Однако, возвращаемый тип \texttt{id} зависит от типа аргумента. Таким образом,
если мы применим функцию \texttt{id} к какому-нибудь аргументу, то механизм
вывода (определения) типа сможет реализовать переменную типа \texttt{'a}. Для
каждого частного использования тип функции \texttt{id} может быть определён.

Иначе, использование жёсткой статической типизации, которая обеспечивает
правильность выполнения, не будет иметь смысла. Функция с полностью
неопределённым типом как \texttt{'a->'b}, разрешит какое попало преобразование
типа, что привело бы к ошибке выполнения, так как физическое представление
значений не одно и то же.

\subsubsection{Очевидное противоречие}

Мы можем определить функции, которые возвращают значение, тип которого не
соответствует типу аргументов. Рассмотрим несколько примеров и проанализируем
почему это не противоречит жёсткой статической типизации.

Вот первый пример:

\begin{lstlisting}[language=OCaml]
# let f x = [] ;;
val f : 'a -> 'b list = <fun>
\end{lstlisting}

Эта функция конструирует полиморфные значения из любого типа.

\begin{lstlisting}[language=OCaml]
# f () ;;
- : 'a list = []
# f "n'importe quoi" ;;
- : 'a list = []
\end{lstlisting}

Однако, полученное значение не совсем является не определённым ---
подразумевается список. Таким образом она не может использоваться где попало.

Вот три примера функций типа \texttt{'a -> 'b}:

\begin{lstlisting}[language=OCaml]
# let rec f1 x = f1 x ;;
val f1 : 'a -> 'b = <fun>
# let f2 x = failwith "n'importe quoi" ;;
val f2 : 'a -> 'b = <fun>
# let f3 x = List.hd [] ;;
val f3 : 'a -> 'b = <fun>
\end{lstlisting}

Эти функции не являются \enq{опасными} в отношении правильности выполнения
программы, так как их невозможно использовать для конструкции значений: первая
зацикливается, две последние запускают исключение, которые останавливают
выполнение программы.

Чтобы не было возможности определить функции типа \texttt{'a -> 'b}, новые
конструкторы исключений не должны иметь аргументы типы которых содержат
переменную.

Если бы могли объявить полиморфное исключение \texttt{Poly\_exn} типа \texttt{'a
-> exn}, то тогда следующая функция была бы возможна:

\begin{lstlisting}[language=OCaml]
let f = function
   0 -> raise (Poly_exn false)
 | n -> n+1 ;;
\end{lstlisting}

Таким образом, тип функции \texttt{f} это \texttt{int->int} и тип
\texttt{Poly\_exn} это \texttt{'a -> exn}, теперь напишем следующее:

\begin{lstlisting}[language=OCaml]
let g n = try f n with Poly_exn x -> x+1 ;;
\end{lstlisting}

Это правильно типизированная функция (поскольку аргумент \texttt{Poly\_exn}
может быть каким угодно) и вызов \texttt{g 0} попытается сложить целое с булевым
значением!


