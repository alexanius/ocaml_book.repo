\section{Введение}
\label{sec:intro_2}

Первый язык функционального программирования LISP появился в конце 1950, в тот
же момент, что и Fortran --- один из первых императивных языков. Оба этих языка
существуют и по сей день, хотя они немало изменились. Область их применения:
вычислительные задачи для Фортрана и символьные (symbolic) для Lisp. Интерес к
функциональному программированию состоит в простоте написания программ, где под
программой подразумевается функция, применённая к аргументам. Она вычисляет
результат, который возвращается как вывод программы. Таким образом можно с
лёгкостью комбинировать программы: вывод одной, становится входным аргументом
для другой.

Функциональное программирование основывается на простой модели вычислений,
состоящей из трёх конструкций: переменные, определение функции и её применение к
какому--либо аргументу. Эта модель, называемая $\lambda$--исчисление, была
введена Alonzo Church в 1932, ещё до появления первых компьютеров. В
$\lambda$--исчислении любая функция является переменной, так что она может быть
использована как входной параметр другой функции, или возвращена как результат
другой. Теория $\lambda$--исчисления утверждает что все то, что вычисляемо может
быть представлено этим формализмом. Однако, синтаксис этой теории слишком
ограничен, чтобы его можно было использовать его как язык программирования. В
связи с этим к $\lambda$--исчислению были добавлены базовые типы (например,
целые числа или строки символов), операторы для этих типов, управляющие
структуры и объявление позволяющие именовать переменные или функции, и в
частности рекурсивные функции.

Существует разные классификации языков функционального программирования. Мы
будем различать их по двум характеристикам, которые нам кажутся наиболее
важными:

\begin{itemize}
	\item без побочных эффектов (чистые), или с побочным эффектом
(не чистые): чистый язык --- это тот, в котором не существует изменения
состояния. Все есть вычисление, и как оно происходит, нас не интересует. Не
чистые языки, такие как Caml или ML, имеют императивные особенности, такие как
изменение состояния. Они позволяют писать программы в стиле близкому к Фортрану,
в котором важен порядок вычисления выражений.

	\item язык типизирован динамически или статически: типизация необходима для
проверки соответствия аргумента, переданного функции, типу формального
параметра. Это проверка может быть выполнена во время выполнения программы. В
этом случае типизация называется динамической. В случае ошибки программа будет
остановлена, как это происходит в Lisp. В случае статической типизации проверка
осуществляется во время компиляции, то есть до выполнения программы. Таким
образом она (проверка) не замедлит программу во время выполнения. Эта типизация
используется в ML и в его диалектах, таких как Objective CAML. Только правильно
типизированные программы, то есть успешно прошедшие проверку типов, могут быть
скомпилированы и затем выполнены.
\end{itemize}
