\section{Типизация, область определения и исключения}

Вычисленный тип функции принадлежит подмножеству множества в котором она
определена. Если входной аргумент функции типа \texttt{int}, это не значит что
она сможет быть выполнена для любого переданного ей целого числа. Таких случаях
мы используем механизм исключений Objective CAML. Запуск исключения провоцирует
остановку вычислений, которое может быть выявлено и обработано. Для этого
необходимо установить обработчик исключения, до того как исключение может быть
возбуждено.

\subsection{Частичные функции и исключения}

Область определения функции соответствует множеству значений которыми функция
манипулирует. Существует множество математических частичных функций, таких как
например, деление или натуральный логарифм. Проблемы возникают в том случае,
когда функция манипулирует более сложными структурами данных. Действительно,
каков будет результат функции определяющей первый элемент списка, если список
пуст. Аналогично, вычисление факториала для отрицательного числа приводит к
бесконечному вычислению.

Определённое число исключительных ситуаций может произойти во время выполнения
программы, как например деление на ноль. Попытка деления на ноль может привести
в лучшем случае к остановке программы и в худшем к неправильному (некоэрантному)
состоянию машины. Безопасность языка программирования заключается в гарантии
того, что такие случаи не возникнут. Исключение есть один из способов такой
гарантии.

Деление 1 на 0 провоцирует запуск специального исключения:

\begin{lstlisting}[language=OCaml]
# 1/0;;
Exception: Division_by_zero.
\end{lstlisting}

Сообщение \texttt{Exception: Division\_by\_zero} указывает во первых на то, что
исключение\texttt{ Division\_by\_zero} возбуждено и во вторых, что оно не было
обработано.

Часто, тип функции не соответствует области ее определения в том случае когда
сопоставление с образцом не является полным, то есть когда он не отслеживает все
возможные случаи. Чтобы избежать такой ситуации, Objective CAML выводит
следующее сообщение.

\begin{lstlisting}[language=OCaml]
# let tete l = match l with t::q -> t ;;
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
[]
val tete : 'a list -> 'a = <fun>
\end{lstlisting}

Однако, если программист все таки настаивает на своей версии, то Objective CAML
воспользуется механизмом исключения в случае неправильного вызова частичной
функции.

\begin{lstlisting}[language=OCaml]
# tete [] ;;
Exception: Match_failure ("", 9, 9).
\end{lstlisting}

Мы уже встречали другое исключение определенное в Objective CAML:
\texttt{Failure}, с входным аргументом типа \texttt{string}. Запустить это
исключение можно функцией \texttt{failwith}. Воспользуемся этим и дополним
определение функции \texttt{tete}.

\subsection{Определения исключения}

В Objective CAML, тип исключений --- \texttt{exn}. Это особенный тип ---
расширяемая сумма: мы можем увеличить множество значений этого типа объявляя
новые конструкторы. Такая особенность позволяет программисту определять свои
собственные исключения.

Синтаксис объявления следующий:

Синтаксис:

\begin{lstlisting}[language=OCaml]
exception Nom ;;
\end{lstlisting}

Синтаксис:

\begin{lstlisting}[language=OCaml]
exception Nom of t ;;
\end{lstlisting}

Вот несколько примеров объявления исключений.

\begin{lstlisting}[language=OCaml]
# exception A_MOI;;
exception A_MOI
# A_MOI;;
- : exn = A_MOI
# exception Depth of int;;
exception Depth of int
# Depth 4;;
- : exn = Depth 4
\end{lstlisting}

Имена исключений являются конструкторами --- это значит они должны начинаться с
заглавной буквы.

\begin{lstlisting}[language=OCaml]
# exception minuscule ;;
Error: Syntax error
\end{lstlisting}

{\it Предупреждение}

Исключения мономорфны, при объявлении типа аргумента мы не можем указать
параметризующий тип.

\begin{lstlisting}[language=OCaml]
exception Value of 'a ;;
Error: Unbound type parameter 'a
\end{lstlisting}

Полиморфное исключение позволило бы определение функций, возвращающих результат
любого типа. Подобный пример мы рассмотрим далее на \ref{}.

\subsection{Возбуждение исключения}

\texttt{raise} --- функциональный примитив языка Objective CAML, её входной
аргумент есть исключение, а возвращает он полиморфный тип.

\begin{lstlisting}[language=OCaml]
# raise ;;
- : exn -> 'a = <fun>
# raise A_MOI;;
Exception: A_MOI.
# 1+(raise A_MOI);;
Exception: A_MOI.
# raise (Depth 4);;
Exception: Depth 4.
\end{lstlisting}

В Objective CAML нет возможности написать функцию \texttt{raise}, она должна
быть определена системой.

\subsection{Перехват исключения}

Весь интерес возбуждения исключений содержится в возможности их обработать и
изменить выполнение программы в зависимости от этого исключения. В этом случае,
порядок вычисления выражения имеет значение для того чтобы определить какое
исключения было запущенно. Таким образом мы выходим из рамок чисто
функционального программирования, потому как порядок вычисления аргументов может
изменить результат. Об этом мы поговорим в следующей главе (стр. \ref{??})

Следующая конструкция, вычисляющая значение какого--то выражения, отлавливает
исключение, возбуждённое во время этого вычисления.

Синтаксис:

\begin{lstlisting}[language=OCaml]
try expr with
  | p1 -> expr1
  :
  | pn -> exprn
\end{lstlisting}

Если вычисление \texttt{expr} не возбудит исключения, то тип результата будет
типом подсчитываемым этим выражением. Иначе, в приведённом выше сопоставлении
будет искаться ответвление соответствующее этому исключению и будет возвращено
значение следующего за ним выражения.

Если ни одно ответвление не соответствует исключению, то оно будет переправлено
до следующего обработчика \texttt{try--with} установленного в программе. Таким
образом сопоставление исключения всегда исчерпывающий. Подразумевается что
последний фильтр \texttt{|e->raise e}. Если ни одного обработчика не найдено в
программе, система сама займётся обработкой этого исключения и остановит
программу с выводом сообщения об ошибке.

Важно понимать разницу между вычислением исключения (то есть значение типа
\texttt{exn}) и его обработкой, которое приостанавливает вычисления. Исключение,
как и любой другой тип, может быть возвращено функцией.

\begin{lstlisting}[language=OCaml]
# let rendre x = Failure x ;;
val rendre : string -> exn = <fun>
# rendre "test" ;;
- : exn = Failure "test"
# let declencher x = raise (Failure x) ;;
val declencher : string -> 'a = <fun>
# declencher "test" ;;
Exception: Failure "test".
\end{lstlisting}

Как вы наверно заметили, функция \texttt{declencher} (запустить) не возвращает
значение типа \texttt{exn}, тогда как \texttt{rendre} (вернуть) возвращает.

\subsubsection{Вычисления с исключениями}

Кроме обработки не желаемых значений, исключения можно использовать для
оптимизации. Следующий пример реализует произведение всех элементов списка целых
чисел. Мы воспользуемся исключением для остановки просмотра списка если
обнаружим 0, который мы вернём как результат функции.

\begin{lstlisting}[language=OCaml]
# exception Found_zero ;;
exception Found_zero
# let rec mult_rec l = match l with
     [] -> 1
   | 0 :: _ -> raise Found_zero
   | n :: x -> n * (mult_rec x) ;;
val mult_rec : int list -> int = <fun>
# let mult_list l =
    try mult_rec l with Found_zero -> 0 ;;
val mult_list : int list -> int = <fun>
# mult_list [1;2;3;0;5;6] ;;
- : int = 0
\end{lstlisting}

Оставшиеся вычисления, то есть произведения элементов после встреченного нуля,
не выполняются. После встречи \texttt{raise}, вычисление вновь продолжится с
\texttt{with}.




