\section{Какой стиль выбрать?}
\label{sec:which_style_to_choose}

Естественно, речь не идёт о \enq{священных} либо эстетических для каждого
понятиях, {\it a priori} не существует стиля красивее или лучше чем другой.
Однако, в зависимости от решаемой проблемы, один стиль может быть более
подходящим или более адаптированным чем другой.

Первое правило --- простота. Желаемый алгоритм (будь то в книге или лишь в
голове программиста) уже определён в каком-то стиле, вполне естественно его и
использовать при реализации.

Второй критерий --- эффективность программы. Можно сказать что императивная
программа (хорошо написанная) более эффективна чем её функциональный аналог, но
в очень многих случаях разница между ними не достаточно существенна для
оправдания сложности кода императивного стиля, там где функциональный был бы
естественен. Функция \texttt{map} есть хороший пример натурально выраженной в
функциональном стиле проблемы и мы ни в чем не выиграем написав её в
императивном стиле.

\subsection{Последовательность или композиция функций}
\label{subsec:sequence_or_composition_of_functions}

Мы уже видели, что как только в программе появляются побочные эффекты,
необходимо явно указывать порядок выполнения элементов программы. Это может быть
сделано двумя способами:

\begin{description}
	\item [функциональным] опираясь на то что Objective CAML строгий язык, то
есть аргумент вычислен до того как он будет передан функции. В выражение
\texttt{(f (g x))} сначала вычисляется \texttt{(g x)} и затем передача этого
результат функции \texttt{f}. В более сложных выражениях, промежуточный
результат может быть именован конструкцией \texttt{let in}, но принцип остаётся
тем же: \texttt{let aux=(g x) in (f aux)}.

	\item [императивный] используя последовательность или другую структуру
контроля (цикл). В этом случае, результатом будет побочный эффект над памятью, а
не значение возвращённое функцией : \texttt{aux:=(g x) ; (f!aux)}.
\end{description}

Давайте рассмотрим данную проблему выбора стиля на следующем примере.
Рекурсивный алгоритм быстрой сортировки вектора описывается следующим образом:

\begin{enumerate}
	\item выбрать опорную точку: выбрать индекс элемента в векторе

	\item переставить элементы вокруг этой точки: переставить элементы вектора
так чтобы значения меньше значения в опорной точке были слева от неё, а большие
значения справа

	\item отсортировать (тем же алгоритмом) два полученных вектора: элементы
после опорной точки и до неё
\end{enumerate}

Сортировка вектора --- означает изменение его состояния, поэтому мы должны
использовать императивный стиль, как минимум для манипуляции данными.

Начнём с определения функции переставляющей элементы вектора.

\begin{lstlisting}[language=OCaml]
# let permute_element vec n p =
   let aux = vec.(n) in vec.(n) <- vec.(p) ; vec.(p) <- aux  ;;
val permute_element : 'a array -> int -> int -> unit = <fun>
\end{lstlisting}

Выбор правильной точки опоры важен для эффективности алгоритма, но мы
ограничимся самым простым способом: вернём индекс первого элемента вектора.

\begin{lstlisting}[language=OCaml]
# let choose_pivot vec start finish = start ;;
val choose_pivot : 'a -> 'b -> 'c -> 'b = <fun>
\end{lstlisting}

Напишем теперь желаемый алгоритм переставляющий элементы вектора вокруг
выбранной точки.

\begin{itemize}
	\item установить опорную точку в начало вектора

	\item \texttt{i} индекс второго элемента вектора
	
	\item \texttt{j} индекс последнего элемента вектора
	
	\item если элемент с индексом \texttt{j} больше чем значение в опорной
точке, поменяем местами их значения и увеличим \texttt{i} на единицу, иначе
уменьшим \texttt{j} на единицу

	\item до тех пор пока \texttt{i} меньше чем \texttt{j} повторить предыдущую
операцию

	\item к этому этапу каждый элемент с индексом меньшим чем \texttt{i} (или
\texttt{}j) меньше значения в опорной точке, а остальные элементы больше: если
элемент с индекс \texttt{i} меньше чем опорное значение мы меняем их местами,
иначе меняем с предыдущим элементом.
\end{itemize}

При реализации алгоритма мы естественно воспользуемся императивными управляющими
структурами.

\begin{lstlisting}[language=OCaml]
# let permute_pivot vec start finish ind_pivot =
    permute_element vec start ind_pivot ;
    let i = ref (start+1) and j = ref finish and pivot = vec.(start) in
    while !i < !j do
      if vec.(!j) >= pivot then decr j
      else
        begin
          permute_element vec !i !j ;
          incr i
        end
    done ;
    if vec.(!i) > pivot then decr i ;
    permute_element vec start !i ;
    !i
 ;;
val permute_pivot : 'a array -> int -> int -> int -> int = <fun>
\end{lstlisting}

Кроме эффекта над вектором, функция возвращает индекс опорной точки.

Нам остаётся лишь собрать воедино различные этапы и написать рекурсивный вызов
для подвекторов.

\begin{lstlisting}[language=OCaml]
# let rec quick vec start finish =
    if start < finish
    then
      let pivot = choose_pivot vec start finish in
      let place_pivot = permute_pivot vec start finish pivot in
      quick (quick vec start (place_pivot-1)) (place_pivot+1) finish
    else vec ;;
val quick : 'a array -> int -> int -> 'a array = <fun>
\end{lstlisting}

Здесь мы воспользовались двумя стилями. Выбранная опорная точка служит
аргументом при перестановке вокруг неё и её порядок в векторе после этой
процедуры служит аргументом рекурсивного вызова. Зато, полученный после
перестановки вектор мы получаем в результате побочного эффекта, а не как
возвращённое значение функции \texttt{permute\_pivot}. Тогда как функция
\texttt{quick} возвращает вектор и сортировка подвекторов реализуется
композицией рекурсивных вызовов.

Теперь главная функция:

\begin{lstlisting}[language=OCaml]
# let quicksort vec = quick vec 0 ((Array.length vec)-1) ;;
val quicksort : 'a array -> 'a array = <fun>
\end{lstlisting}

Это полиморфная функция, так как отношение порядка < полиморфное.

\begin{lstlisting}[language=OCaml]
# let t1 = [|4;8;1;12;7;3;1;9|] ;;
val t1 : int array = [|4; 8; 1; 12; 7; 3; 1; 9|]
# quicksort t1 ;;
- : int array = [|1; 1; 3; 4; 7; 8; 9; 12|]
# t1 ;;
- : int array = [|1; 1; 3; 4; 7; 8; 9; 12|]
# let t2 = [|"the"; "little"; "cat"; "is"; "dead"|] ;;
val t2 : string array = [|"the"; "little"; "cat"; "is"; "dead"|]
# quicksort t2 ;;
- : string array = [|"cat"; "dead"; "is"; "little"; "the"|]
# t2 ;;
- : string array = [|"cat"; "dead"; "is"; "little"; "the"|]
\end{lstlisting}

\subsection{Общее использование или копии значений}
\label{subsec:shared_or_copy_values}

До тех пор пока наши данные не изменяемые, нет необходимости знать используются
они совместно или нет.

\begin{lstlisting}[language=OCaml]
# let id x = x ;;
val id : 'a -> 'a = <fun>
# let a = [ 1; 2; 3 ] ;;
val a : int list = [1; 2; 3]
# let b = id a ;;
val b : int list = [1; 2; 3]
\end{lstlisting}

Является ли \texttt{b} копией \texttt{a} или же это один и тот же список не
имеет значения, так как по любому это \enq{неосязаемые} значения. Однако, если
на место целых чисел, мы поместим изменяемые значения, необходимо будет знать
скажется ли изменение одного значения на другое.

Реализация полиморфизма Objective CAML вызывает (causes) копирование
непосредственных значений (immediate values) и разделение (sharing) структурных
значений. Хоть передача аргументов осуществляется копированием, в случае
структурных значений передается лишь указатель. Как в случае с функцией
\texttt{id}.

\begin{lstlisting}[language=OCaml]
# let a = [| 1 ; 2 ; 3 |] ;;
val a : int array = [|1; 2; 3|]
# let b = id a ;;
val b : int array = [|1; 2; 3|]
# a.(1) <- 4 ;;
- : unit = ()
# a ;;
- : int array = [|1; 4; 3|]
# b ;;
- : int array = [|1; 4; 3|]
\end{lstlisting}

Здесь мы действительно имеем случай выбора стиля программирования, от которого
зависит эффективность представления данных. С одной стороны, использование
изменяемых значений позволяет немедленное манипулирование данными (без
дополнительного выделения памяти). Однако это вынуждает, в некоторых случаях,
делать копии там, где использование неизменяемого значения позволило бы
разделение. Проиллюстрируем это двумя способами реализации списков.

\begin{lstlisting}[language=OCaml]
# type 'a list_immutable = LInil | LIcons of 'a * 'a list_immutable ;;
type 'a list_immutable = LInil | LIcons of 'a * 'a list_immutable
# type 'a list_mutable = LMnil | LMcons of 'a * 'a list_mutable ref ;;
type 'a list_mutable = LMnil | LMcons of 'a * 'a list_mutable ref
\end{lstlisting}

Фиксированные списки строго эквивалентны спискам Objective CAML, тогда как
изменяемые больше в стиле C, где ячейка состоит из значения и ссылки на
следующую ячейку.

С фиксированными списками существует единственный способ реализовать
конкатенацию и он вынуждает копирование структуры первого списка, тогда как
второй список может быть разделен с конечным списком.

\begin{lstlisting}[language=OCaml]
# let rec concat l1 l2 = match l1 with
     LInil -> l2
   | LIcons (a,l11) -> LIcons(a, (concat l11 l2)) ;;
val concat : 'a list_immutable -> 'a list_immutable -> 'a list_immutable =
  <fun>
# let li1 = LIcons(1, LIcons(2, LInil))
 and li2 =  LIcons(3, LIcons(4, LInil)) ;;
val li1 : int list_immutable = LIcons (1, LIcons (2, LInil))
val li2 : int list_immutable = LIcons (3, LIcons (4, LInil))
# let li3 = concat li1 li2 ;;
val li3 : int list_immutable =
  LIcons (1, LIcons (2, LIcons (3, LIcons (4, LInil))))
# li1==li3 ;;
- : bool = false
# let tlLI l =  match l with
   LInil       -> failwith "Liste vide"
 | LIcons(_,x) -> x ;;
val tlLI : 'a list_immutable -> 'a list_immutable = <fun>
# tlLI(tlLI(li3)) == li2 ;;
- : bool = true
\end{lstlisting}

В этом примере мы видим что первые ячейки \texttt{li1} и \texttt{li3} различны,
тогда как вторая часть \texttt{li3} есть именно \texttt{li2}.

С изменяемыми списками можно изменить аргументы (функция \texttt{concat\_share})
или создать новое значение (функция \texttt{concat\_copy})

\begin{lstlisting}[language=OCaml]
# let rec concat_copy l1 l2 =  match l1 with
     LMnil  -> l2
   | LMcons (x,l11) -> LMcons(x, ref (concat_copy !l11 l2)) ;;
val concat_copy : 'a list_mutable -> 'a list_mutable -> 'a list_mutable =
  <fun>
\end{lstlisting}

Это решение, \texttt{concat\_copy}, аналогично предыдущей функции
\texttt{concat}. Вот второе вариант, с общим использованием.

\begin{lstlisting}[language=OCaml]
# let concat_share l1 l2 =
  match l1 with
    LMnil -> l2
  | _     -> let rec set_last = function
                LMnil       -> failwith "concat_share : impossible case!!"
              | LMcons(_,l) -> if !l=LMnil then l:=l2 else set_last !l
             in
               set_last l1 ;
               l1 ;;
val concat_share : 'a list_mutable -> 'a list_mutable -> 'a list_mutable =
  <fun>
\end{lstlisting}

Конкатенация с общим использованием не нуждается в выделении памяти (мы не
используем конструктор \texttt{LMcons}), мы лишь ограничиваемся тем что
последняя ячейка первого списка теперь указывает на второй список. При этом,
конкатенация способна изменить аргументы переданные функции.

\begin{lstlisting}[language=OCaml]
# let lm1 = LMcons(1, ref (LMcons(2, ref LMnil)))
 and lm2 = LMcons(3, ref (LMcons(4, ref LMnil))) ;;
val lm1 : int list_mutable =
  LMcons (1, {contents = LMcons (2, {contents = LMnil})})
val lm2 : int list_mutable =
  LMcons (3, {contents = LMcons (4, {contents = LMnil})})
# let lm3 = concat_share lm1 lm2 ;;
val lm3 : int list_mutable =
  LMcons (1,
   {contents =
     LMcons (2,
      {contents = LMcons (3, {contents = LMcons (4, {contents = LMnil})})})})
\end{lstlisting}

Мы получили ожидаемый результат для \texttt{lm3}, однако значение \texttt{lm1}
изменено.

\begin{lstlisting}[language=OCaml]
# lm1 ;;
- : int list_mutable =
LMcons (1,
 {contents =
   LMcons (2,
    {contents = LMcons (3, {contents = LMcons (4, {contents = LMnil})})})})
\end{lstlisting}

Таким образом это может повлиять на оставшуюся часть программы.

\subsection{Критерии выбора}
\label{subsec:how_to_choose_your_style}

В чисто функциональной программе побочных эффектов не существует, это свойство
лишает нас операций ввода/вывода, исключений и изменяемых структур данных. Наше
определение функционального стиля является менее ограниченным, то есть функция
не изменяющая своё глобальное окружение может быть использована в функциональном
стиле. Подобная функция может иметь локальные изменяемые значения (и значит
следовать императивному стилю), но не должна изменять ни глобальные переменные
ни свои аргументы. С внешней стороны, такие функции можно рассматривать как
\enq{чёрный ящик}, чьё поведение сравнимо с поведением функции в чисто
функциональном стиле, с разницей что выполнение первой может быть приостановлен
возбуждением исключения. В том же духе, изменяемое значение, которое больше не
изменяется после инициализации, может быть использовано в функциональном стиле.

С другой стороны, программа написанная в императивном стиле, унаследует
следующие достоинства Objective CAML: правильность статической типизации,
автоматическое управление памятью, механизм исключений, параметризованный
полиморфизм и вывод типов.

Выбор между стилем функциональным и императивным зависит от программного
обеспечения которое вы хотите реализовать. Выбор может быть сделан в
соответствии со следующими характеристиками:

\begin{description}
	\item [выбор структур данных:] от использования или нет изменяемых структур
данных будет зависеть выбор стиля программирования. Действительно,
функциональный стиль по своей природе не совместим с изменением значений.
Однако, создание и просмотр значения не зависят от её свойств. Таким образом мы
возвращаемся к дискуссии \enq{изменение на месте vs копия} в
\ref{subsec:shared_or_copy_values}, к которой мы вернёмся для обсуждения
критерия эффективности.

	\item [структура данных существует:]
    если в программе необходимо менять изменяемые структуры данных (modify
mutable data structures), то императивный стиль является единственно возможным.
Однако, если необходимо лишь читать значения, то применение функционального
стиля гарантирует целостность данных. Использование рекурсивных структур данных
подразумевает рекурсивные функции, которые могут быть определены используя
особенности того или иного стиля программирования. Однако в общем случае бывает
проще истолковывать создание значения следуя рекуррентному определению. Этот
подход более близок к функциональному стилю, чем повторяющаяся обработка этого
значения рекурсией.

	\item [критерий эффективности:] немедленное изменение без сомнения лучше чем
создание значения. В случае когда эффективность кода является главенствующим
критерием, чаша весов перевешивает в сторону императивного стиля. Однако отметим
что совместное использование значений может оказаться нелёгкой задачей и в конце
концов более дорогостоящей, чем копирование значений с самого начала. Чистая
функциональность имеет определённую цену: частичное применение (partial
application) и использование функций переданных в виде аргумента другой функции
несёт более серьёзные накладные расходы в процессе выполнения программы, чем
явное применение видимой функции. Стоит избегать использования этой
функциональной особенности в тех местах, где критерий производительности
является решающим.

	\item [критерий разработки:] более высокий уровень абстракции
функционального стиля программирования позволяет более быстрое написание
компактного кода, содержащего меньше ошибок чем императивный вариант, который по
своей природе является более \enq{многословным}. Таким образом, функциональный
стиль является выгодным при разработке значительных программ. Независимость
функции к своему контексту окружения позволяет разделить код на более маленькие
части и тем самым облегчить его проверку и читаемость. Более высокая модульность
функционального стиля плюс возможность передавать функции (а значит и обработку)
в аргумент другим функциям повышает вероятность повторного использования
программ.
\end{description}

Эти несколько замечаний подтверждают тот факт, что часто смешанное использование
обоих стилей является рациональным выбором. Функциональный стиль быстрее в
разработке и обеспечивает более простую организацию программы, однако части кода
где необходимо повысить скорость выполнения лучше написать в императивном стиле.