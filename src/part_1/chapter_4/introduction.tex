\section{Введение}

Языки функционального и императивного программирования различаются контролем
выполнения программы и управлением памятью.

\begin{itemize}
	\item функциональная программа вычисляет выражение, в следствии чего мы
получаем некоторый результат. Порядок в котором выполнены операции расчёта и
физическое представление данных не влияют на результат, он одинаков во всех
случаях. При таком порядке вычислений, сбор памяти в Objective CAML неявно
осуществляется вызовом автоматического сборщика мусора или Garbage Collector
(GC) (см. главу \ref{??}).

	\item императивная программа это список инструкций изменяющих состояние
памяти. Каждый этап выполнения строго определён структурами контроля,
указывающими на следующую инструкцию. Такие программы чаще всего манипулируют
указателями на значение, чем самими значениями. Отсюда необходимость явного
выделения и освобождения памяти, что может порой приводить к ошибкам доступа к
памяти, однако ничто не запрещает использование GC.
\end{itemize}

Императивные языки предоставляют больший контроль над выполнением программы и
памятью. Находясь ближе к реальной машине, такой код может быть эффективнее, но
при этом код теряет в устойчивости выполнения. Функциональное программирование
предоставляет более высокий уровень абстракции и таким образом лучший уровень
устойчивости выполнения: типизация (динамическая или статическая) помогает
избежать некорректных значений, автоматическая сборка мусора, хотя и замедляет
скорость выполнения, обеспечивает правильное манипулирование областями памяти.

Исторически обе эти парадигмы программирования существовали в разных сферах:
символьные программы для первого случая и числовые для второго. Однако, с тех
времён кое--что изменилось, в частности появилась техника компиляции
функциональных языков и выросла эффективность GC. С другой стороны, устойчивость
выполнения стала важным критерием, иногда даже важнейшим критерием качества
программного обеспечения. В подтверждение этому \enq{коммерческий аргумент}
языка Java: эффективность не должна преобладать над правильностью, оставаясь при
этом благоразумно хорошей. Эта идея приобретает с каждым днем новых сторонников
в мире производителей программного обеспечения.

Objective CAML придерживается этой позиции: он объединяет обе парадигмы,
расширяя таким образом область своего применения и облегчая написание алгоритмов
в том или ином стиле. Он сохраняет, однако, хорошие свойства правильности
выполнения благодаря статической типизации, GC и механизму исключений.
Исключения — это первая структура контроля выполнения позволяющая
приостановить/продолжить расчёт при возникновении определённых условий. Эта
особенность находится на границе двух стилей программирования, хоть она и не
изменяет результат, но может изменить порядок вычислений. Введение физически
изменяемых значений может повлиять на чисто функциональную часть языка. Порядок
вычисления аргументов функции становится определимым если это вычисление
производит побочный эффект. По этим причинам подобные языки называются “не
чистые функциональные языки”. Мы теряем часть абстракции, так как программист
должен учитывать модель памяти и выполнение программы. Это не всегда плохо, в
частности для читаемости кода. Однако, императивные особенности изменяют систему
типов языка: некоторые функциональные программы, с теоретически правильными
типами, не являются правильными на практике из-за введения ссылок (reference).
Хотя такие программы могут быть легко переписаны.